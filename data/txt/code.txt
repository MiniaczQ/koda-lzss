/* 
 * Compress - data compression program 
 */
#define	min(a,b)	((a>b) ? b : a)

/*
 * machine variants which require cc -Dmachine:  pdp11, z8000, pcxt
 */

/*
 * Set USERMEM to the maximum amount of physical user memory available
 * in bytes.  USERMEM is used to determine the maximum BITS that can be used
 * for compression.
 *
 * SACREDMEM is the amount of physical memory saved for others; compress
 * will hog the rest.
 */
#ifndef SACREDMEM
#define SACREDMEM	0
#endif

#ifndef USERMEM
# define USERMEM 	450000	/* default user memory */
#endif

#ifdef interdata		/* (Perkin-Elmer) */
#define SIGNED_COMPARE_SLOW	/* signed compare is slower than unsigned */
#endif

#ifdef pdp11
# define BITS 	12	/* max bits/code for 16-bit machine */
# define NO_UCHAR	/* also if "unsigned char" functions as signed char */
# undef USERMEM 
#endif /* pdp11 */	/* don't forget to compile with -i */

#ifdef z8000
# define BITS 	12
# undef vax		/* weird preprocessor */
# undef USERMEM 
#endif /* z8000 */

#ifdef pcxt
# define BITS   12
# undef USERMEM
#endif /* pcxt */

#ifdef USERMEM
# if USERMEM >= (433484+SACREDMEM)
#  define PBITS	16
# else
#  if USERMEM >= (229600+SACREDMEM)
#   define PBITS	15
#  else
#   if USERMEM >= (127536+SACREDMEM)
#    define PBITS	14
#   else
#    if USERMEM >= (73464+SACREDMEM)
#     define PBITS	13
#    else
#     define PBITS	12
#    endif
#   endif
#  endif
# endif
# undef USERMEM
#endif /* USERMEM */

#ifdef PBITS		/* Preferred BITS for this memory size */
# ifndef BITS
#  define BITS PBITS
# endif BITS
#endif /* PBITS */

#if BITS == 16
# define HSIZE	69001		/* 95% occupancy */
#endif
#if BITS == 15
# define HSIZE	35023		/* 94% occupancy */
#endif
#if BITS == 14
# define HSIZE	18013		/* 91% occupancy */
#endif
#if BITS == 13
# define HSIZE	9001		/* 91% occupancy */
#endif
#if BITS <= 12
# define HSIZE	5003		/* 80% occupancy */
#endif

#ifdef M_XENIX			/* Stupid compiler can't handle arrays with */
# if BITS == 16			/* more than 65535 bytes - so we fake it */
#  define XENIX_16
# else
#  if BITS > 13			/* Code only handles BITS = 12, 13, or 16 */
#   define BITS	13
#  endif
# endif
#endif

/*
 * a code_int must be able to hold 2**BITS values of type int, and also -1
 */
#if BITS > 15
typedef long int	code_int;
#else
typedef int		code_int;
#endif

#ifdef SIGNED_COMPARE_SLOW
typedef unsigned long int count_int;
typedef unsigned short int count_short;
#else
typedef long int	  count_int;
#endif

#ifdef NO_UCHAR
 typedef char	char_type;
#else
 typedef	unsigned char	char_type;
#endif /* UCHAR */
char_type magic_header[] = { "\037\235" };	/* 1F 9D */

/* Defines for third byte of header */
#define BIT_MASK	0x1f
#define BLOCK_MASK	0x80
/* Masks 0x40 and 0x20 are free.  I think 0x20 should mean that there is
   a fourth header byte (for expansion).
*/
#define INIT_BITS 9			/* initial number of bits/code */

/*
 * compress.c - File compression ala IEEE Computer, June 1984.
 *
 * Authors:	Spencer W. Thomas	(decvax!harpo!utah-cs!utah-gr!thomas)
 *		Jim McKie		(decvax!mcvax!jim)
 *		Steve Davies		(decvax!vax135!petsd!peora!srd)
 *		Ken Turkowski		(decvax!decwrl!turtlevax!ken)
 *		James A. Woods		(decvax!ihnp4!ames!jaw)
 *		Joe Orost		(decvax!vax135!petsd!joe)
 *
 * $Header: compress.c,v 4.0 85/07/30 12:50:00 joe Release $
 * $Log:	compress.c,v $
 * Revision 4.0  85/07/30  12:50:00  joe
 * Removed ferror() calls in output routine on every output except first.
 * Prepared for release to the world.
 * 
 * Revision 3.6  85/07/04  01:22:21  joe
 * Remove much wasted storage by overlaying hash table with the tables
 * used by decompress: tab_suffix[1<<BITS], stack[8000].  Updated USERMEM
 * computations.  Fixed dump_tab() DEBUG routine.
 *
 * Revision 3.5  85/06/30  20:47:21  jaw
 * Change hash function to use exclusive-or.  Rip out hash cache.  These
 * speedups render the megamemory version defunct, for now.  Make decoder
 * stack global.  Parts of the RCS trunks 2.7, 2.6, and 2.1 no longer apply.
 *
 * Revision 3.4  85/06/27  12:00:00  ken
 * Get rid of all floating-point calculations by doing all compression ratio
 * calculations in fixed point.
 *
 * Revision 3.3  85/06/24  21:53:24  joe
 * Incorporate portability suggestion for M_XENIX.  Got rid of text on #else
 * and #endif lines.  Cleaned up #ifdefs for vax and interdata.
 *
 * Revision 3.2  85/06/06  21:53:24  jaw
 * Incorporate portability suggestions for Z8000, IBM PC/XT from mailing list.
 * Default to "quiet" output (no compression statistics).
 *
 * Revision 3.1  85/05/12  18:56:13  jaw
 * Integrate decompress() stack speedups (from early pointer mods by McKie).
 * Repair multi-file USERMEM gaffe.  Unify 'force' flags to mimic semantics
 * of SVR2 'pack'.  Streamline block-compress table clear logic.  Increase 
 * output byte count by magic number size.
 * 
 * Revision 3.0   84/11/27  11:50:00  petsd!joe
 * Set HSIZE depending on BITS.  Set BITS depending on USERMEM.  Unrolled
 * loops in clear routines.  Added "-C" flag for 2.0 compatibility.  Used
 * unsigned compares on Perkin-Elmer.  Fixed foreground check.
 *
 * Revision 2.7   84/11/16  19:35:39  ames!jaw
 * Cache common hash codes based on input statistics; this improves
 * performance for low-density raster images.  Pass on #ifdef bundle
 * from Turkowski.
 *
 * Revision 2.6   84/11/05  19:18:21  ames!jaw
 * Vary size of hash tables to reduce time for small files.
 * Tune PDP-11 hash function.
 *
 * Revision 2.5   84/10/30  20:15:14  ames!jaw
 * Junk chaining; replace with the simpler (and, on the VAX, faster)
 * double hashing, discussed within.  Make block compression standard.
 *
 * Revision 2.4   84/10/16  11:11:11  ames!jaw
 * Introduce adaptive reset for block compression, to boost the rate
 * another several percent.  (See mailing list notes.)
 *
 * Revision 2.3   84/09/22  22:00:00  petsd!joe
 * Implemented "-B" block compress.  Implemented REVERSE sorting of tab_next.
 * Bug fix for last bits.  Changed fwrite to putchar loop everywhere.
 *
 * Revision 2.2   84/09/18  14:12:21  ames!jaw
 * Fold in news changes, small machine typedef from thomas,
 * #ifdef interdata from joe.
 *
 * Revision 2.1   84/09/10  12:34:56  ames!jaw
 * Configured fast table lookup for 32-bit machines.
 * This cuts user time in half for b <= FBITS, and is useful for news batching
 * from VAX to PDP sites.  Also sped up decompress() [fwrite->putc] and
 * added signal catcher [plus beef in writeerr()] to delete effluvia.
 *
 * Revision 2.0   84/08/28  22:00:00  petsd!joe
 * Add check for foreground before prompting user.  Insert maxbits into
 * compressed file.  Force file being uncompressed to end with ".Z".
 * Added "-c" flag and "zcat".  Prepared for release.
 *
 * Revision 1.10  84/08/24  18:28:00  turtlevax!ken
 * Will only compress regular files (no directories), added a magic number
 * header (plus an undocumented -n flag to handle old files without headers),
 * added -f flag to force overwriting of possibly existing destination file,
 * otherwise the user is prompted for a response.  Will tack on a .Z to a
 * filename if it doesn't have one when decompressing.  Will only replace
 * file if it was compressed.
 *
 * Revision 1.9  84/08/16  17:28:00  turtlevax!ken
 * Removed scanargs(), getopt(), added .Z extension and unlimited number of
 * filenames to compress.  Flags may be clustered (-Ddvb12) or separated
 * (-D -d -v -b 12), or combination thereof.  Modes and other status is
 * copied with copystat().  -O bug for 4.2 seems to have disappeared with
 * 1.8.
 *
 * Revision 1.8  84/08/09  23:15:00  joe
 * Made it compatible with vax version, installed jim's fixes/enhancements
 *
 * Revision 1.6  84/08/01  22:08:00  joe
 * Sped up algorithm significantly by sorting the compress chain.
 *
 * Revision 1.5  84/07/13  13:11:00  srd
 * Added C version of vax asm routines.  Changed structure to arrays to
 * save much memory.  Do unsigned compares where possible (faster on
 * Perkin-Elmer)
 *
 * Revision 1.4  84/07/05  03:11:11  thomas
 * Clean up the code a little and lint it.  (Lint complains about all
 * the regs used in the asm, but I'm not going to "fix" this.)
 *
 * Revision 1.3  84/07/05  02:06:54  thomas
 * Minor fixes.
 *
 * Revision 1.2  84/07/05  00:27:27  thomas
 * Add variable bit length output.
 *
 */
static char rcs_ident[] = 
"$Header: compress.c,v 4.0 85/07/30 12:50:00 joe Release $";

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>

#define ARGVAL() (*++(*argv) || (--argc && *++argv))

int n_bits;				/* number of bits/code */
int maxbits = BITS;			/* user settable max # bits/code */
code_int maxcode;			/* maximum code, given n_bits */
code_int maxmaxcode = 1 << BITS;	/* should NEVER generate this code */
#ifdef COMPATIBLE		/* But wrong! */
# define MAXCODE(n_bits)	(1 << (n_bits) - 1)
#else
# define MAXCODE(n_bits)	((1 << (n_bits)) - 1)
#endif /* COMPATIBLE */

#ifdef XENIX_16
count_int htab0[8192];
count_int htab1[8192];
count_int htab2[8192];
count_int htab3[8192];
count_int htab4[8192];
count_int htab5[8192];
count_int htab6[8192];
count_int htab7[8192];
count_int htab8[HSIZE-65536];
count_int * htab[9] = {
	htab0, htab1, htab2, htab3, htab4, htab5, htab6, htab7, htab8 };

#define htabof(i)	(htab[(i) >> 13][(i) & 0x1fff])
unsigned short code0tab[16384];
unsigned short code1tab[16384];
unsigned short code2tab[16384];
unsigned short code3tab[16384];
unsigned short code4tab[16384];
unsigned short * codetab[5] = {
	code0tab, code1tab, code2tab, code3tab, code4tab };

#define codetabof(i)	(codetab[(i) >> 14][(i) & 0x3fff])

#else	/* Normal machine */
count_int htab [HSIZE];
unsigned short codetab [HSIZE];
#define htabof(i)	htab[i]
#define codetabof(i)	codetab[i]
#endif	/* XENIX_16 */
code_int hsize = HSIZE;			/* for dynamic table sizing */
count_int fsize;

/*
 * To save much memory, we overlay the table used by compress() with those
 * used by decompress().  The tab_prefix table is the same size and type
 * as the codetab.  The tab_suffix table needs 2**BITS characters.  We
 * get this from the beginning of htab.  The output stack uses the rest
 * of htab, and contains characters.  There is plenty of room for any
 * possible stack (stack used to be 8000 characters).
 */

#define tab_prefixof(i)	codetabof(i)
#ifdef XENIX_16
# define tab_suffixof(i)	((char_type *)htab[(i)>>15])[(i) & 0x7fff]
# define de_stack		((char_type *)(htab2))
#else	/* Normal machine */
# define tab_suffixof(i)	((char_type *)(htab))[i]
# define de_stack		((char_type *)&tab_suffixof(1<<BITS))
#endif	/* XENIX_16 */

code_int free_ent = 0;			/* first unused entry */
int exit_stat = 0;

code_int getcode();

Usage() {
#ifdef DEBUG
fprintf(stderr,"Usage: compress [-dDVfc] [-b maxbits] [file ...]\n");
}
int debug = 0;
#else
fprintf(stderr,"Usage: compress [-dfvcV] [-b maxbits] [file ...]\n");
}
#endif /* DEBUG */
int nomagic = 0;	/* Use a 3-byte magic number header, unless old file */
int zcat_flg = 0;	/* Write output on stdout, suppress messages */
int quiet = 1;		/* don't tell me about compression */

/*
 * block compression parameters -- after all codes are used up,
 * and compression rate changes, start over.
 */
int block_compress = BLOCK_MASK;
int clear_flg = 0;
long int ratio = 0;
#define CHECK_GAP 10000	/* ratio check interval */
count_int checkpoint = CHECK_GAP;
/*
 * the next two codes should not be changed lightly, as they must not
 * lie within the contiguous general code space.
 */ 
#define FIRST	257	/* first free entry */
#define	CLEAR	256	/* table clear output code */

int force = 0;
char ofname [100];
#ifdef DEBUG
int verbose = 0;
#endif /* DEBUG */
int (*bgnd_flag)();

int do_decomp = 0;

/*****************************************************************
 * TAG( main )
 *
 * Algorithm from "A Technique for High Performance Data Compression",
 * Terry A. Welch, IEEE Computer Vol 17, No 6 (June 1984), pp 8-19.
 *
 * Usage: compress [-dfvc] [-b bits] [file ...]
 * Inputs:
 *	-d:	    If given, decompression is done instead.
 *
 *      -c:         Write output on stdout, don't remove original.
 *
 *      -b:         Parameter limits the max number of bits/code.
 *
 *	-f:	    Forces output file to be generated, even if one already
 *		    exists, and even if no space is saved by compressing.
 *		    If -f is not used, the user will be prompted if stdin is
 *		    a tty, otherwise, the output file will not be overwritten.
 *
 *      -v:	    Write compression statistics
 *
 * 	file ...:   Files to be compressed.  If none specified, stdin
 *		    is used.
 * Outputs:
 *	file.Z:	    Compressed form of file with same mode, owner, and utimes
 * 	or stdout   (if stdin used as input)
 *
 * Assumptions:
 *	When filenames are given, replaces with the compressed version
 *	(.Z suffix) only if the file decreases in size.
 * Algorithm:
 * 	Modified Lempel-Ziv method (LZW).  Basically finds common
 * substrings and replaces them with a variable size code.  This is
 * deterministic, and can be done on the fly.  Thus, the decompression
 * procedure needs no input table, but tracks the way the table was built.
 */

main( argc, argv )
register int argc; char **argv;
{
    int overwrite = 0;	/* Do not overwrite unless given -f flag */
    char tempname[100];
    char **filelist, **fileptr;
    char *cp, *rindex(), *malloc();
    struct stat statbuf;
    extern onintr(), oops();


    if ( (bgnd_flag = signal ( SIGINT, SIG_IGN )) != SIG_IGN ) {
	signal ( SIGINT, onintr );
	signal ( SIGSEGV, oops );
    }

#ifdef COMPATIBLE
    nomagic = 1;	/* Original didn't have a magic number */
#endif /* COMPATIBLE */

    filelist = fileptr = (char **)(malloc(argc * sizeof(*argv)));
    *filelist = NULL;

    if((cp = rindex(argv[0], '/')) != 0) {
	cp++;
    } else {
	cp = argv[0];
    }
    if(strcmp(cp, "uncompress") == 0) {
	do_decomp = 1;
    } else if(strcmp(cp, "zcat") == 0) {
	do_decomp = 1;
	zcat_flg = 1;
    }

#ifdef BSD4_2
    /* 4.2BSD dependent - take it out if not */
    setlinebuf( stderr );
#endif /* BSD4_2 */

    /* Argument Processing
     * All flags are optional.
     * -D => debug
     * -V => print Version; debug verbose
     * -d => do_decomp
     * -v => unquiet
     * -f => force overwrite of output file
     * -n => no header: useful to uncompress old files
     * -b maxbits => maxbits.  If -b is specified, then maxbits MUST be
     *	    given also.
     * -c => cat all output to stdout
     * -C => generate output compatible with compress 2.0.
     * if a string is left, must be an input filename.
     */
    for (argc--, argv++; argc > 0; argc--, argv++) {
	if (**argv == '-') {	/* A flag argument */
	    while (*++(*argv)) {	/* Process all flags in this arg */
		switch (**argv) {
#ifdef DEBUG
		    case 'D':
			debug = 1;
			break;
		    case 'V':
			verbose = 1;
			version();
			break;
#else
		    case 'V':
			version();
			break;
#endif /* DEBUG */
		    case 'v':
			quiet = 0;
			break;
		    case 'd':
			do_decomp = 1;
			break;
		    case 'f':
		    case 'F':
			overwrite = 1;
			force = 1;
			break;
		    case 'n':
			nomagic = 1;
			break;
		    case 'C':
			block_compress = 0;
			break;
		    case 'b':
			if (!ARGVAL()) {
			    fprintf(stderr, "Missing maxbits\n");
			    Usage();
			    exit(1);
			}
			maxbits = atoi(*argv);
			goto nextarg;
		    case 'c':
			zcat_flg = 1;
			break;
		    case 'q':
			quiet = 1;
			break;
		    default:
			fprintf(stderr, "Unknown flag: '%c'; ", **argv);
			Usage();
			exit(1);
		}
	    }
	}
	else {		/* Input file name */
	    *fileptr++ = *argv;	/* Build input file list */
	    *fileptr = NULL;
	    /* process nextarg; */
	}
	nextarg: continue;
    }

    if(maxbits < INIT_BITS) maxbits = INIT_BITS;
    if (maxbits > BITS) maxbits = BITS;
    maxmaxcode = 1 << maxbits;

    if (*filelist != NULL) {
	for (fileptr = filelist; *fileptr; fileptr++) {
	    exit_stat = 0;
	    if (do_decomp != 0) {			/* DECOMPRESSION */
		/* Check for .Z suffix */
		if (strcmp(*fileptr + strlen(*fileptr) - 2, ".Z") != 0) {
		    /* No .Z: tack one on */
		    strcpy(tempname, *fileptr);
		    strcat(tempname, ".Z");
		    *fileptr = tempname;
		}
		/* Open input file */
		if ((freopen(*fileptr, "r", stdin)) == NULL) {
			perror(*fileptr); continue;
		}
		/* Check the magic number */
		if (nomagic == 0) {
		    if ((getchar() != (magic_header[0] & 0xFF))
		     || (getchar() != (magic_header[1] & 0xFF))) {
			fprintf(stderr, "%s: not in compressed format\n",
			    *fileptr);
		    continue;
		    }
		    maxbits = getchar();	/* set -b from file */
		    block_compress = maxbits & BLOCK_MASK;
		    maxbits &= BIT_MASK;
		    maxmaxcode = 1 << maxbits;
		    if(maxbits > BITS) {
			fprintf(stderr,
			"%s: compressed with %d bits, can only handle %d bits\n",
			*fileptr, maxbits, BITS);
			continue;
		    }
		}
		/* Generate output filename */
		strcpy(ofname, *fileptr);
		ofname[strlen(*fileptr) - 2] = '\0';  /* Strip off .Z */
	    } else {					/* COMPRESSION */
		if (strcmp(*fileptr + strlen(*fileptr) - 2, ".Z") == 0) {
		    	fprintf(stderr, "%s: already has .Z suffix -- no change\n",
			    *fileptr);
		    continue;
		}
		/* Open input file */
		if ((freopen(*fileptr, "r", stdin)) == NULL) {
		    perror(*fileptr); continue;
		}
		stat ( *fileptr, &statbuf );
		fsize = (long) statbuf.st_size;
		/*
		 * tune hash table size for small files -- ad hoc,
		 * but the sizes match earlier #defines, which
		 * serve as upper bounds on the number of output codes. 
		 */
		hsize = HSIZE;
		if ( fsize < (1 << 12) )
		    hsize = min ( 5003, HSIZE );
		else if ( fsize < (1 << 13) )
		    hsize = min ( 9001, HSIZE );
		else if ( fsize < (1 << 14) )
		    hsize = min ( 18013, HSIZE );
		else if ( fsize < (1 << 15) )
		    hsize = min ( 35023, HSIZE );
		else if ( fsize < 47000 )
		    hsize = min ( 50021, HSIZE );

		/* Generate output filename */
		strcpy(ofname, *fileptr);
#ifndef BSD4_2		/* Short filenames */
		if ((cp=rindex(ofname,'/')) != NULL)	cp++;
		else					cp = ofname;
		if (strlen(cp) > 12) {
		    fprintf(stderr,"%s: filename too long to tack on .Z\n",cp);
		    continue;
		}
#endif  /* BSD4_2		Long filenames allowed */
		strcat(ofname, ".Z");
	    }
	    /* Check for overwrite of existing file */
	    if (overwrite == 0 && zcat_flg == 0) {
		if (stat(ofname, &statbuf) == 0) {
		    char response[2];
		    response[0] = 'n';
		    fprintf(stderr, "%s already exists;", ofname);
		    if (foreground()) {
			fprintf(stderr, " do you wish to overwrite %s (y or n)? ",
			ofname);
			fflush(stderr);
			read(2, response, 2);
			while (response[1] != '\n') {
			    if (read(2, response+1, 1) < 0) {	/* Ack! */
				perror("stderr"); break;
			    }
			}
		    }
		    if (response[0] != 'y') {
			fprintf(stderr, "\tnot overwritten\n");
			continue;
		    }
		}
	    }
	    if(zcat_flg == 0) {		/* Open output file */
		if (freopen(ofname, "w", stdout) == NULL) {
		    perror(ofname);
		    continue;
		}
		if(!quiet)
			fprintf(stderr, "%s: ", *fileptr);
	    }

	    /* Actually do the compression/decompression */
	    if (do_decomp == 0)	compress();
#ifndef DEBUG
	    else			decompress();
#else
	    else if (debug == 0)	decompress();
	    else			printcodes();
	    if (verbose)		dump_tab();
#endif /* DEBUG */
	    if(zcat_flg == 0) {
		copystat(*fileptr, ofname);	/* Copy stats */
		if((exit_stat == 1) || (!quiet))
			putc('\n', stderr);
	    }
	}
    } else {		/* Standard input */
	if (do_decomp == 0) {
		compress();
#ifdef DEBUG
		if(verbose)		dump_tab();
#endif /* DEBUG */
		if(!quiet)
			putc('\n', stderr);
	} else {
	    /* Check the magic number */
	    if (nomagic == 0) {
		if ((getchar()!=(magic_header[0] & 0xFF))
		 || (getchar()!=(magic_header[1] & 0xFF))) {
		    fprintf(stderr, "stdin: not in compressed format\n");
		    exit(1);
		}
		maxbits = getchar();	/* set -b from file */
		block_compress = maxbits & BLOCK_MASK;
		maxbits &= BIT_MASK;
		maxmaxcode = 1 << maxbits;
		fsize = 100000;		/* assume stdin large for USERMEM */
		if(maxbits > BITS) {
			fprintf(stderr,
			"stdin: compressed with %d bits, can only handle %d bits\n",
			maxbits, BITS);
			exit(1);
		}
	    }
#ifndef DEBUG
	    decompress();
#else
	    if (debug == 0)	decompress();
	    else		printcodes();
	    if (verbose)	dump_tab();
#endif /* DEBUG */
	}
    }
    exit(exit_stat);
}

static int offset;
long int in_count = 1;			/* length of input */
long int bytes_out;			/* length of compressed output */
long int out_count = 0;			/* # of codes output (for debugging) */

/*
 * compress stdin to stdout
 *
 * Algorithm:  use open addressing double hashing (no chaining) on the 
 * prefix code / next character combination.  We do a variant of Knuth's
 * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime
 * secondary probe.  Here, the modular division first probe is gives way
 * to a faster exclusive-or manipulation.  Also do block compression with
 * an adaptive reset, whereby the code table is cleared when the compression
 * ratio decreases, but after the table fills.  The variable-length output
 * codes are re-sized at this point, and a special CLEAR code is generated
 * for the decompressor.  Late addition:  construct the table according to
 * file size for noticeable speed improvement on small files.  Please direct
 * questions about this implementation to ames!jaw.
 */

compress() {
    register long fcode;
    register code_int i = 0;
    register int c;
    register code_int ent;
#ifdef XENIX_16
    register code_int disp;
#else	/* Normal machine */
    register int disp;
#endif
    register code_int hsize_reg;
    register int hshift;

#ifndef COMPATIBLE
    if (nomagic == 0) {
	putchar(magic_header[0]); putchar(magic_header[1]);
	putchar((char)(maxbits | block_compress));
	if(ferror(stdout))
		writeerr();
    }
#endif /* COMPATIBLE */

    offset = 0;
    bytes_out = 3;		/* includes 3-byte header mojo */
    out_count = 0;
    clear_flg = 0;
    ratio = 0;
    in_count = 1;
    checkpoint = CHECK_GAP;
    maxcode = MAXCODE(n_bits = INIT_BITS);
    free_ent = ((block_compress) ? FIRST : 256 );

    ent = getchar ();

    hshift = 0;
    for ( fcode = (long) hsize;  fcode < 65536L; fcode *= 2L )
    	hshift++;
    hshift = 8 - hshift;		/* set hash code range bound */

    hsize_reg = hsize;
    cl_hash( (count_int) hsize_reg);		/* clear hash table */

#ifdef SIGNED_COMPARE_SLOW
    while ( (c = getchar()) != (unsigned) EOF ) {
#else
    while ( (c = getchar()) != EOF ) {
#endif
	in_count++;
	fcode = (long) (((long) c << maxbits) + ent);
 	i = ((c << hshift) ^ ent);	/* xor hashing */

	if ( htabof (i) == fcode ) {
	    ent = codetabof (i);
	    continue;
	} else if ( (long)htabof (i) < 0 )	/* empty slot */
	    goto nomatch;
 	disp = hsize_reg - i;		/* secondary hash (after G. Knott) */
	if ( i == 0 )
	    disp = 1;
probe:
	if ( (i -= disp) < 0 )
	    i += hsize_reg;

	if ( htabof (i) == fcode ) {
	    ent = codetabof (i);
	    continue;
	}
	if ( (long)htabof (i) > 0 ) 
	    goto probe;
nomatch:
	output ( (code_int) ent );
	out_count++;
 	ent = c;
#ifdef SIGNED_COMPARE_SLOW
	if ( (unsigned) free_ent < (unsigned) maxmaxcode) {
#else
	if ( free_ent < maxmaxcode ) {
#endif
 	    codetabof (i) = free_ent++;	/* code -> hashtable */
	    htabof (i) = fcode;
	}
	else if ( (count_int)in_count >= checkpoint && block_compress )
	    cl_block ();
    }
    /*
     * Put out the final code.
     */
    output( (code_int)ent );
    out_count++;
    output( (code_int)-1 );

    /*
     * Print out stats on stderr
     */
    if(zcat_flg == 0 && !quiet) {
#ifdef DEBUG
	fprintf( stderr,
		"%ld chars in, %ld codes (%ld bytes) out, compression factor: ",
		in_count, out_count, bytes_out );
	prratio( stderr, in_count, bytes_out );
	fprintf( stderr, "\n");
	fprintf( stderr, "\tCompression as in compact: " );
	prratio( stderr, in_count-bytes_out, in_count );
	fprintf( stderr, "\n");
	fprintf( stderr, "\tLargest code (of last block) was %d (%d bits)\n",
		free_ent - 1, n_bits );
#else /* !DEBUG */
	fprintf( stderr, "Compression: " );
	prratio( stderr, in_count-bytes_out, in_count );
#endif /* DEBUG */
    }
    if(bytes_out > in_count)	/* exit(2) if no savings */
	exit_stat = 2;
    return;
}

/*****************************************************************
 * TAG( output )
 *
 * Output the given code.
 * Inputs:
 * 	code:	A n_bits-bit integer.  If == -1, then EOF.  This assumes
 *		that n_bits =< (long)wordsize - 1.
 * Outputs:
 * 	Outputs code to the file.
 * Assumptions:
 *	Chars are 8 bits long.
 * Algorithm:
 * 	Maintain a BITS character long buffer (so that 8 codes will
 * fit in it exactly).  Use the VAX insv instruction to insert each
 * code in turn.  When the buffer fills up empty it and start over.
 */

static char buf[BITS];

#ifndef vax
char_type lmask[9] = {0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00};
char_type rmask[9] = {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};
#endif /* vax */

output( code )
code_int  code;
{
#ifdef DEBUG
    static int col = 0;
#endif /* DEBUG */

    /*
     * On the VAX, it is important to have the register declarations
     * in exactly the order given, or the asm will break.
     */
    register int r_off = offset, bits= n_bits;
    register char * bp = buf;

#ifdef DEBUG
	if ( verbose )
	    fprintf( stderr, "%5d%c", code,
		    (col+=6) >= 74 ? (col = 0, '\n') : ' ' );
#endif /* DEBUG */
    if ( code >= 0 ) {
#ifdef vax
	/* VAX DEPENDENT!! Implementation on other machines is below.
	 *
	 * Translation: Insert BITS bits from the argument starting at
	 * offset bits from the beginning of buf.
	 */
	0;	/* Work around for pcc -O bug with asm and if stmt */
	asm( "insv	4(ap),r11,r10,(r9)" );
#else /* not a vax */
/* 
 * byte/bit numbering on the VAX is simulated by the following code
 */
	/*
	 * Get to the first byte.
	 */
	bp += (r_off >> 3);
	r_off &= 7;
	/*
	 * Since code is always >= 8 bits, only need to mask the first
	 * hunk on the left.
	 */
	*bp = (*bp & rmask[r_off]) | (code << r_off) & lmask[r_off];
	bp++;
	bits -= (8 - r_off);
	code >>= 8 - r_off;
	/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
	if ( bits >= 8 ) {
	    *bp++ = code;
	    code >>= 8;
	    bits -= 8;
	}
	/* Last bits. */
	if(bits)
	    *bp = code;
#endif /* vax */
	offset += n_bits;
	if ( offset == (n_bits << 3) ) {
	    bp = buf;
	    bits = n_bits;
	    bytes_out += bits;
	    do
		putchar(*bp++);
	    while(--bits);
	    offset = 0;
	}

	/*
	 * If the next entry is going to be too big for the code size,
	 * then increase it, if possible.
	 */
	if ( free_ent > maxcode || (clear_flg > 0))
	{
	    /*
	     * Write the whole buffer, because the input side won't
	     * discover the size increase until after it has read it.
	     */
	    if ( offset > 0 ) {
		if( fwrite( buf, 1, n_bits, stdout ) != n_bits)
			writeerr();
		bytes_out += n_bits;
	    }
	    offset = 0;

	    if ( clear_flg ) {
    	        maxcode = MAXCODE (n_bits = INIT_BITS);
	        clear_flg = 0;
	    }
	    else {
	    	n_bits++;
	    	if ( n_bits == maxbits )
		    maxcode = maxmaxcode;
	    	else
		    maxcode = MAXCODE(n_bits);
	    }
#ifdef DEBUG
	    if ( debug ) {
		fprintf( stderr, "\nChange to %d bits\n", n_bits );
		col = 0;
	    }
#endif /* DEBUG */
	}
    } else {
	/*
	 * At EOF, write the rest of the buffer.
	 */
	if ( offset > 0 )
	    fwrite( buf, 1, (offset + 7) / 8, stdout );
	bytes_out += (offset + 7) / 8;
	offset = 0;
	fflush( stdout );
#ifdef DEBUG
	if ( verbose )
	    fprintf( stderr, "\n" );
#endif /* DEBUG */
	if( ferror( stdout ) )
		writeerr();
    }
}

/*
 * Decompress stdin to stdout.  This routine adapts to the codes in the
 * file building the "string" table on-the-fly; requiring no table to
 * be stored in the compressed file.  The tables used herein are shared
 * with those of the compress() routine.  See the definitions above.
 */

decompress() {
    register char_type *stackp;
    register int finchar;
    register code_int code, oldcode, incode;

    /*
     * As above, initialize the first 256 entries in the table.
     */
    maxcode = MAXCODE(n_bits = INIT_BITS);
    for ( code = 255; code >= 0; code-- ) {
	tab_prefixof(code) = 0;
	tab_suffixof(code) = (char_type)code;
    }
    free_ent = ((block_compress) ? FIRST : 256 );

    finchar = oldcode = getcode();
    if(oldcode == -1)	/* EOF already? */
	return;			/* Get out of here */
    putchar( (char)finchar );		/* first code must be 8 bits = char */
    if(ferror(stdout))		/* Crash if can't write */
	writeerr();
    stackp = de_stack;

    while ( (code = getcode()) > -1 ) {

	if ( (code == CLEAR) && block_compress ) {
	    for ( code = 255; code >= 0; code-- )
		tab_prefixof(code) = 0;
	    clear_flg = 1;
	    free_ent = FIRST - 1;
	    if ( (code = getcode ()) == -1 )	/* O, untimely death! */
		break;
	}
	incode = code;
	/*
	 * Special case for KwKwK string.
	 */
	if ( code >= free_ent ) {
            *stackp++ = finchar;
	    code = oldcode;
	}

	/*
	 * Generate output characters in reverse order
	 */
#ifdef SIGNED_COMPARE_SLOW
	while ( ((unsigned long)code) >= ((unsigned long)256) ) {
#else
	while ( code >= 256 ) {
#endif
	    *stackp++ = tab_suffixof(code);
	    code = tab_prefixof(code);
	}
	*stackp++ = finchar = tab_suffixof(code);

	/*
	 * And put them out in forward order
	 */
	do
	    putchar ( *--stackp );
	while ( stackp > de_stack );

	/*
	 * Generate the new entry.
	 */
	if ( (code=free_ent) < maxmaxcode ) {
	    tab_prefixof(code) = (unsigned short)oldcode;
	    tab_suffixof(code) = finchar;
	    free_ent = code+1;
	} 
	/*
	 * Remember previous code.
	 */
	oldcode = incode;
    }
    fflush( stdout );
    if(ferror(stdout))
	writeerr();
}

/*****************************************************************
 * TAG( getcode )
 *
 * Read one code from the standard input.  If EOF, return -1.
 * Inputs:
 * 	stdin
 * Outputs:
 * 	code or -1 is returned.
 */

code_int
getcode() {
    /*
     * On the VAX, it is important to have the register declarations
     * in exactly the order given, or the asm will break.
     */
    register code_int code;
    static int offset = 0, size = 0;
    static char_type buf[BITS];
    register int r_off, bits;
    register char_type *bp = buf;

    if ( clear_flg > 0 || offset >= size || free_ent > maxcode ) {
	/*
	 * If the next entry will be too big for the current code
	 * size, then we must increase the size.  This implies reading
	 * a new buffer full, too.
	 */
	if ( free_ent > maxcode ) {
	    n_bits++;
	    if ( n_bits == maxbits )
		maxcode = maxmaxcode;	/* won't get any bigger now */
	    else
		maxcode = MAXCODE(n_bits);
	}
	if ( clear_flg > 0) {
    	    maxcode = MAXCODE (n_bits = INIT_BITS);
	    clear_flg = 0;
	}
	size = fread( buf, 1, n_bits, stdin );
	if ( size <= 0 )
	    return -1;			/* end of file */
	offset = 0;
	/* Round size down to integral number of codes */
	size = (size << 3) - (n_bits - 1);
    }
    r_off = offset;
    bits = n_bits;
#ifdef vax
    asm( "extzv   r10,r9,(r8),r11" );
#else /* not a vax */
	/*
	 * Get to the first byte.
	 */
	bp += (r_off >> 3);
	r_off &= 7;
	/* Get first part (low order bits) */
#ifdef NO_UCHAR
	code = ((*bp++ >> r_off) & rmask[8 - r_off]) & 0xff;
#else
	code = (*bp++ >> r_off);
#endif /* NO_UCHAR */
	bits -= (8 - r_off);
	r_off = 8 - r_off;		/* now, offset into code word */
	/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
	if ( bits >= 8 ) {
#ifdef NO_UCHAR
	    code |= (*bp++ & 0xff) << r_off;
#else
	    code |= *bp++ << r_off;
#endif /* NO_UCHAR */
	    r_off += 8;
	    bits -= 8;
	}
	/* high order bits. */
	code |= (*bp & rmask[bits]) << r_off;
#endif /* vax */
    offset += n_bits;

    return code;
}

char *
rindex(s, c)		/* For those who don't have it in libc.a */
register char *s, c;
{
	char *p;
	for (p = NULL; *s; s++)
	    if (*s == c)
		p = s;
	return(p);
}

#ifdef DEBUG
printcodes()
{
    /*
     * Just print out codes from input file.  For debugging.
     */
    code_int code;
    int col = 0, bits;

    bits = n_bits = INIT_BITS;
    maxcode = MAXCODE(n_bits);
    free_ent = ((block_compress) ? FIRST : 256 );
    while ( ( code = getcode() ) >= 0 ) {
	if ( (code == CLEAR) && block_compress ) {
   	    free_ent = FIRST - 1;
   	    clear_flg = 1;
	}
	else if ( free_ent < maxmaxcode )
	    free_ent++;
	if ( bits != n_bits ) {
	    fprintf(stderr, "\nChange to %d bits\n", n_bits );
	    bits = n_bits;
	    col = 0;
	}
	fprintf(stderr, "%5d%c", code, (col+=6) >= 74 ? (col = 0, '\n') : ' ' );
    }
    putc( '\n', stderr );
    exit( 0 );
}

code_int sorttab[1<<BITS];	/* sorted pointers into htab */

dump_tab()	/* dump string table */
{
    register int i, first;
    register ent;
#define STACK_SIZE	15000
    int stack_top = STACK_SIZE;
    register c;

    if(do_decomp == 0) {	/* compressing */
	register int flag = 1;

	for(i=0; i<hsize; i++) {	/* build sort pointers */
		if((long)htabof(i) >= 0) {
			sorttab[codetabof(i)] = i;
		}
	}
	first = block_compress ? FIRST : 256;
	for(i = first; i < free_ent; i++) {
		fprintf(stderr, "%5d: \"", i);
		de_stack[--stack_top] = '\n';
		de_stack[--stack_top] = '"';
		stack_top = in_stack((htabof(sorttab[i])>>maxbits)&0xff, 
                                     stack_top);
		for(ent=htabof(sorttab[i]) & ((1<<maxbits)-1);
		    ent > 256;
		    ent=htabof(sorttab[ent]) & ((1<<maxbits)-1)) {
			stack_top = in_stack(htabof(sorttab[ent]) >> maxbits,
						stack_top);
		}
		stack_top = in_stack(ent, stack_top);
		fwrite( &de_stack[stack_top], 1, STACK_SIZE-stack_top, stderr);
	   	stack_top = STACK_SIZE;
	}
   } else if(!debug) {	/* decompressing */

       for ( i = 0; i < free_ent; i++ ) {
	   ent = i;
	   c = tab_suffixof(ent);
	   if ( isascii(c) && isprint(c) )
	       fprintf( stderr, "%5d: %5d/'%c'  \"",
			   ent, tab_prefixof(ent), c );
	   else
	       fprintf( stderr, "%5d: %5d/\\%03o \"",
			   ent, tab_prefixof(ent), c );
	   de_stack[--stack_top] = '\n';
	   de_stack[--stack_top] = '"';
	   for ( ; ent != NULL;
		   ent = (ent >= FIRST ? tab_prefixof(ent) : NULL) ) {
	       stack_top = in_stack(tab_suffixof(ent), stack_top);
	   }
	   fwrite( &de_stack[stack_top], 1, STACK_SIZE - stack_top, stderr );
	   stack_top = STACK_SIZE;
       }
    }
}

int
in_stack(c, stack_top)
	register c, stack_top;
{
	if ( (isascii(c) && isprint(c) && c != '\\') || c == ' ' ) {
	    de_stack[--stack_top] = c;
	} else {
	    switch( c ) {
	    case '\n': de_stack[--stack_top] = 'n'; break;
	    case '\t': de_stack[--stack_top] = 't'; break;
	    case '\b': de_stack[--stack_top] = 'b'; break;
	    case '\f': de_stack[--stack_top] = 'f'; break;
	    case '\r': de_stack[--stack_top] = 'r'; break;
	    case '\\': de_stack[--stack_top] = '\\'; break;
	    default:
	 	de_stack[--stack_top] = '0' + c % 8;
	 	de_stack[--stack_top] = '0' + (c / 8) % 8;
	 	de_stack[--stack_top] = '0' + c / 64;
	 	break;
	    }
	    de_stack[--stack_top] = '\\';
	}
	return stack_top;
}
#endif /* DEBUG */

writeerr()
{
    perror ( ofname );
    unlink ( ofname );
    exit ( 1 );
}

copystat(ifname, ofname)
char *ifname, *ofname;
{
    struct stat statbuf;
    int mode;
    time_t timep[2];

    fclose(stdout);
    if (stat(ifname, &statbuf)) {		/* Get stat on input file */
	perror(ifname);
	return;
    }
    if ((statbuf.st_mode & S_IFMT/*0170000*/) != S_IFREG/*0100000*/) {
	if(quiet)
	    	fprintf(stderr, "%s: ", ifname);
	fprintf(stderr, " -- not a regular file: unchanged");
	exit_stat = 1;
    } else if (statbuf.st_nlink > 1) {
	if(quiet)
	    	fprintf(stderr, "%s: ", ifname);
	fprintf(stderr, " -- has %d other links: unchanged",
		statbuf.st_nlink - 1);
	exit_stat = 1;
    } else if (exit_stat == 2 && (!force)) { /* No compression: rm file.Z */
	if(!quiet)
		fprintf(stderr, " -- file unchanged");
    } else {			/* ***** Successful Compression ***** */
	exit_stat = 0;
	mode = statbuf.st_mode & 07777;
	if (chmod(ofname, mode))		/* Copy modes */
	    perror(ofname);
	chown(ofname, statbuf.st_uid, statbuf.st_gid);	/* Copy ownership */
	timep[0] = statbuf.st_atime;
	timep[1] = statbuf.st_mtime;
	utime(ofname, timep);	/* Update last accessed and modified times */
	if (unlink(ifname))	/* Remove input file */
	    perror(ifname);
	if(!quiet)
		fprintf(stderr, " -- replaced with %s", ofname);
	return;		/* Successful return */
    }

    /* Unsuccessful return -- one of the tests failed */
    if (unlink(ofname))
	perror(ofname);
}
/*
 * This routine returns 1 if we are running in the foreground and stderr
 * is a tty.
 */
foreground()
{
	if(bgnd_flag) {	/* background? */
		return(0);
	} else {			/* foreground */
		if(isatty(2)) {		/* and stderr is a tty */
			return(1);
		} else {
			return(0);
		}
	}
}

onintr ( )
{
    unlink ( ofname );
    exit ( 1 );
}

oops ( )	/* wild pointer -- assume bad input */
{
    if ( do_decomp == 1 ) 
    	fprintf ( stderr, "uncompress: corrupt input\n" );
    unlink ( ofname );
    exit ( 1 );
}

cl_block ()		/* table clear for block compress */
{
    register long int rat;

    checkpoint = in_count + CHECK_GAP;
#ifdef DEBUG
	if ( debug ) {
    		fprintf ( stderr, "count: %ld, ratio: ", in_count );
     		prratio ( stderr, in_count, bytes_out );
		fprintf ( stderr, "\n");
	}
#endif /* DEBUG */

    if(in_count > 0x007fffff) {	/* shift will overflow */
	rat = bytes_out >> 8;
	if(rat == 0) {		/* Don't divide by zero */
	    rat = 0x7fffffff;
	} else {
	    rat = in_count / rat;
	}
    } else {
	rat = (in_count << 8) / bytes_out;	/* 8 fractional bits */
    }
    if ( rat > ratio ) {
	ratio = rat;
    } else {
	ratio = 0;
#ifdef DEBUG
	if(verbose)
		dump_tab();	/* dump string table */
#endif
 	cl_hash ( (count_int) hsize );
	free_ent = FIRST;
	clear_flg = 1;
	output ( (code_int) CLEAR );
#ifdef DEBUG
	if(debug)
    		fprintf ( stderr, "clear\n" );
#endif /* DEBUG */
    }
}

cl_hash(hsize)		/* reset code table */
	register count_int hsize;
{
#ifndef XENIX_16	/* Normal machine */
	register count_int *htab_p = htab+hsize;
#else
	register j;
	register long k = hsize;
	register count_int *htab_p;
#endif
	register long i;
	register long m1 = -1;

#ifdef XENIX_16
    for(j=0; j<=8 && k>=0; j++,k-=8192) {
	i = 8192;
	if(k < 8192) {
		i = k;
	}
	htab_p = &(htab[j][i]);
	i -= 16;
	if(i > 0) {
#else
	i = hsize - 16;
#endif
 	do {				/* might use Sys V memset(3) here */
		*(htab_p-16) = m1;
		*(htab_p-15) = m1;
		*(htab_p-14) = m1;
		*(htab_p-13) = m1;
		*(htab_p-12) = m1;
		*(htab_p-11) = m1;
		*(htab_p-10) = m1;
		*(htab_p-9) = m1;
		*(htab_p-8) = m1;
		*(htab_p-7) = m1;
		*(htab_p-6) = m1;
		*(htab_p-5) = m1;
		*(htab_p-4) = m1;
		*(htab_p-3) = m1;
		*(htab_p-2) = m1;
		*(htab_p-1) = m1;
		htab_p -= 16;
	} while ((i -= 16) >= 0);
#ifdef XENIX_16
	}
    }
#endif
    	for ( i += 16; i > 0; i-- )
		*--htab_p = m1;
}

prratio(stream, num, den)
FILE *stream;
long int num, den;
{
	register int q;			/* Doesn't need to be long */

	if(num > 214748L) {		/* 2147483647/10000 */
		q = num / (den / 10000L);
	} else {
		q = 10000L * num / den;		/* Long calculations, though */
	}
	if (q < 0) {
		putc('-', stream);
		q = -q;
	}
	fprintf(stream, "%d.%02d%%", q / 100, q % 100);
}

version()
{
	fprintf(stderr, "%s\n", rcs_ident);
	fprintf(stderr, "Options: ");
#ifdef vax
	fprintf(stderr, "vax, ");
#endif
#ifdef NO_UCHAR
	fprintf(stderr, "NO_UCHAR, ");
#endif
#ifdef SIGNED_COMPARE_SLOW
	fprintf(stderr, "SIGNED_COMPARE_SLOW, ");
#endif
#ifdef XENIX_16
	fprintf(stderr, "XENIX_16, ");
#endif
#ifdef COMPATIBLE
	fprintf(stderr, "COMPATIBLE, ");
#endif
#ifdef DEBUG
	fprintf(stderr, "DEBUG, ");
#endif
#ifdef BSD4_2
	fprintf(stderr, "BSD4_2, ");
#endif
	fprintf(stderr, "BITS = %d\n", BITS);
}
#ifndef lint
static char Rcs_Id[] =
    "$Id: fields.c,v 1.7 1994/01/06 05:26:37 geoff Exp $";
#endif

/*
 * $Log: fields.c,v $
 * Revision 1.7  1994/01/06  05:26:37  geoff
 * Get rid of all references to System V string routines, for portability
 * (sigh).
 *
 * Revision 1.6  1994/01/05  20:13:43  geoff
 * Add the maxf parameter
 *
 * Revision 1.5  1994/01/04  02:40:21  geoff
 * Make the increments settable (field_line_inc and field_field_inc).
 * Add support for the FLD_NOSHRINK flag.
 *
 * Revision 1.4  1993/09/27  17:48:02  geoff
 * Fix some lint complaints and some parenthesization errors.
 *
 * Revision 1.3  1993/09/09  01:11:11  geoff
 * Add a return value to fieldwrite.  Add support for backquotes and for
 * unstripped backslashes.
 *
 * Revision 1.2  1993/08/26  00:02:50  geoff
 * Fix a stupid null-pointer bug
 *
 * Revision 1.1  1993/08/25  21:32:05  geoff
 * Initial revision
 *
 */

#include <stdio.h>
#include "config.h"
#include "fields.h"

field_t *	fieldread P ((FILE * file, char * delims,
				  int flags, int maxf));
				/* Read a line with fields from a file */
field_t *	fieldmake P ((char * line, int allocated, char * delims,
				  int flags, int maxf));
				/* Make a field structure from a line */
static field_t * fieldparse P ((field_t * fieldp, char * line, char * delims,
				  int flags, int maxf));
				/* Parse the fields in a line */
static int	fieldbackch P ((char * str, char ** out, int strip));
				/* Process backslash sequences */
int		fieldwrite P ((FILE * file, field_t * fieldp, int delim));
				/* Write a line with fields to a file */
void		fieldfree P ((field_t * fieldp));
				/* Free a field returned by fieldread */

unsigned int	field_field_inc = 20; /* Increment to increase # fields by */
unsigned int	field_line_inc = 512; /* Incr to increase line length by */

#ifndef USG
#define strchr	index
#endif /* USG */

extern void	free ();
extern char *	malloc ();
extern char *	realloc ();
extern char *	strchr ();
extern int	strlen ();

/*
 * Read one line of the given file into a buffer, break it up into
 * fields, and return them to the caller.  The field_t structure
 * returned must eventually be freed with fieldfree.
 */
field_t * fieldread (file, delims, flags, maxf)
    FILE *		file;	/* File to read lines from */
    char *		delims;	/* Characters to use for field delimiters */
    int			flags;	/* Option flags;  see fields.h */
    int			maxf;	/* Maximum number of fields to parse */
    {
    register char *	linebuf; /* Buffer to hold the line read in */
    int			linemax; /* Maximum line buffer size */
    int			linesize; /* Current line buffer size */

    linebuf = (char *) malloc (field_line_inc);
    if (linebuf == NULL)
	return NULL;
    linemax = field_line_inc;
    linesize = 0;
    /*
     * Read in the line.
     */
    while (fgets (&linebuf[linesize], linemax - linesize, file)
      != NULL)
	{
	linesize += strlen (&linebuf[linesize]);
	if (linebuf[linesize - 1] == '\n')
	    break;
	else
	    {
	    linemax += field_line_inc;
	    linebuf = (char *) realloc (linebuf, linemax);
	    if (linebuf == NULL)
		return NULL;
	    }
	}
    if (linesize == 0)
	{
	free (linebuf);
	return NULL;
	}
    return fieldmake (linebuf, 1, delims, flags, maxf);
    }

field_t * fieldmake (line, allocated, delims, flags, maxf)
    char *		line;	/* Line to make into a field structure */
    int			allocated; /* NZ if line allocated with malloc */
    char *		delims;	/* Characters to use for field delimiters */
    int			flags;	/* Option flags;  see fields.h */
    int			maxf;	/* Maximum number of fields to parse */
    {
    register field_t *	fieldp;	/* Structure describing the fields */
    int			linesize; /* Current line buffer size */

    fieldp = (field_t *) malloc (sizeof (field_t));
    if (fieldp == NULL)
	return NULL;
    fieldp->nfields = 0;
    fieldp->linebuf = allocated ? line : NULL;
    fieldp->fields = NULL;
    fieldp->hadnl = 0;
    linesize = strlen (line);
    if (line[linesize - 1] == '\n')
	{
	line[--linesize] = '\0';
	fieldp->hadnl = 1;
	}
    /*
     * Shrink the line buffer if necessary.
     */
    if (allocated  &&  (flags & FLD_NOSHRINK) == 0)
	{
	line = fieldp->linebuf =
	  (char *) realloc (fieldp->linebuf, linesize + 1);
	if (fieldp->linebuf == NULL)
	    {
	    fieldfree (fieldp);
	    return NULL;
	    }
	}
    return fieldparse (fieldp, line, delims, flags, maxf);
    }

static field_t * fieldparse (fieldp, line, delims, flags, maxf)
    register field_t *	fieldp;	/* Field structure to parse into */
    register char *	line;	/* Line to be parsed */
    char *		delims;	/* Characters to use for field delimiters */
    int			flags;	/* Option flags;  see fields.h */
    int			maxf;	/* Maximum number of fields to parse */
    {
    int			fieldmax; /* Max size of fields array */
    char *		lineout; /* Where to store xlated char in line */
    char		quote;	/* Quote character in use */

    fieldp->nfields = 0;
    fieldmax =
      (maxf != 0  &&  maxf < field_field_inc) ? maxf + 2 : field_field_inc;
    fieldp->fields = (char **) malloc (fieldmax * sizeof (char *));
    if (fieldp->fields == NULL)
	{
	fieldfree (fieldp);
	return NULL;
	}
    if ((flags
	& (FLD_SHQUOTES | FLD_SNGLQUOTES | FLD_BACKQUOTES | FLD_DBLQUOTES))
      == FLD_SHQUOTES)
	flags |= FLD_SNGLQUOTES | FLD_BACKQUOTES | FLD_DBLQUOTES;
    while (1)
	{
	if (flags & FLD_RUNS)
	    {
	    while (*line != '\0'  &&  strchr (delims, *line) != NULL)
		line++;			/* Skip runs of delimiters */
	    if (*line == '\0')
		break;
	    }
	fieldp->fields[fieldp->nfields] = lineout = line;
	/*
	 * Skip to the next delimiter.  At the end of skipping, "line" will
	 * point to either a delimiter or a null byte.
	 */
	if (flags
	  & (FLD_SHQUOTES | FLD_SNGLQUOTES | FLD_BACKQUOTES
	    | FLD_DBLQUOTES | FLD_BACKSLASH))
	    {
	    while (*line != '\0')
		{
		if (strchr (delims, *line) != NULL)
		    break;
		else if (((flags & FLD_SNGLQUOTES)  &&  *line == '\'')
		  ||  ((flags & FLD_BACKQUOTES)  &&  *line == '`')
		  ||  ((flags & FLD_DBLQUOTES)  &&  *line == '"'))
		    {
		    if ((flags & FLD_SHQUOTES) == 0
		      &&  line != fieldp->fields[fieldp->nfields])
			quote = '\0';
		    else
			quote = *line;
		    }
		else
		    quote = '\0';
		if (quote == '\0')
		    {
		    if (*line == '\\'  &&  (flags & FLD_BACKSLASH))
			{
			line++;
			if (*line == '\0')
			    break;
			line += fieldbackch (line, &lineout,
			  flags & FLD_STRIPQUOTES);
			}
		    else
			*lineout++ = *line++;
		    }
		else
		    {
		    /* Process quoted string */
		    if ((flags & FLD_STRIPQUOTES) == 0)
			*lineout++ = quote;
		    ++line;
		    while (*line != '\0')
			{
			if (*line == quote)
			    {
			    if ((flags & FLD_STRIPQUOTES) == 0)
				*lineout++ = quote;
			    line++;		/* Go on past quote */
			    if ((flags & FLD_SHQUOTES) == 0)
				{
				while (*line != '\0'
				  &&  strchr (delims, *line) == NULL)
				    line++;	/* Skip to delimiter */
				}
			    break;
			    }
			else if (*line == '\\')
			    {
			    if (flags & FLD_BACKSLASH)
				{
				line++;
				if (*line == '\0')
				    break;
				else
				    line += fieldbackch (line, &lineout,
				      flags & FLD_STRIPQUOTES);
				}
			    else
				{
				*lineout++ = '\\';
				if (*++line == '\0')
				    break;
				*lineout++ = *line;
				}
			    }
			else
			    *lineout++ = *line++;
			}
		    }
		}
	    }
	else
	    {
	    while (*line != '\0'  &&  strchr (delims, *line) == NULL)
		line++;			/* Skip to delimiter */
	    lineout = line;
	    }
	fieldp->nfields++;
	if (*line++ == '\0')
	    break;
	if (maxf != 0  &&  fieldp->nfields > maxf)
	    break;
	*lineout = '\0';
	if (fieldp->nfields >= fieldmax)
	    {
	    fieldmax += field_field_inc;
	    fieldp->fields =
	      (char **) realloc (fieldp->fields, fieldmax * sizeof (char *));
	    if (fieldp->fields == NULL)
		{
		fieldfree (fieldp);
		return NULL;
		}
	    }
	}
    /*
     * Shrink the field pointers and return the field structure.
     */
    if ((flags & FLD_NOSHRINK) == 0  &&  fieldp->nfields >= fieldmax)
	{
	fieldp->fields = (char **) realloc (fieldp->fields,
	  (fieldp->nfields + 1) * sizeof (char *));
	if (fieldp->fields == NULL)
	    {
	    fieldfree (fieldp);
	    return NULL;
	    }
	}
    fieldp->fields[fieldp->nfields] = NULL;
    return fieldp;
    }

static int fieldbackch (str, out, strip)
    register char *	str;		/* First char of backslash sequence */
    register char **	out;		/* Where to store result */
    int			strip;		/* NZ to convert the sequence */
    {
    register int	ch;		/* Character being developed */
    char *		origstr;	/* Original value of str */

    if (!strip)
	{
	*(*out)++ = '\\';
	if (*str != 'x'  &&  *str != 'X'  &&  (*str < '0'  ||  *str > '7'))
	    {
	    *(*out)++ = *str;
	    return *str != '\0';
	    }
	}
    switch (*str)
	{
	case '\0':
	    *(*out)++ = '\0';
	    return 0;
	case 'a':
	    *(*out)++ = '\007';
	    return 1;
	case 'b':
	    *(*out)++ = '\b';
	    return 1;
	case 'f':
	    *(*out)++ = '\f';
	    return 1;
	case 'n':
	    *(*out)++ = '\n';
	    return 1;
	case 'r':
	    *(*out)++ = '\r';
	    return 1;
	case 'v':
	    *(*out)++ = '\v';
	    return 1;
	case 'X':
	case 'x':
	    /* Hexadecimal sequence */
	    origstr = str++;
	    ch = 0;
	    if (*str >= '0'  &&  *str <= '9')
		ch = *str++ - '0';
	    else if (*str >= 'a'  &&  *str <= 'f')
		ch = *str++ - 'a' + 0xa;
	    else if (*str >= 'A'  &&  *str <= 'F')
		ch = *str++ - 'A' + 0xa;
	    if (*str >= '0'  &&  *str <= '9')
		ch = (ch << 4) | (*str++ - '0');
	    else if (*str >= 'a'  &&  *str <= 'f')
		ch = (ch << 4) | (*str++ - 'a' + 0xa);
	    else if (*str >= 'A'  &&  *str <= 'F')
		ch = (ch << 4) | (*str++ - 'A' + 0xa);
	    break;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	    /* Octal sequence */
	    origstr = str;
	    ch = *str++ - '0';
	    if (*str >= '0'  &&  *str <= '7')
		ch = (ch << 3) | (*str++ - '0');
	    if (*str >= '0'  &&  *str <= '7')
		ch = (ch << 3) | (*str++ - '0');
	    break;
	default:
	    *(*out)++ = *str;
	    return 1;
	}
    if (strip)
	{
	*(*out)++ = ch;
	return str - origstr;
	}
    else
	{
	for (ch = 0;  origstr < str;  ch++)
	    *(*out)++ = *origstr++;
	return ch;
	}
    }

int fieldwrite (file, fieldp, delim)
    FILE *		file;	/* File to write to */
    register field_t *	fieldp;	/* Field structure to write */
    int			delim;	/* Delimiter to place between fields */
    {
    int			error;	/* NZ if an error occurs */
    register int	fieldno; /* Number of field being written */

    error = 0;
    for (fieldno = 0;  fieldno < fieldp->nfields;  fieldno++)
	{
	if (fieldno != 0)
	    error |= putc (delim, file) == EOF;
	error |= fputs (fieldp->fields[fieldno], file) == EOF;
	}
    if (fieldp->hadnl)
	error |= putc ('\n', file) == EOF;
    return error;
    }

void fieldfree (fieldp)
    register field_t *	fieldp;	/* Field structure to free */
    {

    if (fieldp == NULL)
	return;
    if (fieldp->linebuf != NULL)
	free ((char *) fieldp->linebuf);
    if (fieldp->fields != NULL)
	free ((char *) fieldp->fields);
    free ((char *) fieldp);
    }
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; form.l -- screen forms handler
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare
  (specials t)
  (macros t))

(eval-when (compile)
  (load 'utilities)
  (load 'constants)
  (load 'zone)
  (load 'look)
  (load 'font)
  (load 'text)
  (load 'text-edit))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;						generic fields
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defstruct
  (field		; generic field
    (:displace t)
    (:list)
    (:conc-name))
  (type 'generic-field)		; type = generic
  (zone (make-zone))		; bounding zone
  (properties (list nil))	; empty property list
)

(defvar field-properties	; list of expected field properties
  '("field-properties"
    fill-ground		(solid pattern)		; should we draw when highlit?
    fill-colour		(x_colour x_pattern)	; what colour or pattern?
    empty-ground 	(solid pattern)		; should we draw when unlit?
    empty-colour	(x_colour x_pattern)	; what colour or pattern?
    border-colour	(x_colour) ; should we draw border (and what colour?)
   ))	; can use this as real plist for online documentation

(defun draw-field (f)		; draw field from scratch
  (apply (concat 'draw- (field-type f))	; construct draw function name
	 (ncons f)))				; then call it

(defun init-field (f)		; initialize a field
  (apply (concat 'init- (field-type f))	; construct init function name
	 (ncons f)))				; then call it

(defun resize-field (f box)		; resize a field
  (apply				; construct resize function name
    (concat 'resize- (field-type f))
    (list f box)))				; then call it

(defun toggle-field (f)		; toggle a field
  (apply (concat 'toggle- (field-type f)) ; construct toggle fcn name
	 (ncons f)))				; then call it

(defun check-field (f p)	; check if point is inside field excl.border
  (cond ((point-in-box-interior p (zone-box (field-zone f)))
	 (apply			; if so, construct check function name
	   (concat 'check- (field-type f))
	   (list f p)))		; then call it and return result
	(t nil)))		; otherwise return nil

(defun fill-field (f)		; fill the field interior, if defined
  (let ((b (get (field-properties f) 'fill-ground))	; check if has one
	(c (get (field-properties f) 'fill-colour)))
       (cond ((eq b 'solid)	; solid background
	      (cond (c (clear-zone-interior (field-zone f) c))
		    (t (clear-zone-interior (field-zone f) W-CONTRAST))))
	     ((eq b 'pattern)	; patterned background
	      (cond (c (pattern-zone-interior (field-zone f) c))
		    (t (pattern-zone-interior (field-zone f) W-PATTERN-1))))
       )))			; no background at all!

(defun empty-field (f)		; empty the field interior, if defined
  (let ((b (get (field-properties f) 'empty-ground)) ; check if has one
	(c (get (field-properties f) 'empty-colour)))
       (cond ((eq b 'solid)	; solid background
	      (cond (c (clear-zone-interior (field-zone f) c))
		    (t (clear-zone-interior (field-zone f) W-BACKGROUND))))
	     ((eq b 'pattern)	; patterned background
	      (cond (c (pattern-zone-interior (field-zone f) c))
		    (t (pattern-zone-interior (field-zone f) W-PATTERN-1))))
       )))			; no background at all!

(defun draw-field-background (f)	; just what it says
  (let ((b (get (field-properties f) 'empty-ground)) ; check if has one
	(c (get (field-properties f) 'empty-colour)))
       (cond ((eq b 'solid)	; solid background
	      (cond (c (clear-zone (field-zone f) c))
		    (t (clear-zone (field-zone f) W-BACKGROUND))))
	     ((eq b 'pattern)	; patterned background
	      (cond (c (pattern-zone (field-zone f) c))
		    (t (pattern-zone (field-zone f) W-PATTERN-1))))
       )))			; no background at all!

(defun draw-field-border (f)		; draw outline, if any
  (let ((c (get (field-properties f) 'border-colour)))
       (cond (c (draw-zone-outline (field-zone f) c)))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;						aggregate fields
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defstruct
  (aggregate-field	; aggregate field = form
    (:displace t)
    (:list)
    (:conc-name))
  (type 'aggregate-field)		; type
  (zone (make-zone))		; bounding zone
  (properties (list nil))	; empty property list
  subfields			; list of subfields
  selection			; which subfield was last hit
)
  
(defvar aggregate-field-properties
  `("aggregate-field-properties"
    = ,field-properties
   ))	; can use this as real plist for online documentation

(defun draw-aggregate-field (f)
  (draw-field-background f)			; clear background, if any
  (draw-field-border f)				; draw border, if any
  (mapc 'draw-field (aggregate-field-subfields f)) ; draw subfields
  (w-flush (window-w (zone-window (field-zone f)))) t) ; flush it out

(defun init-aggregate-field (f)
  (mapc 'init-field (aggregate-field-subfields f))
  (alter-aggregate-field f selection nil) t)

(defun resize-aggregate-field (f box)
  (alter-zone (field-zone f) box box))

(defun check-aggregate-field (f p)
  (do ((subfields (aggregate-field-subfields f)	; go through subfields
	 (cdr subfields))
       (gotcha))
      ((or (null subfields)				; stop when no more
	   (setq gotcha (check-field (car subfields) p))) ; or when one is hit
       (alter-aggregate-field f selection gotcha)	; remember which one
       gotcha)))					; also return it

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;						remote fields
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; A remote field is a field which activates another field when hit.
;;; Usually the remote field has some functional significance!

(defstruct
  (remote-field		; remote field
    (:displace t)
    (:list)
    (:conc-name))
  (type 'remote-field)		; type = remote
  (zone (make-zone))		; bounding zone
  (properties (list nil))	; empty plist
  (target)			; the actual target field
  (point)			; x,y coords to pretend to use
)

(defvar remote-field-properties
  `("remote-field-properties"
    = ,field-properties
   ))	; can use this as real plist for online documentation

(defun draw-remote-field (f) 't)	; nothing to draw

(defun init-remote-field (f) 't)	; nothing to initialize

(defun resize-remote-field (f box)
  (alter-zone (field-zone f) box box))

(defun check-remote-field (f p)
  (check-field
    (remote-field-target f)
    (remote-field-point f)))		; return result of checking target

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;						button fields
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defstruct
  (button-field		; button field
    (:displace t)
    (:list)
    (:conc-name))
  (type 'button-field)		; type = button
  (zone (make-zone))		; bounding zone
  (properties
    (list nil			; default properties
	  'fill-ground 'solid
	  'empty-ground 'solid
	  'border-colour W-CONTRAST
    ))
  (value nil)			; value
)

(defvar button-field-properties
  `("button-field-properties"
    = ,field-properties
   ))	; can use this as real plist for online documentation

(defun draw-button-field (f)
  (draw-field-border f)
  (cond ((button-field-value f)
	 (fill-field f))
	(t (empty-field f))))

(defun toggle-button-field (f)
  (alter-button-field f value (not (button-field-value f)))
  (clear-zone-interior (field-zone f) W-XOR))

(defun init-button-field (f)
  (alter-button-field f value nil))	; turn it off

(defun resize-button-field (f box)
  (alter-zone (field-zone f) box box))

(defun check-button-field (f p)
  (toggle-button-field f) f)	; if we get here it's a hit -> return self

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;						radio-button fields
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Named for the buttons on radios in which only one is "in" at a time.

(defstruct
  (radio-button-field		; radio-button field
    (:displace t)
    (:list)
    (:conc-name))
  (type 'radio-button-field)		; type = radio-button
  (zone (make-zone))		; bounding zone
  (properties (list nil))	; empty plist
  (subfields nil)		; individual buttons
  (selection nil)		; which one last hit
)

(defvar radio-button-field-properties
  `("radio-button-field-properties"
    = ,aggregate-field-properties
   ))	; can use this as real plist for online documentation

(defun draw-radio-button-field (f)
  (draw-aggregate-field f))

(defun init-radio-button-field (f)
  (init-aggregate-field f))

(defun resize-radio-button-field (f box)
  (alter-zone (field-zone f) box box))

(defun check-radio-button-field (f p)
  (cond ((and (radio-button-field-selection f)	; if button previously sel'd
	      (button-field-value
		(radio-button-field-selection f))) ; and it has a value
	 (toggle-field				; turn it off
	   (radio-button-field-selection f))))
  (check-aggregate-field f p)			; check individual buttons
)		; this will turn back on if same one sel'd, and return it

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;						text fields
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defstruct
  (text-field		; text field
    (:displace t)
    (:list)
    (:conc-name))
  (type 'text-field)		; type = text
  (zone (make-zone))		; bounding zone
  (properties
    (list nil
	  'fill-ground 'solid
	  'empty-ground 'solid
	  'border-colour W-CONTRAST
	  'x-offset 5		; offset from left
    ))
  (value nil)
  (text '||)			; text of text
)

(defvar text-field-properties
  `("text-field-properties"
    x-offset (x_pixels)		; text offset from box ll, otherwise centred
    y-offset (x_pixels)		; text offset from box ll, otherwise centred
    + ,button-field-properties
   ))	; can use this as real plist for online documentation

(defun draw-text-field (f)
  (draw-button-field f)
  (w-flush (window-w (zone-window (field-zone f)))) ; guarantee text on top
  (draw-text (text-field-text f)))

(defun redraw-text-field (f)
  (empty-field f)
  (w-flush (window-w (zone-window (field-zone f)))) ; guarantee text on top
  (draw-text (text-field-text f)))

(defun init-text-field (f)	; position & position the text in the field
  (let ((s (text-field-text f))
	(x-offset (get (field-properties f) 'x-offset))	; x offset from ll
	(y-offset (get (field-properties f) 'y-offset))); y offset from ll
       (alter-text s
	 zone (make-zone			; ensure it has a zone
		window (zone-window (field-zone f))
		box (box-interior (zone-box (field-zone f)))))
       (format-text s)		; ensure text delta calculated
       (cond ((null x-offset)		; x-offset specified?
	      (setq x-offset		; nope! centre it left-right
		    (/ (- (x (box-size (zone-box (field-zone f))))
			  (x (text-delta s)))
		       2))))
       (cond ((null y-offset)		; y-offset specified?
	      (setq y-offset		; nope! centre it up-down
		    (/ (- (y (box-size (zone-box (field-zone f))))
			  (font-x-height (look-font (text-look s))))
		       2))))
       (alter-text s			; now position the text
	 offset (make-point x x-offset y y-offset))
       ))

(defun resize-text-field (f box)	; position the text in the field
  (alter-zone (field-zone f) box box)
  (init-text-field f))

(defun check-text-field (f p)
  (input-text-field f) f)	; if we get here it's a hit -> return self

(defun input-text-field (f)
  (alter-text (text-field-text f)
    text '|| nn 0 kr 0 kl 0 delta (make-point x 0 y 0))
  (draw-text-field f)
  (edit-text-field f (ll (zone-box (text-zone (text-field-text f))))))

(defun edit-text-field (f p)		; edit in middle of text field
  (edit-text (text-field-text f) p)	; edit the text
  (draw-field f))			; redraw


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;						prompt fields
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defstruct
  (prompt-field		; prompt field
    (:displace t)
    (:list)
    (:conc-name))
  (type 'prompt-field)		; type = prompt
  (zone (make-zone))		; bounding zone
  (properties
    (list nil 'x-offset 0))	; put it exactly where spec indicates.
  (value nil)
  (text '||)			; text of prompt
)

(defvar prompt-field-properties
  `("prompt-field-properties"
    = ,text-field-properties
   ))	; can use this as real plist for online documentation

(defun draw-prompt-field (f)
  (draw-text-field f))

(defun init-prompt-field (f)
  (init-text-field f))

(defun resize-prompt-field (f box)	; position the text in the field
  (resize-text-field f box))

(defun check-prompt-field (f p) f) ; just return self

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;						text-button fields
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; A text-button is a button tied to a text.
;;; When the button is pressed, the text is input from the keyboard.
;;; Zone could same as either the button (activation by button only)
;;; or include both button & text (should then be adjacent)

(defstruct
  (text-button-field		; text-button field
    (:displace t)
    (:list)
    (:conc-name))
  (type 'text-button-field)		; type = text-button
  (zone (make-zone))		; bounding zone
  (properties (list nil))	; empty plist
  (button)			; button subfield
  (text)			; text subfield
)

(defvar text-button-field-properties
  `("text-button-field-properties"
    = ,field-properties
   ))	; can use this as real plist for online documentation

(defun draw-text-button-field (f)
  (draw-field (text-button-field-button f))
  (draw-text-field (text-button-field-text f)))

(defun init-text-button-field (f)
  (init-field (text-button-field-button f))
  (init-text-field (text-button-field-text f)))

(defun resize-text-button-field (f box)
  (alter-zone (field-zone f) box box))

(defun toggle-text-button-field (f)	; toggle only the button part
  (cond ((button-field-value		; and only if non-nil
	   (text-button-field-button f))
	 (toggle-button-field (text-button-field-button f)))))

(defun check-text-button-field (f p)
  (cond ((check-field (text-button-field-button f) p)
	 (input-text-field			; input from scratch
	   (text-button-field-text f)))	; get the data
	(t (toggle-button-field			; must be pointing at text
	     (text-button-field-button f))	; toggle only the button part
	   (edit-text-field
	     (text-button-field-text f) p))	; edit the data
  )
  (toggle-button-field			; toggle button back
    (text-button-field-button f))
  (alter-button-field (text-button-field-button f)
    value nil)			; keep aggregate from toggling again
  f)					; return self

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;						labelled button fields
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defstruct
  (labelled-button-field ; labelled button field
    (:displace t)
    (:list)
    (:conc-name))
  (type 'labelled-button-field)	; type = labelled-button
  (zone (make-zone))		; bounding zone
  (properties
    (list nil
	  'fill-ground 'solid
	  'empty-ground 'solid
	  'border-colour W-CONTRAST
    ))
  (value nil)			; value
  (text '||)			; label text
)

(defvar labelled-button-field-properties
  `("labelled-button-field-properties"
    = ,text-field-properties
   ))	; can use this as real plist for online documentation

(defun draw-labelled-button-field (f)
  (draw-text-field f))

(defun init-labelled-button-field (f)
  (init-text-field f))

(defun resize-labelled-button-field (f box)
  (resize-text-field f box))

(defun check-labelled-button-field (f p)
  (toggle-button-field f) f)	; if we get here it's a hit -> return self

(defun toggle-labelled-button-field (f)
  (toggle-button-field f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;						expanded-bitmap fields
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defstruct
  (expanded-bitmap-field	; expanded-bitmap field
    (:displace t)
    (:list)
    (:conc-name))
  (type 'expanded-bitmap-field)	; type = expanded-bitmap
  (zone (make-zone))		; bounding zone
  (properties (list nil))	; empty plist
  (subfields nil)		; individual bits
  (selection nil)		; which one last hit
  (nrows 1)
  (ncols 1)
)

(defvar expanded-bitmap-field-properties
  `("expanded-bitmap-field-properties"
    = ,aggregate-field-properties
   ))	; can use this as real plist for online documentation

(defun draw-expanded-bitmap-field (f)
  (draw-aggregate-field f))

(defun init-expanded-bitmap-field (f)
  (let ((s (divide-points			; calculate x,y dimensions
	     (box-size (zone-box (field-zone f)))
	     (make-point
	       x (expanded-bitmap-field-ncols f)
	       y (expanded-bitmap-field-nrows f)))))
       (do ((z (field-zone f))
	    (r nil)
	    (x (x (ll (zone-box (field-zone f)))))
	    (y (y (ll (zone-box (field-zone f))))
	       (+ y dy))
	    (dx (x s))
	    (dy (y s))
	    (nc (expanded-bitmap-field-nrows f))
	    (nr (expanded-bitmap-field-nrows f))
	    (j 0 (1+ j)))
	   ((= j nr) (alter-aggregate-field f subfields (nreverse r)) 't)
	   (do ((x x (+ x dx))
		(p)
		(i 0 (1+ i)))
	       ((= i nc))			; create a row of buttons
	       (setq p (make-point x x y y))
	       (setq r (xcons r (make-button-field zone (append z nil))))
	       (alter-zone (field-zone (car r))
		 box (make-box ll p ur (add-points p s)))
	   ))))

(defun resize-expanded-bitmap-field (f box)
  (alter-zone (field-zone f) box box)
  (let ((s (divide-points			; calculate x,y dimensions
	     (box-size box)
	     (make-point
	       x (expanded-bitmap-field-ncols f)
	       y (expanded-bitmap-field-nrows f)))))
       (do ((z (field-zone f))
	    (r (expanded-bitmap-field-subfields f))
	    (x (x (ll box)))
	    (y (y (ll box)) (+ y dy))
	    (dx (x s))
	    (dy (y s))
	    (nc (expanded-bitmap-field-nrows f))
	    (nr (expanded-bitmap-field-nrows f))
	    (j 0 (1+ j)))
	   ((= j nr) t)
	   (do ((x x (+ x dx))
		(p)
		(i 0 (1+ i)))
	       ((= i nc))			; create a row of buttons
	       (setq p (make-point x x y y))
	       (resize-button-field (car r)
		 (make-box ll p ur (add-points p s)))
	       (setq r (cdr r))
	   ))))

(defun check-expanded-bitmap-field (f p)
  (check-aggregate-field f p))	; if we get here it's a hit -> check subfields

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; utilities.l								;
;;;									;
;;; These macros and functions are thought to be generally useful.	;
;;;									;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;							Macros		;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare
  (macros t)		; keep macros around after compiling
  (localf pairify* pairifyq* split2* sublist*)
  (special compiled-with-help))

(defmacro copy-all-but-last (ls)	; copy all but last member of list
  `(let ((ls ,ls))
	(firstn (1- (length ls))
	  ls)))

(defmacro all-but-last (ls)		; destructive all-but-last
  `(let ((ls ,ls))
	(cond ((cdr ls)
	       (rplacd (nthcdr (- (length ls) 2) ls) nil)
	       ls))))

(def hex (macro (arglist)		; hex to integer conversion
		`(car (hex-to-int ',(cdr arglist)))))

;;; define properties on symbols for use by help routines

(defmacro def-usage (fun usage returns group)
  (cond (compiled-with-help	; flag controls help generation
	  `(progn (putprop ,fun ,usage 'fcn-usage)
		  (putprop ,fun ,returns 'fcn-returns)
		  (putprop ,fun (nconc ,group (ncons ,fun)) 'fcn-group)))))
(defvar compiled-with-help t)	; unless otherwise notified

;;; (letenv 'l_bind_plist g_expr1 ... g_exprn) -- pair-list form of "let"
;;; Lambda-binds pairs of "binding-objects" (see description of let,let*),
;;; at RUN TIME, then evaluates g_expr1 to g_exprn, returning g_exprn. eg:
;;; (apply 'letenv '(letenv '(a 1 b (+ c d))
;;;		      (e)(f g)))
;-> (eval (cons 'let (cons (pairify '(a 1 b (+ c d)))
;;;			   '((e) (f g)))))
;-> (let ((a 1) (b (+ c d)))
;;;	 (e) (f g))
(def letenv
  (macro (x)
    `(eval (cons 'let
	     (cons
	       (pairify ,(cadr x))	; plist of binding objects
	       ',(cddr x))))))		; exprs to be eval'ed

(def letenvq			; letenv, quoted binding objects
  (macro (x)
    `(eval (cons 'let
	     (cons
	       (pairifyq ,(cadr x))	; plist of binding objects
	       ',(cddr x))))))		; exprs to be eval'ed

(defmacro mergecar (L1 L2 cmpfn)	; merge, comparing by car's
  `(merge ,L1 ,L2 '(lambda (e1 e2)		; (like sortcar)
		     (funcall ,cmpfn (car e1) (car e2)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;							Functions	;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; (all-but-last l_items)	-- copy all but last list element

;(defun all-but-last (ls)
;  (cond ((cdr ls) (cons (car ls) (all-but-last (cdr ls))))))

;;; (alphap sx_char)
(defun alphap (char)			; is char alphabetic?
  (cond ((symbolp char)
	 (setq char (car (exploden char)))))
  (and (fixp char)
       (or (and (>& char #.(1- #/A))
		(<& char #.(1+ #/Z)))
	   (and (>& char #.(1- #/a))
		(<& char #.(1+ #/z))))))

;;; (alphanumericp sx_char)
(defun alphanumericp (char)		; is char alphabetic or numeric?
  (cond ((symbolp char)
	 (setq char (car (exploden char)))))
  (and (fixp char)
       (or (and (>& char #.(1- #/A))
		(<& char #.(1+ #/Z)))
	   (and (>& char #.(1- #/a))
		(<& char #.(1+ #/z)))
	   (and (>& char #.(1- #/0))
		(<& char #.(1+ #/9))))))

;;; (assqonc 'g_key 'g_val 'l_al)
;;; like   (cond ((assq key alist))
;;;		 (t (cadr (rplacd (last alist)
;;;			    (ncons (cons key val))))))
(defun assqonc (key val al)	; tack (key.val) on end if not found
  (do ((al al (cdr al)))
      ((or (eq key (caar al))
	   (and (null (cdr al))
		(rplacd al (setq al (ncons (cons key val))))))
       (car al))))

;;; (cartesian l_xset l_yset)
(defun cartesian (xset yset)		; cartesian product of elements
  (mapcan
    '(lambda (x)
       (mapcar
	 '(lambda (y) (cons x y))
	 yset))
    xset))

(defun concat-pairs (sb-list)	; concat neighbouring symbol pairs
  (do ((s1 (car sb-list) s2)
       (s2 (cadr sb-list) (car sbs-left))
       (sbs-left (cddr sb-list) (cdr sbs-left))
       (result nil (cons (concat s1 s2) result)))
      ((null s2) (nreverse result))))
;;; (detach l)
;;; Detaches (and throws away) first element of list (converse of attach)
;;; keeping the same initial list cell.
(defun detach (l)
  (cond (l (rplacd l (cddr (rplaca l (cadr l)))))))

;;; (distribute x_Q x_N)
;;; returns list of the form: (1 1 1 0 0 0 0 1 1) or (3 2 2 2 3)
;;; i.e. a list of length <N> containing quantity <Q> evenly distributed
;;; with the excess <Q mod N> surrounding a "core" of <Q div N>'s
;;; Useful (?) for padding spaces in line adjustment.
;(defun distribute (Q N)	; this one only does 1's and 0's
;  (cond ((signp le Q) (duplicate N 0))
;	((eq Q 1) (pad 0 N '(1)))
;	(t (cons 1 (nconc
;		     (distribute (- Q 2) (- N 2))
;		     '(1))))))

(defun distribute (Q N)		; distribute quantity Q among N elements
  (let ((tmp (Divide (abs Q) N)))
       (setq tmp (distribute0 (cadr tmp) N (car tmp) (1+ (car tmp))))
       (cond ((signp ge Q) tmp)
	     (t (mapcar 'minus tmp)))))

(defun distribute0 (Q N X X1)
  (cond ((signp le Q) (duplicate N X))
	((eq Q 1) (pad X N (ncons X1)))
	(t (cons X1 (nconc
			  (distribute0 (- Q 2) (- N 2) X X1)
			  (ncons X1))))))

;;; (duplicate x_n g_object)
;;; Returns list of n copies of object (nil if n <= 0)
(defun duplicate (n object)
  (do ((res nil (cons object res))
       (i n (1- i)))
      ((signp le i) res)))

(defun e0 (in out)		; simulate binary insertion procedure
  (let ((lin (length in))
	(lout (length out)))
       (cond ((> lin lout)
	      (e0
		(nthcdr lout in)
		(mapcan 'list out (firstn lout in))))
	     (t (nconc (mapcan 'list (firstn lin out) in)
		       (nthcdr lin out))))))

(defun e (files)		; determine file permutation for emacs insert
  (let ((i (e0 (cdr (iota (length files))) '(0)))
	(f (append files nil)))
       (mapc '(lambda (f-index f-name)
		(rplaca (nthcdr f-index f) f-name))
	     i files)
       f))

;;; (firstn x_n l_listarg)
(defun firstn (n l)		;  copy first <n> elements of list
  (do ((n n (1- n))
       (l l (cdr l))
       (r nil))
      ((not (plusp n)) (nreverse r))		; <nil> if n=0 or -ve
      (setq r (cons (car l) r))))

;;; (iota x_n)
;;; APL index generator (0,1,2,...,<n>-1)
(defun iota (n)
  (do ((i (1- n) (1- i))
       (res nil))
      ((minusp i) res)
      (setq res (cons i res))))

(defun hex-to-int (numlist)		; eg. (hex-to-int '(12b3 120 8b))
  (cond
    (numlist			; terminate recursion on null numlist
      (cons
	(apply '+
	       (maplist
		 '(lambda (digits)
		    (lsh
		      (get '(hex |0| 0 |1| 1 |2| 2 |3| 3
				 |4| 4 |5| 5 |6| 6 |7| 7
				 |8| 8 |9| 9  a 10  b 11
				  c 12  d 13  e 14  f 15)
			   (car digits))
		      (lsh (1- (length digits)) 2)))
		 (explodec (car numlist))))
	(hex-to-int (cdr numlist))))))  

;;; (lctouc g_expr)
;;; Returns s-expression formed by translating lower-case alphabetic
;;; characters in <expr> to their upper-case equivalents.
;;; Operates by imploding the translated characters, in the case of a
;;; symbol or string, or by recursively calling on members of a list.
;;; Other object types are returned unchanged.
(defun lctouc (expr)
    (cond
	((dtpr expr) (mapcar 'uctolc expr))
	((or (symbolp expr) (stringp expr))
	 (implode
	     (mapcar
		 '(lambda (ch)
		      (cond ((alphap ch)		; and-out lower-case bit
			     (boole 1 #.(1- (1- #/a)) ch)) (t ch)))
		 (exploden expr))))
	(t expr)))

;;; (log2 x_n)
(defun log2 (n)			; log base 2 (truncated)
  (do ((n (lsh n -1) (lsh n -1))
       (p 0 (1+ p)))
      ((zerop n) p)))

;;; (lowerp sx_char)
(defun lowerp (char)		; is char lower-case alphabetic?
  (cond ((symbolp char)
	 (setq char (car (exploden char)))))
  (and (fixp char)
       (or (and (> char #.(1- #/a))
		(< char #.(1+ #/z))))))

;;; (numericp sx_char)
;;; returns t if char is numeric, otherwise nil
(defun numericp (char)
  (cond ((symbolp char)(setq char (car (exploden char)))))
  (and (fixp char)
       (and (> char #.(1- #/0))
	    (< char #.(1+ #/9)))))

;;; (pad g_item x_n l_list)
;;; Returns <list> padded with copies of <item> to length <n>
(defun pad (item n list)
  (append list (duplicate (- n (length list)) item)))

;;; (pairify l_items)	; make a-list from alternating elements
(defun pairify (pl)
  (pairify* nil pl))
(defun pairify* (rs pl)		; tail-recursive local fun
  (cond (pl (pairify* (cons (list (car pl) (cadr pl)) rs)
		       (cddr pl)))
	(t (nreverse rs))))

;;; (pairifyq l_items)	; make a-list from alternating elements
(defun pairifyq (pl)	; with each second element quoted
  (pairifyq* nil pl))
(defun pairifyq* (rs pl)		; tail-recursive local fun
  (cond (pl (pairifyq* (cons (list (car pl) (kwote (cadr pl))) rs)
		       (cddr pl)))
	(t (nreverse rs))))

;;; (penultimate l_items)	; cdr down to next-to-last list element
(defun penultimate (ls)	
  (cond ((cddr ls) (penultimate (cdr ls)))
	(t ls)))

;;; (split2 l_L)
;;; Splits list <L> into two (new) second-level lists
(defun split2* (L tc1 tc2)
  (cond ((null L) (list (nreverse tc1) (nreverse tc2)))
	(t (split2* (cddr L)
	     (cons (car L) tc1)
	     (cons (cadr L) tc2)))))

(defun split2 (L)
  (split2* L nil nil))

;;; (sublist L IL)
;;; Splits list <L> (destructively) into (length IL) sub-lists.
;;; IL is a list of starting indices, base zero, should be unique positive
;;; fixnums in ascending order, and shouldn't exceed the length of L.
;;; Each resulting sublist <i> begins with (nthcdr (nth <i> IL) L)
(defun sublist (L IL)
  (sublist* 0 nil (cons nil L) IL))
(defun sublist* (I R L IL)		; tail-recursion function
  (cond ((and L IL)
	 (cond
	   ((<& I (car IL))
	    (sublist* (1+ I) R (cdr L) IL))
	   (t (sublist* (1+ I)
			(cons (cdr L) R)
			(prog1 (cdr L) (rplacd L nil))
			(cdr IL)))))
	(t (nreverse R))))

(defun try-fun (fun l-arg)	; try function on each arg until non-nil
  (cond ((funcall fun (car l-arg)))
	(l-arg (try-fun fun (cdr l-arg)))))

;;; (uctolc g_expr)
;;; Returns s-expression formed by translating upper-case alphabetic
;;; characters in <expr> to their lower-case equivalents.
;;; Operates by imploding the translated characters, in the case of a
;;; symbol or string, or by recursively calling on members of a list.
;;; Other object types are returned unchanged.
(defun uctolc (expr)
    (cond
	((dtpr expr) (mapcar 'uctolc expr))
	((or (symbolp expr) (stringp expr))
	 (implode
	     (mapcar
		 '(lambda (ch)
		      (cond ((alphap ch)		; or-in lower-case bit
			     (boole 7 #.(1- #/a) ch)) (t ch)))
		 (exploden expr))))
	(t expr)))

;;; (unique a l) -- Scan <l> for an element <e> "equal" to <a>.
;;; If found, return <e>. Otherwise nconc <a> onto <l>; return <a>.
(defun unique (a l)			; ensure unique in list
  (car
    (do ((cdr_ul l (cdr ul))
	 (ul l cdr_ul))
	((null cdr_ul) (rplacd ul (ncons a)))
	(cond ((equal a (car cdr_ul)) (return cdr_ul))))))

;;; (upperp sx_char)
(defun upperp (char)		; is char upper-case alphabetic?
  (cond ((symbolp char)
	 (setq char (car (exploden char)))))
  (and (fixp char)
       (or (and (> char #.(1- #/A))
		(< char #.(1+ #/Z))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; zone.l -- data structures and routines for concrete window zones
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; a "point" is a pair of integer x,y coordinates
;;; a "box" is a pair of points defining lower left and upper right corners
;;; a "position" is a point coupled with a window
;;; a "zone" is a box coupled with a window
;;; a "window" is a machine, integer window id and, for compatibility
;;;	with the toolbox, an integer toolbox window pointer
;;; a "machine" is a name coupled with the j-process-id's of resident servers
;;; The basic idea is to define a notion of a concrete position for a
;;; display object, that can be incorporated into the object data structure.
;;; Higher levels of software can use the objects without explicit reference
;;; to server processes, windows and machines.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare
  (specials t)			; global vars not local to this file
  (macros t))			; compile macros as well

(eval-when (compile)		; trust  to higher level for eval & load
  (load 'utilities)		; utility functions
  (load 'constants)		; common constants for window toolbox
;  (load 'shape)		; arbitrarily shaped screen areas
)

(defstruct
  (position		; a concrete display position
    (:displace t)
    (:list)
    (:conc-name))
  (window (make-window))	; concrete window
  (point (make-point))		; actual x, y coordinates
)

(defstruct
  (zone			; a concrete display zone
    (:displace t)
    (:list)
    (:conc-name))
  (window (make-window))	; concrete window
  (box (make-box))		; bounding box of zone
  (colour W-BACKGROUND)		; colour (for scrolling etc)
  shape
)

(defstruct
  (window		; concrete window
    (:displace t)
    (:list)
    (:conc-name))
  (id 0)			; integer window id
  (machine (make-machine))	; machine (workstation)
  (w 0)				; toolbox window structure pointer
)

(defstruct
  (machine		; machine (workstation)
    (:displace t)
    (:list)
    (:conc-name))
  (name	'unknown-machine)	; machine name
  (servers nil)			; plist of server processes living there
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; manipulation routines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun add-points (p q)		; vector sum (x1+x2) (y1+y2)
  (make-point
    x (+ (x p) (x q))
    y (+ (y p) (y q))))

(defun subtract-points (p q)	; vector subtract (x1-x2) (y1-y2)
  (make-point
    x (- (x p) (x q))
    y (- (y p) (y q))))

(defun multiply-points (p q)	; vector multiply (x1*x2) (y1*y2)
  (make-point
    x (* (x p) (x q))
    y (* (y p) (y q))))

(defun divide-points (p q)	; vector division (x1-x2) (y1-y2)
  (make-point
    x (/ (x p) (x q))
    y (/ (y p) (y q))))

(defun move-point (p q)		; move point p to point q
  (alter-point p
    x (x q)
    y (y q))
  t)					; return true

(defun box-size (b)		; size of box = ur - ll
  (subtract-points (ur b) (ll b)))

(defun box-interior (b)		; return box just inside this box dimensions
  (make-box
    ll (add-points (ll b) '(1 1))
    ur (subtract-points (ur b) '(1 1))))

(defun move-box (b p)		; move box b to point p (lower-left)
  (let ((size (box-size b)))
       (alter-box b
	 ll p
	 ur (add-points p size))
       t))				; return true

(defun point-in-box (p b)	; is point p in box b? (including boundary)
  (and (>= (x p) (x (ll b)))
       (<= (x p) (x (ur b)))
       (>= (y p) (y (ll b)))
       (<= (y p) (y (ur b)))
  ))

(defun point-in-box-interior (p b) ; is point p in box b? (excluding boundary)
  (and (> (x p) (x (ll b)))
       (< (x p) (x (ur b)))
       (> (y p) (y (ll b)))
       (< (y p) (y (ur b)))
  ))

(defun init-window (w)		; fill in  "window" structure
  (let				; presuming window-w predefined
    ((m (j-machine-name (w-get-manager (window-w w)))))
    (alter-window w id (w-get-id (window-w w)))
    (cond ((not (window-machine w))
	   (alter-window w machine (make-machine name m)))
	  (t (alter-machine (window-machine w) name m)))
    (init-machine (window-machine w))	; also fill in machine structure
    t))				; return true

(defun init-machine (m)		; fill in "machine" structure
  (cond				; presuming machine-name predefined
    ((null (machine-servers m))		; if no plist, make new one
     (alter-machine m servers (ncons 'servers:))))
  (mapc '(lambda (pname)		; for each expected server name
	   (let
	     ((pid (j-search-machine-e jipc-error-code
		     (machine-name m)
		     pname)))		; try to find one on that machine
	     (cond ((j-same-process pid J-NO-PROCESS)
		    (putprop (machine-servers m) nil pname)) ; failed! use nil
		   (t (putprop (machine-servers m) pid pname))))) ; success!
	EXPECTED-WORKSTATION-SERVERS)	; global list of process names
  t)					; return true

(defvar EXPECTED-WORKSTATION-SERVERS	; global list of process names
  '(window_manager creator savemem
     text-composer))			; usually want at least these

(defun window-box (w)		; box fills entire window
  (let ((w-size (w-get-window-size (window-w w))))
       (make-box
	 ll (make-point x 0 y 0)
	 ur (make-point x (car w-size) y (cadr w-size)))
  ))

(defun clear-zone (z colour)	; clear zone (including boundaries)
  (let ((b (box-size (zone-box z))))
       (w-clear-rectangle (window-w (zone-window z))
	 (x (ll (zone-box z))) (y (ll (zone-box z)))
	 (1+ (x b)) (1+ (y b))
	 colour)))

(defun clear-zone-interior (z colour)	; clear zone (excluding boundaries)
  (let ((b (box-size (zone-box z))))
       (w-clear-rectangle (window-w (zone-window z))
	 (1+ (x (ll (zone-box z)))) (1+ (y (ll (zone-box z))))
	 (1- (x b)) (1- (y b))
	 colour)))

(defun pattern-zone (z pattern)	; pattern zone (including boundaries)
  (let ((b (zone-box z)))
       (w-pattern-rectangle (window-w (zone-window z))
	 (x (ll b)) (y (ll b))
	 (1+ (x (ur b))) (1+ (y (ur b))) pattern)
  ))

(defun pattern-zone-interior (z pattern) ; pattern zone (excluding boundaries)
  (let ((b (box-size (zone-box z))))
       (w-pattern-rectangle (window-w (zone-window z))
	 (1+ (x (ll (zone-box z)))) (1+ (y (ll (zone-box z))))
	 (1- (x b)) (1- (y b)) pattern)
  ))

(defun draw-zone-outline (z colour)	; draw zone boundaries
  (let* ((w (window-w (zone-window z)))
	 (b (zone-box z))
	 (ll (ll b))
	 (ur (ur b)))
	(w-draw-vector w (x ll) (y ll) (x ll) (y ur) colour)
	(w-draw-vector w (x ll) (y ur) (x ur) (y ur) colour)
	(w-draw-vector w (x ur) (y ur) (x ur) (y ll) colour)
	(w-draw-vector w (x ur) (y ll) (x ll) (y ll) colour)
  ))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; font.l -- font manipulation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(eval-when (compile)
  (load 'utilities)
  (load 'constants))

(defvar -installed-fonts nil)	; list of installed fonts

(defstruct
  (font			; font structure
    (:displace t)
    (:list)
    (:conc-name))
  (name 'standard)
  (size 8)
  (body 8)
  (cap-height 7)
  (x-height 5)
  (fixed-width 5)
  (first 0)
  (last 127)
  glyph			; the actual characters
)

(defstruct
  (glyph			; glyph structure
    (:displace t)
    (:list)
    (:conc-name))
  code
  width
  (bytes (byte-block 32))	; the actual bitmap
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 				font manipulation routines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun read-font (family size path)
  (let ((p (infile path))		; open file
	(x (new-vectori-long 2))
	(f nil))
       (setq f (make-font
		 name family
		 size (tyi p)
		 body (tyi p)
		 cap-height (tyi p)
		 x-height (tyi p)
		 fixed-width (tyi p)
		 first (prog1 (tyi p) (tyi p))
		 last (prog1 (tyi p) (tyi p))))
       (alter-font f glyph
	 (do ((i (font-first f) (1+ i))
	      (r (ncons nil))
	      (g))	   
	     ((> i (font-last f)) (car r))
	     (setq g (make-glyph code i))	; allocate char
	     (do ((j 0 (1+ j)))			; read bitmap
		 ((> j 31))
		 (vseti-byte (glyph-bytes g) j (tyi p)))
	     (alter-glyph g width (tyi p))	; read width
	     (setq r (tconc r g))
	 ))
       (close p)			; close file

       (rplacd				; install font
	 (cond ((assoc (list (font-name f) (font-size f)) -installed-fonts))
	       (t (car (setq -installed-fonts
			     (cons (ncons (list (font-name f) (font-size f)))
				   -installed-fonts)))))
	 f)
       f))				; return font

(def-usage 'read-font '(|'st_family| |'x_size| |'st_path|)
  'l_font-descriptor
  (setq fcn-group (ncons "Font Manipulation:")))

(defun install-font (f)
  (cdr
    (rplacd				; install font
      (cond ((assoc (list (font-name f) (font-size f)) -installed-fonts))
	    (t (car (setq -installed-fonts
			  (cons (ncons (list (font-name f) (font-size f)))
				-installed-fonts)))))
      f)))

(defun find-font (family size)	; always "finds" one even if dummy
  (cond ((cdr (assoc (list family size) -installed-fonts)))
	(t (install-font (make-font name family size size)))))

(def-usage 'find-font
  '(|'st_family| |'x_size|)
  'l_font-descriptor
  fcn-group)

(defun create-font (driver font)
  (j-send-se-list driver
    (list 'make-font
	  (font-name font)
	  (font-size font)
	  (font-body font)
	  (font-cap-height font)
	  (font-x-height font)
	  (font-fixed-width font)
	  (font-first font)
	  (font-last font))))

(defun download-glyph (driver font glyph)
  (j-put-items
    `((J-STRING set-glyph)
       (J-STRING ,(font-name font))
       (J-INT ,(font-size font))
       (J-INT ,(glyph-code glyph))
       (J-INT ,(glyph-width glyph))
       (J-BLOCK ,(glyph-bytes glyph))))
  (j-send driver))

(defun download-font (driver font)
  (do ((g (font-glyph font))
       (font-size (font-size font)))
      ((null g))
      (j-put-items
	`((J-STRING set-glyph)
	  (J-STRING ,(font-name font))
	  (J-INT ,font-size)))
      (do ((gg g (cdr gg)))
	  ((or (null gg) (j-put-items
			   `((J-INT ,(glyph-code (car gg)))
			     (J-INT ,(glyph-width (car gg)))
			     (J-BLOCK
			       ,(glyph-bytes (car gg))
			       ,(+ font-size font-size)))))
	   (setq g gg)))		; when buffer full, save remainder
      (j-send driver)
      (cond ((eq J-STRING (j-next-item-type))
	     (j-gets j-comm-string 128)		; skip past message string
	     (cond ((eq J-INT (j-next-item-type))(patom (j-geti))(terpr)))))
  ))

(def-usage 'download-font
  '(|'x_process-id| |'l_font-descriptor|)
  't
  fcn-group)

(defun read-create-download-font (driver family size path)
  (let ((f (read-font family size path)))
       (create-font driver f)
       (download-font driver f)
       f))

(def-usage 'read-create-download-font
  '(|'x_process-id| |'st_family| |'x_size| |'st_path|)
  'l_font-descriptor
  fcn-group)

(defun font-depth (f)
  (- (font-body f) (font-cap-height f)))

(defun font-height (f)
  (font-cap-height f))

(defun get-font-list (sc) ; arg is string-composer or font-server pid
  (j-send-se sc 'get-font-list)
  (pairify (mapcar
	     '(lambda (x)
		(cond ((stringp (cadr x)) (concat (cadr x)))
		      (t (cadr x))))
	     (j-get-items))))

(defun get-all-font-info (sc) ; arg is string-composer or font-server pid
  (mapc '(lambda (f)
	   (rplacd (apply 'find-font f)
	     (cdr (progn
		    (j-send-se-list sc (cons 'get-font-info f))
		    (mapcar 'cadr (j-get-items))))))
	(get-font-list sc)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; text.l -- fancy text strings
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare
  (specials t)
  (macros t))

(eval-when (compile)
  (load 'utilities)
  (load 'constants)
  (load 'zone)
  (load 'font)
  (load 'look))

(defstruct
  (text		; text structure
    (:displace t)
    (:list)
    (:conc-name))
  (text '||)			; the text to draw
  (look (make-look))		; what style to draw it in
  (kl 0)			; (starting) left kerning mask
  (zone (make-zone))		; specific window, clipping box
  (offset (make-point))		; offset of start point from zone ll
  (kr 0)			; (final) right kerning mask
  (delta (make-point))		; change in (x,y) relative to start point
  (nn -1)			; char count
)

;;; NOTE: clipping box of ((0 0) (-1 -1)) uses window boundaries

(defun text-width (s)		; presumes non-rotated
  (x (text-delta s)))

(defun text-box (s)		; presumes non-rotated
  (make-box
    ll (subtract-points
	 (text-start-point s)
	 (make-point x 0 y (font-depth (look-font (text-look s)))))
    ur (add-points
	 (text-end-point s)
	 (make-point x 0 y (font-height (look-font (text-look s)))))))

(defun text-start-point (s)
  (add-points
    (ll (zone-box (text-zone s)))
    (text-offset s)))

(defun text-end-point (s)
  (add-points
    (text-start-point s)
    (text-delta s)))

(defun text-x (s)	; x coord of start of text object
  (+ (x (ll (zone-box (text-zone s))))
     (x (text-offset s))))

(defun text-y (s)	; y coord of start of text object
  (+ (y (ll (zone-box (text-zone s))))
     (y (text-offset s))))

(defun text-xx (s)	; x coord of end of text object
  (+ (x (ll (zone-box (text-zone s))))
     (x (text-offset s))
     (x (text-delta s))))

(defun text-yy (s)	; y coord of end of text object
  (+ (y (ll (zone-box (text-zone s))))
     (y (text-offset s))
     (y (text-delta s))))

(defun move-text (s p)	; move s to new x,y
  (alter-text s
    offset (subtract-points p (ll (zone-box (text-zone s))))))

(defun draw-text (s)		; quietly draw text, clipping to zone box
  (let (((x y) (text-start-point s))
	(l (text-look s)))
       (j-put-items
	 `((J-STRING compose)
	   (J-INT ,(window-id (zone-window (text-zone s))))
	   (J-STRING ,(text-text s))
	   (J-STRING ,(font-name (look-font l)))
	   (J-INT ,(font-size (look-font l)))
	   (J-INT ,(boole 7 (look-mode l) QUIET))
	   (J-INT ,(look-colour l))
	   (J-INT ,(look-gap l))
	   (J-INT ,(look-ul l))
	   (J-INT ,(text-kl s))
	   (J-INT ,x)
	   (J-INT ,y)
	   (J-INT ,(x (cond
			((zerop (boole 1 ROTATE-180 (look-mode l)))
			 (ur (zone-box (text-zone s))))
			(t (ll (zone-box (text-zone s)))))))
	   (J-INT ,(y (cond
			((zerop (boole 1 ROTATE-90 (look-mode l)))
			 (ur (zone-box (text-zone s))))
			(t (ll (zone-box (text-zone s)))))))
	   (J-INT ,(text-nn s))
	  ))
       (j-send (get (machine-servers
		      (window-machine
			(zone-window
			  (text-zone s))))
		    'text-composer))
  ))

(defun undraw-text (s)	; quietly undraw text, clipping to zone box
  (let (((x y) (text-start-point s))
	(l (text-look s)))
       (j-put-items
	 `((J-STRING compose)
	   (J-INT ,(window-id (zone-window (text-zone s))))
	   (J-STRING ,(text-text s))
	   (J-STRING ,(font-name (look-font l)))
	   (J-INT ,(font-size (look-font l)))
	   (J-INT ,(boole 7 OVERSTRIKE QUIET (look-mode l)))
	   (J-INT ,(inverse-colour (look-colour l)))
	   (J-INT ,(look-gap l))
	   (J-INT ,(look-ul l))
	   (J-INT ,(text-kl s))
	   (J-INT ,x)
	   (J-INT ,y)
	   (J-INT ,(x (cond
			((zerop (boole 1 ROTATE-180 (look-mode l)))
			 (ur (zone-box (text-zone s))))
			(t (ll (zone-box (text-zone s)))))))
	   (J-INT ,(y (cond
			((zerop (boole 1 ROTATE-90 (look-mode l)))
			 (ur (zone-box (text-zone s))))
			(t (ll (zone-box (text-zone s)))))))
	   (J-INT ,(text-nn s))
	  ))
       (j-send (get (machine-servers
		      (window-machine
			(zone-window
			  (text-zone s))))
		    'text-composer))
  ))

(defun format-text (s)	; format text without drawing or clipping
  (let ((memop (symbolp (text-text s)))	; can only memoize symbols
	(k) (p) (q) (l (text-look s)))
       (cond
	 (memop					; are we memoizing? yes!
	   (setq k (unique-look-id l))	; key based on look
	   (setq p (get (text-text s) k))		; alist found on plist
	   (setq q (assoc (text-kl s) p))))		; entry based on kl
       (cond
	 (q (alter-text s			; if info found
	      kr (cadr q)			; record result
	      delta (caddr q)			; then return
	      nn (cadddr q)))
	 (t					; otherwise compute data
	   (j-put-items
	     `((J-STRING compose)
	       (J-INT 0)			; no window needed
	       (J-STRING ,(text-text s))
	       (J-STRING ,(font-name (look-font l)))
	       (J-INT ,(font-size (look-font l)))
	       (J-INT ,(boole 7 NO-DRAW (look-mode l)))
	       (J-INT ,(look-colour l))
	       (J-INT ,(look-gap l))
	       (J-INT ,(look-ul l))
	       (J-INT ,(text-kl s))
	       (J-INT 0)			; starting point 0 0
	       (J-INT 0)
	       (J-INT -1)			; no clipping
	       (J-INT -1)
	       (J-INT -1)
	      ))
	   (j-send (get (machine-servers
			  (window-machine
			    (zone-window
			      (text-zone s))))
			'text-composer))
	   (let ((kr (j-geti))			; now record result
		 (xx (j-geti))
		 (yy (j-geti))
		 (nn (j-geti)))
		(alter-text s
		  kr kr
		  delta (make-point x xx y yy)
		  nn nn)
		(cond (memop				; memoize if req'd
			(cond (p (nconc p
				   (ncons (list (text-kl s) kr
						(text-delta s) nn))))
			      (t (putprop (text-text s)
				   (ncons (list (text-kl s) kr
						(text-delta s) nn))
				   k))))
		))
	 ))
       't))					; always return t

(defun scan-text (s p) ; scan text s for point p, return (kr delta nn)
  (let (((x y) (text-start-point s))		; inside: check text
	(l (text-look s)))
       (j-put-items
	 `((J-STRING compose)
	   (J-INT 0)
	   (J-STRING ,(text-text s))
	   (J-STRING ,(font-name (look-font l)))
	   (J-INT ,(font-size (look-font l)))
	   (J-INT ,(boole 7 NO-DRAW (look-mode l)))
	   (J-INT ,(look-colour l))
	   (J-INT ,(look-gap l))
	   (J-INT ,(look-ul l))
	   (J-INT ,(text-kl s))
	   (J-INT ,x)
	   (J-INT ,y)
	   (J-INT ,(x p))
	   (J-INT ,(y p))
	   (J-INT ,(text-nn s))
	  ))
       (j-send (get (machine-servers
		      (window-machine
			(zone-window
			  (text-zone s))))
		    'text-composer))
       (let ((kr (j-geti))			; now record result
	     (xx (j-geti))
	     (yy (j-geti))
	     (nn (j-geti)))
	    (list kr (make-point x (- xx x) y (- yy y)) nn))
  ))

(defun format-draw-text (s)		; draw it while formatting
  (let ((memop (symbolp (text-text s)))	; can only memoize symbols
	((x y) (text-start-point s))
	(k) (p) (q) (l (text-look s)))
       (cond
	 (memop					; are we memoizing? yes!
	   (setq k (unique-look-id l))	; key based on look
	   (setq p (get (text-text s) k))		; alist found on plist
	   (setq q (assoc (text-kl s) p))))		; entry based on kl
       (cond
	 (q (alter-text s			; if info found
	      kr (cadr q)			; record result
	      delta (caddr q)
	      nn (cadddr q))
	    (draw-text s))			; draw it & return
	 (t					; otherwise compute data
	   (j-put-items
	     `((J-STRING compose)
	       (J-INT ,(window-id (zone-window (text-zone s))))
	       (J-STRING ,(text-text s))
	       (J-STRING ,(font-name (look-font l )))
	       (J-INT ,(font-size (look-font l)))
	       (J-INT ,(boole 4 (look-mode l) QUIET))
	       (J-INT ,(look-colour l))
	       (J-INT ,(look-gap l))
	       (J-INT ,(look-ul l))
	       (J-INT ,(text-kl s))
	       (J-INT ,x)
	       (J-INT ,y)
	       (J-INT ,(x (cond
			    ((zerop (boole 1 ROTATE-180 (look-mode l)))
			     (ur (zone-box (text-zone s))))
			    (t (ll (zone-box (text-zone s)))))))
	       (J-INT ,(y (cond
			    ((zerop (boole 1 ROTATE-90 (look-mode l)))
			     (ur (zone-box (text-zone s))))
			    (t (ll (zone-box (text-zone s)))))))
	       (J-INT -1)			; format to end of text
	      ))
	   (j-send (get (machine-servers
			  (window-machine
			    (zone-window
			      (text-zone s))))
			'text-composer))
	   (let ((kr (j-geti))			; now alter result data
		 (xx (j-geti))
		 (yy (j-geti))
		 (nn (j-geti)))
		(cond ((neq nn (length (exploden (text-text s))))
		       (format-text s))	; actually clipped! reformat
		      (t (alter-text s
			   kr kr
			   delta (make-point x (- xx x) y (- yy y))
			   nn nn)
			 (cond
			   (memop		; memoize if req'd
			     (cond (p (nconc p
					(ncons (list (text-kl s) kr
						     (text-delta s) nn))))
				   (t (putprop (text-text s)
					(ncons (list (text-kl s) kr
						     (text-delta s) nn))
					k))))
			 ))
		))
	 ))
       't))					; always return t

(defun backspace-text (s n)	; undraw last n characters, remove from text
  (cond				; this presumes s has valid delta,kr,nn
    ((plusp (text-nn s))	; proceed only if length > 0
     (setq n (min n (text-nn s)))	; can't delete more than nn chars
     (let ((text (text-text s))
	   (l (text-look s)))
	  (alter-text s		; keep all but last n chars
	    text (substring text 1 (- (text-nn s) n))
	    nn (- (text-nn s) n))
	  (format-text s)		; reformat to find the new end
	  (j-put-items
	    `((J-STRING compose)	; now undraw last character
	      (J-INT ,(window-id (zone-window (text-zone s))))
	      (J-STRING ,(substring text (- n))) ; undraw last n chars
	      (J-STRING ,(font-name (look-font l)))
	      (J-INT ,(font-size (look-font l)))
	      (J-INT ,(boole 7 QUIET OVERSTRIKE (look-mode l)))
	      (J-INT ,(inverse-colour (look-colour l)))
	      (J-INT ,(look-gap l))
	      (J-INT ,(look-ul l))
	      (J-INT ,(text-kr s))
	      (J-INT ,(text-xx s))
	      (J-INT ,(text-yy s))
	      (J-INT ,(x (cond
			   ((zerop (boole 1 ROTATE-180 (look-mode l)))
			    (ur (zone-box (text-zone s))))
			   (t (ll (zone-box (text-zone s)))))))
	      (J-INT ,(y (cond
			   ((zerop (boole 1 ROTATE-90 (look-mode l)))
			    (ur (zone-box (text-zone s))))
			   (t (ll (zone-box (text-zone s)))))))
	      (J-INT ,n)
	     ))
	  (j-send (get (machine-servers
			 (window-machine
			   (zone-window
			     (text-zone s))))
		       'text-composer))
	  't))			; return t if able to do it; nil if nn <= 0
  ))

(defun append-text (s c)	; draw new char(s) & add to end of text
  (cond ((fixp c)		; this presumes s has valid delta,kr,nn
	 (setq c (ascii c))))
  (j-put-items
    `((J-STRING compose)	; draw new last character(s)
      (J-INT ,(window-id (zone-window (text-zone s))))
      (J-STRING ,c)
      (J-STRING ,(font-name (look-font (text-look s))))
      (J-INT ,(font-size (look-font (text-look s))))
      (J-INT ,(boole 4 (look-mode (text-look s)) QUIET))	; be noisy!
      (J-INT ,(look-colour (text-look s)))
      (J-INT ,(look-gap (text-look s)))
      (J-INT ,(look-ul (text-look s)))
      (J-INT ,(text-kr s))	; this presumes s has valid delta,kr,nn
      (J-INT ,(text-xx s))
      (J-INT ,(text-yy s))
	       (J-INT ,(x (cond
			    ((zerop (boole 1 ROTATE-180 (look-mode l)))
			     (ur (zone-box (text-zone s))))
			    (t (ll (zone-box (text-zone s)))))))
	       (J-INT ,(y (cond
			    ((zerop (boole 1 ROTATE-90 (look-mode l)))
			     (ur (zone-box (text-zone s))))
			    (t (ll (zone-box (text-zone s)))))))
      (J-INT -1)
     ))
  (j-send (get (machine-servers
		 (window-machine
		   (zone-window
		     (text-zone s))))
	       'text-composer))
  (let ((kr (j-geti))
	(xx (j-geti))
	(yy (j-geti))
	(nn (j-geti)))
       (alter-text s
	 text (concat (text-text s) c)
	 kr kr
	 delta (subtract-points
		 (make-point x xx y yy)
		 (text-start-point s))
	 nn (+ (text-nn s) nn)))
  't)

(defun append-text-scroll (s c colour) ; draw and add new char(s)
  (let ((w (window-id	;  while scrolling zone box b in specified colour
	     (zone-window (text-zone s))))
	(b (zone-box (text-zone s)))
	(l (text-look s)))
       (cond ((fixp c)
	      (setq c (ascii c)))) ; this presumes s has valid delta,kr,nn
       (j-put-items
	 `((J-STRING compose)	; format new last character
	   (J-INT ,w)
	   (J-STRING ,c)
	   (J-STRING ,(font-name (look-font l)))
	   (J-INT ,(font-size (look-font l)))
	   (J-INT ,(boole 7 NO-DRAW (look-mode l)))
	   (J-INT ,(look-colour l))
	   (J-INT ,(look-gap l))
	   (J-INT ,(look-ul l))
	   (J-INT ,(text-kr s)) ; this presumes s has valid delta,kr,nn
	   (J-INT 0)
	   (J-INT 0)
	   (J-INT -1)
	   (J-INT -1)
	   (J-INT -1)
	  ))
       (j-send (get (machine-servers
		      (window-machine
			(zone-window
			  (text-zone s))))
		    'text-composer))
       (let ((kr (j-geti))
	     (xx (j-geti))
	     (yy (j-geti))
	     (nn (j-geti)))
	    (apply
	      'w-scroll-rectangle
	      (nconc
		(ncons (window-w (zone-window (text-zone s))))
		(let ((direction (boole 1 ROTATION
					(look-mode l))))
		     (cond
		       ((= direction ROTATE-0)
			(list (text-xx s)
			      (y (ll b))
			      (- (x (ur b)) (text-xx s) -1)
			      (- (y (ur b)) (y (ll b)) -1)
			      WM-RIGHT xx))
		       ((= direction ROTATE-90)
			(list (x (ll b))
			      (text-yy s)
			      (- (x (ur b)) (x (ll b)) -1)
			      (- (y (ur b)) (text-yy s) -1)
			      WM-UP yy))
		       ((= direction ROTATE-180)
			(list (x (ll b))
			      (y (ll b))
			      (- (text-xx s) (x (ll b)) -1)
			      (- (y (ur b)) (y (ll b)) -1)
			      WM-LEFT (- xx)))
		       ((= direction ROTATE-270)
			(list (x (ll b))
			      (y (ll b))
			      (- (x (ur b)) (x (ll b)) -1)
			      (- (text-yy s) (y (ll b)) -1)
			      WM-DOWN (- yy)))
		     ))
		(ncons colour)))
	    (w-flush (window-w (zone-window (text-zone s))))
	    (j-put-items
	      `((J-STRING compose)	; draw new last character
		(J-INT ,w)
		(J-STRING ,c)
		(J-STRING ,(font-name (look-font l)))
		(J-INT ,(font-size (look-font l)))
		(J-INT ,(boole 7 (look-mode l) QUIET))
		(J-INT ,(look-colour l))
		(J-INT ,(look-gap l))
		(J-INT ,(look-ul l))
		(J-INT ,(text-kr s)) ; this presumes s has valid delta,kr,nn
		(J-INT ,(text-xx s))
		(J-INT ,(text-yy s))
	       (J-INT ,(x (cond
			    ((zerop (boole 1 ROTATE-180 (look-mode l)))
			     (ur (zone-box (text-zone s))))
			    (t (ll (zone-box (text-zone s)))))))
	       (J-INT ,(y (cond
			    ((zerop (boole 1 ROTATE-90 (look-mode l)))
			     (ur (zone-box (text-zone s))))
			    (t (ll (zone-box (text-zone s)))))))
		(J-INT -1)
	       ))
	    (j-send (get (machine-servers
			   (window-machine
			     (zone-window
			       (text-zone s))))
			 'text-composer))
	    (alter-text s
	      text (concat (text-text s) c)
	      kr kr
	      delta (add-points
		      (make-point x xx y yy)
		      (text-delta s))
	      nn (+ (text-nn s) nn))
       )'t))

(defun format-text-list (sl)			; chain the text objects
  (do ((s (car sl) (car sl))			; so that xx,yy,kr of one
       (sl (cdr sl) (cdr sl)))			; used as x,y,kl of next
      ((null sl) (format-text s) 't)
      (format-text s)
      (alter-text (car sl)
	kl (text-kr s))
      (move-text (car sl) (text-end-point s))
  ))

(defun move-text-list (sl p)	; move whole list of text objects
  (do ((s (car sl) (car sl))
       (sl (cdr sl) (cdr sl))
       (p p (text-end-point s)))
      ((null s) 't)
      (move-text s p)
  ))

(defun compress-text-list (sl)		; combine like-moded text objects
  (do ((s (car sl) (car sl))			; to reduce communication
       (sl (cdr sl) (cdr sl))
       (new-text nil)
       (new-end-point (text-start-point s))
       (new-s (append (car sl) nil))	; top-level copy
       (dx nil)
       (gap (look-gap (text-look (car sl))))
       (result nil))
      ((null s) (alter-text new-s
		   text (apply 'concat (nreverse new-text))
		   nn -1)
       (nreverse (cons new-s result)))		; return new s-list
      (setq dx (- (x (text-start-point s))
		  (x new-end-point)))
      (cond ((and			; check most likely diffs first
	       (or (eq dx 0) (>= dx (look-gap (text-look s))))
	       (= (y (text-start-point s)) (y new-end-point))
	       (eq (text-look s)
		   (text-look new-s))
	     )				; presume kerning doesn't matter!
	     (cond ((plusp dx)		; horizontal movement
		    (setq new-text
			  (cons
			    (implode
			      (do ((dx (- dx gap 4) (- dx gap 4))
				   (result nil))
				  ((minusp dx)
				   (do ((dx (+ dx 4 -1) (- dx gap 1)))
				       ((minusp dx)
					(cond ((eq dx -1)
					       (setq result
						     (cons 1 result)))))
							; 0-pixel space
				       (setq result (cons 2 result)))
							; 1-pixel space
				   result)
				  (setq result (cons 3 result))
							; 4-pixel space
			      ))
			    new-text))))
	     (setq new-text (cons (text-text s) new-text))
	     (setq new-end-point (text-end-point s))
	    )
	    (t (alter-text new-s
		 text (apply 'concat (nreverse new-text))
		 nn -1
		 delta (subtract-points new-end-point
			 (text-start-point new-s)))
	       (setq result (cons new-s result))
	       (setq new-s (append s nil)
		     new-text (ncons (text-text s)))
	       (setq
		 new-end-point (text-start-point s)
		 gap (look-gap (text-look s)))
	    )
      )))

(defun draw-text-list (sl)
  (mapc '(lambda (x) (draw-text x)) sl) 't)

(defun undraw-text-list (sl)
  (mapc '(lambda (x) (undraw-text x)) sl) 't)

(defun format-draw-text-list (slist) ; format all on same line
  (do ((s (car slist) (car sl))
       (sl (cdr slist) (cdr sl)))
      ((null sl) (format-draw-text s))	; format the last one
      (format-draw-text s)
      (move-text (car sl)	; chain xx,yy,kr to next one's x,y,kl
	(text-end-point s))
  ))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; text-edit.l -- rudimentary line editor for fancy character texts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; These routines provide a simple line editor with control keys reminiscent
;;; of the default EMACS key bindings.
;;;
;;; The calling program presumably has obtained a "point" event, at
;;; position "p".  The cursor will be placed on the nearest character,
;;; and then input is accepted from the keyboard, until such time as a
;;; <return> key is accepted, or a point event occurs outside the text
;;; zone boundary, or until a non-key, non-point event occurs.  Another
;;; point event within the text zone causes the cursor to be re-positioned.
;;;
;;; Editing operations currently supported are:
;;;	CTRL-A (ascii 1)	; control A = beginning of line
;;;	CTRL-B (ascii 2)	; control B = backward-character
;;;	CTRL-D (ascii 4)	; control D = delete next char
;;;	CTRL-E (ascii 5)	; control E = end of line
;;;	CTRL-F (ascii 6)	; control F = forward-character
;;;	BACKSPACE (ascii 8)	; BACKSPACE = delete previous char
;;;	CTRL-K (ascii 11)	; control K = kill to end of line
;;;	CTRL-L (ascii 12)	; control L = redraw text
;;;	RETURN (ascii 13)	; RETURN = "done"
;;;	CTRL-T (ascii 20)	; control T = transpose previous 2 chars
;;;	CTRL-Y (ascii 25)	; control Y = "yank" recently killed text

(declare
  (specials t)
  (macros t))

(eval-when (compile)
  (load 'utilities)
  (load 'constants)
  (load 'zone)
  (load 'font)
  (load 'look)
  (load 'text))


(eval-when (compile eval load)
  (defvar BACKSPACE (ascii 8))	; backspace char = delete previous char
  (defvar RETURN (ascii 13))	; carriage return = "done"
  (defvar CTRL-A (ascii 1))	; control A = beginning of line
  (defvar CTRL-B (ascii 2))	; control B = backward-character
  (defvar CTRL-D (ascii 4))	; control D = delete next char
  (defvar CTRL-E (ascii 5))	; control E = end of line
  (defvar CTRL-F (ascii 6))	; control F = forward-character
  (defvar CTRL-K (ascii 11))	; control K = kill to end of line
  (defvar CTRL-L (ascii 12))	; control L = redraw text
  (defvar CTRL-T (ascii 20))	; control T = transpose previous 2 chars
  (defvar CTRL-Y (ascii 25))	; control Y = "yank" recently killed text
  (defvar TYPEAHEAD-THRESHOLD 5); can type at most 5 chars -> forced feedback
)

(defun edit-text (s p)	; edit a text at point p
  (cond					; p outside zone => nil
    ((not (point-in-box p (zone-box (text-zone s)))) nil)
    (t					; p inside zone => edit text
      (let
	((w (window-w (zone-window (text-zone s))))
	 (post (append s nil))
	 (kill-text ""))
	(split-texts s post p)	; split into left and right parts
	(draw-cursor-leading-text post)	; highlight first char
	(skip-stroke-release-events w)
	(do ((e (w-get-next-event w)		; get an event
		(w-get-next-event w))		; then keep getting events
	     (l) (c))				; character list, character
	    ((eq c '#.RETURN)		; stop when <return> is received
	     (cond ((neq e WM-KEY)	; if not caused by key, put event back
		    (w-put-back-event w)))
	     (combine-texts s post)
	     t)			; just return 't
	    (cond			; main loop
	      ((eq e WM-KEY)
	       (setq c (concat (car (w-get-key w))))	; get the character
	       (cond
		 ((eq c '#.BACKSPACE)		; backspace char
		  (text-delete-previous-character s post))
		 ((eq c '#.CTRL-A)			; control A
		  (text-beginning-of-line s post))
		 ((eq c '#.CTRL-B)			; control B
		  (text-backward-character s post))
		 ((eq c '#.CTRL-D)			; control D
		  (text-delete-next-character s post))
		 ((eq c '#.CTRL-E)			; control E
		  (text-end-of-line s post))
		 ((eq c '#.CTRL-F)			; control F
		  (text-forward-character s post))
		 ((eq c '#.CTRL-K)			; control K
		  (text-kill-to-end-of-line s post))
		 ((eq c '#.CTRL-L)			; control L
		  (text-redraw-display s post))
		 ((eq c '#.CTRL-T)			; control T
		  (text-transpose-characters s post))
		 ((eq c '#.CTRL-Y)			; control Y
		  (text-yank-from-killbuffer s post))
		 ((neq c '#.RETURN)			; not <return>
		  (text-insert-character s post))
		 (t (w-put-back-event w))	; it's a <return>; put it back
	       ))			; so loop control can get it again
	      ((eq e WM-POINT-DEPRESSED)
	       (setq p (w-get-point w))
	       (cond				; check point in zone
		 ((point-in-box p (zone-box (text-zone s)))
		  (draw-cursor-leading-text post)	; un-highlight char
		  (combine-texts s post)
		  (split-texts s post p)
		  (draw-cursor-leading-text post)	; highlight new char
		  (skip-stroke-release-events w))
		 (t (w-put-back-event w)	; outside zone => return
		    (setq c '#.RETURN))))
	      ((neq e WM-CANCEL)		; an event we can't handle
	       (w-put-back-event w)		; so put it back, then return
	       (setq c '#.RETURN))
	    )))
    )))

(defun input-typeahead-keys (w n brk-fcn l)	; return keys typed ahead
   (cond					; brk-fcn tests text
     ((or (zerop n)				; already have max typeahead
	  (not (w-any-events w))) (nreverse l))	; or there aren't any events
     (t (let ((x (w-get-next-event w)))		; there's an event
	     (cond
	       ((neq x WM-KEY)
		(w-put-back-event w) (nreverse l))	; but not a keystroke
	       (t (setq x (car (w-get-key w)))		; it's a keystroke
		  (cond
		    ((funcall brk-fcn x)		; is it a break char?
		     (w-put-back-event w) (nreverse l))	; it's a special char
		    (t (input-typeahead-keys		; it's a regular char
			 w (1- n) brk-fcn (cons x l)))	; tail recur for rest
		  )))))))

(defun split-texts (s post p)		; split text s at point p
  (let					; yielding texts s and post
    (((kr delta nn) (scan-text s p)))	; scan for char pos'n
    (alter-text post			; text incl & after char pt'ed
      text (cond ((substring (text-text s) (1+ nn)))	; if it exists!
		 (""))			; otherwise,nothing
      offset (add-points (text-offset s) delta)
      kl kr
      delta (subtract-points (text-delta s) delta)
      nn (- (text-nn s) nn))
    (alter-text s kr kr delta delta nn nn	; truncate text
      text (cond ((substring (text-text s) 1 nn))
		 ("")))
  ))

(defun skip-stroke-release-events (w)
  (do ((e (w-get-next-event w)
	  (w-get-next-event w)))
      ((neq e WM-POINT-STROKE)		; get events until non-point-stroke
       (cond ((neq e WM-POINT-RELEASED)	; should be point-release
	      (w-put-back-event w))))	; if not, put it back
  ))

(defun combine-texts (s post)	; recombine texts
  (alter-text s
    text (concat (text-text s) (text-text post))
    nn (+ (text-nn s) (text-nn post))
    delta (add-points (text-delta s) (text-delta post))
    kr (text-kr post))
  (format-text s))

(defun draw-cursor-leading-text (s)	; highlight first char of text
  (let ((c (append s nil)))
       (alter-text c			; get first char
	 text (concat (cond ((substring (text-text c) 1 1))	; if any
			    (t 'a))))	; otherwise use a typical character
       (format-text c)
       (w-clear-rectangle
	 (window-w (zone-window (text-zone c)))
	 (text-x c)
	 (y (ll (zone-box (text-zone c))))
	 (min (x (text-delta c))
	      (- (x (ur (zone-box (text-zone c))))
		 (text-x c) -1))
	 (- (y (ur (zone-box (text-zone c))))
	    (y (ll (zone-box (text-zone c)))) -1)
	 W-XOR)
       (w-flush (window-w (zone-window (text-zone c))))
       t))

(defun text-delete-previous-character (s post)
  (let ((l (input-typeahead-keys w TYPEAHEAD-THRESHOLD
	     '(lambda (x)	; break on first non-BS
		(not (equal x #.(get_pname BACKSPACE))))
	     (ncons '#.BACKSPACE))))
       (alter-text s
	 nn (max 0 (- (text-nn s) (length l))))
       (alter-text s
	 text (cond ((substring
		       (text-text s)
		       1 (text-nn s)))
		    ("")))
       (format-text s)
       (w-scroll-rectangle
	 (window-w (zone-window (text-zone s)))
	 (text-xx s)
	 (y (ll (zone-box (text-zone s))))
	 (- (x (ur (zone-box (text-zone s))))
	    (text-xx s) 1)
	 (1+ (y (box-size (zone-box (text-zone s)))))
	 WM-LEFT
	 (- (x (text-start-point post))
	    (x (text-end-point s)))
	 (zone-colour (text-zone s)))
       (w-flush
	 (window-w (zone-window (text-zone s))))
       (move-text post (text-end-point s))
       (alter-text post kl (text-kr s))))

(defun text-beginning-of-line (s post)
  (draw-cursor-leading-text post)	; un-highlight first char
  (alter-text post
    text (concat (text-text s) (text-text post))
    nn (+  (text-nn s) (text-nn post))
    delta (add-points (text-delta s) (text-delta post))
    kl 0
    offset (text-offset s))
  (alter-text s text "" nn 0 delta '(0 0) kr 0)
  (draw-cursor-leading-text post))	; highlight new first char

(defun text-backward-character (s post)
  (let ((l (input-typeahead-keys w TYPEAHEAD-THRESHOLD
	     '(lambda (x)	; break on first non-BS
		(not (equal x #.(get_pname CTRL-B))))
	     (ncons '#.CTRL-B))))
       (draw-cursor-leading-text post)	; un-highlight first char
       (alter-text post
	 text (get_pname (concat (substring (text-text s) (- (length l)))
			   (text-text post)))
	 nn (1+ (text-nn post)))
       (alter-text s
	 text (substring (text-text s) 1 (- (text-nn s) (length l)))
	 nn (- (text-nn s) (length l)))
       (format-text s)
       (alter-text post
	 kl (text-kr s)
	 offset (add-points (text-offset s) (text-delta s))
	 delta (subtract-points
		 (text-end-point post)
		 (text-end-point s)))
       (draw-cursor-leading-text post)	; highlight new first char
  ))

(defun text-forward-character (s post)
  (let ((l (input-typeahead-keys w TYPEAHEAD-THRESHOLD
	     '(lambda (x)	; break on first non-BS
		(not (equal x #.(get_pname CTRL-F))))
	     (ncons '#.CTRL-F))))
       (draw-cursor-leading-text post)	; un-highlight first char
       (alter-text s
	 text (get_pname (concat (text-text s)
			   (substring (text-text post) 1 (length l))))
	 nn (+ (text-nn s) (length l)))
       (format-text s)
       (alter-text post
	 text (substring (text-text post) (1+ (length l)))
	 nn (- (text-nn post) (length l))
	 kl (text-kr s)
	 offset (add-points (text-offset s) (text-delta s))
	 delta (subtract-points
		 (text-end-point post)
		 (text-end-point s)))
       (draw-cursor-leading-text post)	; highlight new first char
  ))

(defun text-end-of-line (s post)
  (draw-cursor-leading-text post)	; un-highlight first char
  (alter-text s
    text (concat (text-text s) (text-text post))
    nn (+  (text-nn s) (text-nn post))
    delta (add-points (text-delta s) (text-delta post))
    kr (text-kr post))
  (alter-text post
    text ""
    nn 0
    offset (add-points (text-offset post) (text-delta post))
    delta '(0 0)
    kl (text-kr s))
  (draw-cursor-leading-text post))	; highlight new first char
  
(defun text-kill-to-end-of-line (s post)
  (w-clear-rectangle
    (window-w (zone-window (text-zone post)))
    (text-x post)
    (y (ll (zone-box (text-zone post))))
    (- (x (ur (zone-box (text-zone post)))) (text-x post))
    (1+ (y (box-size (zone-box (text-zone post)))))
    (zone-colour (text-zone post)))
  (setq kill-text (text-text post))
  (alter-text post
    text ""
    nn 0
    delta '(0 0)
    kl (text-kr s))
  (draw-cursor-leading-text post))	; highlight new first char
  
(defun text-yank-from-killbuffer (s post)
  (append-text-scroll s kill-text
    (zone-colour (text-zone s)))
  (move-text post (text-end-point s))
  (alter-text post
    kl (text-kr s)))

(defun text-transpose-characters (s post)
  (let ((tmp (append s nil)))
       (alter-text tmp
	 nn (- (text-nn tmp) 2))
       (let (((kr delta nn) (scan-text tmp '(-1 -1)))) ; find 2nd prev char
	    (alter-text tmp
	      text (substring (text-text tmp) -2)
	      offset (add-points (text-offset tmp) delta)
	      kl kr)
	    (format-text tmp)
	    (w-clear-rectangle
	      (window-w (zone-window (text-zone tmp)))
	      (text-x tmp)
	      (y (ll (zone-box (text-zone tmp))))
	      (x (text-delta tmp))
	      (1+ (y (box-size (zone-box (text-zone tmp)))))
	      (zone-colour (text-zone tmp)))
	    (w-flush (window-w (zone-window (text-zone tmp))))
	    (alter-text tmp
	      text (get_pname (concat
				(substring (text-text tmp) 2 1)
				(substring (text-text tmp) 1 1))))
	    (format-draw-text tmp)
	    (alter-text s
	      text (get_pname
		     (concat
		       (substring (text-text s) 1 (- (text-nn s) 2))
		       (text-text tmp)))
	      kr (text-kr tmp))
       )))

(defun text-delete-next-character (s post)
  (let ((l (input-typeahead-keys w TYPEAHEAD-THRESHOLD
	     '(lambda (x)	; break on first non-BS
		(not (equal x #.(get_pname CTRL-D))))
	     (ncons '#.CTRL-D))))
       (alter-text post
	 nn (length l))
       (let (((kl delta nn)		; scan for nn'th char position
	      (scan-text post '(-1 -1))))
	    (w-scroll-rectangle
	      (window-w (zone-window (text-zone post)))
	      (text-x post)
	      (y (ll (zone-box (text-zone post))))
	      (- (x (ur (zone-box (text-zone post))))
		 (text-x post) 1)
	      (1+ (y (box-size (zone-box (text-zone post)))))
	      WM-LEFT
	      (x delta)
	      (zone-colour (text-zone post)))
	    (alter-text post
	      nn (max 0 (- (length (exploden (text-text post)))
			   (length l)))
	      kl kl)
	    (alter-text post
	      text (cond ((substring
			    (text-text post)
			    (- (text-nn post))))
			 ("")))
	    (format-text post)
	    (draw-cursor-leading-text post)
	    (w-flush (window-w (zone-window (text-zone post))))
       )))

(defun text-insert-character (s post)
  (let ((l (input-typeahead-keys w TYPEAHEAD-THRESHOLD
	     '(lambda (x)	; break on first BS or CR
		(memq (concat x) '#.(list BACKSPACE RETURN)))
	     (ncons c))))
       (append-text-scroll s (concatl l)
	 (zone-colour (text-zone s)))
       (move-text post (text-end-point s))
       (alter-text post
	 kl (text-kr s))))

(defun text-redraw-display (s post)
  (clear-zone (text-zone s) (zone-colour (text-zone s)))
  (w-flush (window-w (zone-window (text-zone post))))
  (format-draw-text s)
  (alter-text post
    kl (text-kr s)
    offset (add-points (text-offset s) (text-delta s)))
  (format-draw-text post)
  (draw-cursor-leading-text post))
;;; -*- Mode: Lisp; Syntax: Common-Lisp; -*-

(define-language
  :grammar
  '(((S $any) -> (S1 $any))
    ((S (Compound $s1 $s2)) -> (S1 $s1) (Conjunction) (S1 $s2))
    
    ((S1 (Statement $v)) -> (NP $subj) (VP $subj $tense $v))
    ((S1 (Acknowledge $a)) -> (Acknowledge $a))
    ((S1 (Command $v)) -> (VP Self present $v))
    ((S1 (Question $v)) -> (Aux $tense) (NP $subj) (VP $subj $tense $v))
    ((S1 (Question $v)) -> (Be $tense) (NP $subj) (Be-Arg $subj $tense $v))

    ((Be-Arg $subj $tense (Occur $tense (loc $subj $loc))) ->
     (Loc-Adjunct $tense (loc $subj $loc)))

    ((VP $subj $tense (Occur $tense $v)) -> (VP1 $subj $tense $v))
    ((VP $subj $tense (Occur $tense $v)) -> (Aux $tense)(VP1 $subj present $v))

    ((VP1 $subj $tense $v) -> (VP2 $subj $tense $v) (Adjunct? $v))

    ((VP2 $subj $tense ($rel $subj $loc)) ->
     (Verb/in $rel $tense))
    ((VP2 $subj $tense ($rel $subj $loc $obj)) ->
     (Verb/tr $rel $tense) (NP $obj))
    ((VP2 $subj $tense ($rel $subj $loc $obj $obj2)) -> 
     (Verb/di $rel $tense) (NP $obj) (NP $obj2))
    ((VP2 $subj $tense (loc $subj $loc)) ->
     (Be $tense) (Loc-Adjunct $tense (loc $subj $loc)))

    ((NP $n) -> (Pronoun $n))
    ((NP $n) -> (Article) (Noun $n))
    ((NP $n) -> (Noun $n))
    ((NP ($x $y)) -> (Number $x) (Number $y))

    ((PP ($prep $n)) -> (Prep $prep) (NP $n))
    ((Adjunct? $v) ->)
    ((Adjunct? $v) -> (Loc-Adjunct $tense $v))
    #+Allegro ((Loc-Adjunct $tense ($rel $subj $loc @rest)) -> (PP $loc))
    #+Allegro ((Loc-Adjunct $tense ($rel $subj $loc @rest)) -> (Adjunct $loc))
    #+Lucid ((Loc-Adjunct $tense ($rel $subj $loc . $rest)) -> (PP $loc))
    #+Lucid ((Loc-Adjunct $tense ($rel $subj $loc . $rest)) -> (Adjunct $loc))

    )
  :lexicon
  '(
    ((Acknowledge $a) -> (yes true) (no false) (maybe unknown) (huh unparsed))
    ((Adjunct $loc) -> here there (nearby near) near left right up down)
    ((Article) -> a an the)
    ((Aux $tense) -> (will future) (did past) (do $finite))
    ((Be $tense) -> (am present) (are present) (is present) (be $finite)
     (was past) (were past))
    ((Conjunction) -> and --)
    ((Noun $n) -> gold Wumpus pit breeze stench glitter nothing)
    ((Number $n) -> 0 1 2 3 4 5 6 7 8 9)
    ((Prep $prep) -> in at to near)
    ((Pronoun $n) -> (you self) (me master) (I master))
    
    ((Verb/in $rel $tense) -> (go move $finite) (went move past)
     (move move $finite) (move move past) (shoot shoot $finite))
    ((Verb/tr $rel $tense) -> (move carry $finite) (moved carry past)
     (carry carry $finite) (carry carried past)
     (grab grab $finite) (grab grabbed past) (get grab $finite)
     (got grab past) (release release $finite) (release release past)
     (drop release $finite) (dropped release past) (shoot shoot-at $finite)
     (shot shoot-at past) (kill shoot-at $finite) (killed shoot-at past)
     (smell perceive $finite) (feel perceive $finite) (felt perceive past))
    ((Verb/di $rel $tense) -> (bring bring $finite) (brought bring past)
     (get bring $finite) (got bring past))
    ))

(defparameter *sentences*
  '((I will shoot the wumpus at 4 4)
    (yes)
    (You went right -- I will go left)
    (carry the gold)
    (yes and no)
    (did you bring me the gold)
    (a breeze is here -- I am near 5 3)
    (a stench is in 3 5)
    (a pit is nearby)
    (is the wumpus near)
    (Did you go to 3 8)
    (Yes -- Nothing is there)
    (Shoot -- Shoot left)
    (Kill the wumpus -- shoot up)))

(defun ss (&optional (sentences *sentences*))
  "Run some test sentences, and count how many were not parsed."
  (count-if-not
   #'(lambda (s)
       (format t "~2&>>> ~(~{~a ~}~)~%" s)
       (write (second (parse s)) :pretty t))
   *sentences*))
program interval(input,output);
{dataflow simulator for real interval arithmetic}

const
	IMem = 500; {number of instructions}
	DMem = 200;  {number of interval variables allowed}
	Par = 3;   {max number of paramters for an operator}
	Maxexp = 10; Minexp = -9;
	Maxinf =10000; Mininf =-10000; {Tied to values of Minman and Maxman}
	Maxman = 9999; Minman = -9999; {cannot exceed sqrt(maxint)}
	Splitman = 1000; {Smallest normalized mantisa}
	Digits = 4; {number of digits in mantissa}

type
	Positive= 0..maxint;
	State  = -1..99;  {Used for holding state of operator -1:done}
	OpType = (print,pr,tr,soln,readr,halve,halves,linh,mult,add,intgr,
less,leq,noteq,sqrr,minr,maxr,modu,absr,trig,expr,lb,ub,copy,stop); {!!}
	Ptr    = 1..DMem;
	Loc    = 1..IMem;
	Loc0   = 0..IMem;
	EdgeT  = (hout,lin,hin,lout); {Warning this order is important in}
				      {predicates such as gtS,geS}
	CardT  = (finite,infinite);
	ExpT   = Minexp..Maxexp;
	ManT   = Mininf..Maxinf; 
	Pflag  = (PNull,PSoln,PTrace,PPrint);
	Sreal  = record
		    edge:EdgeT;
		    cardinality:CardT;
		    exp:ExpT; {exponent}
		    mantissa:ManT;
		 end;
	Int    = record
		    hi:Sreal;
		    lo:Sreal;
	 end;
	Instr  = record
		    Code:OpType;
		    Pars: array[0..Par] of 0..DMem;
		 end;
	DataMem= record
		    D        :array [Ptr] of Int;
		    S        :array [Loc] of State;
		    LastHalve:Loc;
		    RHalve   :array [Loc] of real;
		 end;
	DataFlags=record
		    PF	     :array [Ptr] of Pflag;
		 end;
var
	Debug  : (none,activity,post,trace,dump);
	Cut    : (once,all);
	GlobalEnd,Verifiable:boolean;
	HalveThreshold:real;
	I      : array [Loc] of Instr; {Memory holding instructions}
	End    : Loc; {last instruction in I}
	ParN   : array [OpType] of -1..Par; {number of parameters for each 
			opcode. -1 means no result}
        ParIntersect : array [OpType] of boolean ;
	DInit  : DataMem; {initial memory which is cleared and 
				used in first call}
	DF     : DataFlags; {hold flags for variables, e.g. print/trace}
	MaxDMem:0..DMem;
	Shift  : array[0..Digits] of 1..maxint;{array of constant multipliers}
						{used for alignment etc.}
	Dummy  :Positive;
	{constant intervals and Sreals}
	PlusInfS,MinusInfS,PlusSmallS,MinusSmallS,ZeroS,
	PlusFiniteS,MinusFiniteS:Sreal;
	Zero,All,AllFinite:Int;

procedure deblank;
var Ch:char;
begin
   while (not eof) and (input^ in [' ','	']) do read(Ch);
end;

procedure InitialOptions;

#include '/user/profs/cleary/bin/options.i';

   procedure Option;
   begin
      case Opt of
      'a','A':Debug:=activity;
      'd','D':Debug:=dump;
      'h','H':HalveThreshold:=StringNum/100;
      'n','N':Debug:=none;
      'p','P':Debug:=post;
      't','T':Debug:=trace;
      'v','V':Verifiable:=true;
      end;
   end;

begin
   Debug:=trace;
   Verifiable:=false;
   HalveThreshold:=67/100;
   Options;
   writeln(Debug);
   writeln('Verifiable:',Verifiable);
   writeln('Halve threshold',HalveThreshold);
end;{InitialOptions}

procedure NormalizeUp(E,M:integer;var S:Sreal;var Closed:boolean);
begin
with S do
begin
   if M=0 then S:=ZeroS else
   if M>0 then
   begin
      while M>=Maxinf do
      begin 
	 if M mod 10 > 0 then begin Closed:=false;M:=(M div 10)+1 end
	 else M:=M div 10;
	 E:=E+1;
      end;
	 
      while M < Maxinf div 10 do
      begin M:=M*10; E:=E-1; 
      end;

      if E > Maxexp then {overflow-set to infinity}
      begin 
	 S:=PlusInfS;
	 Closed:=false;
      end else
      if E < Minexp then {underflow-set to smallest positive value}
      begin 
         S:=PlusSmallS;
         Closed:=false;
      end else
      begin cardinality:=finite;exp:=E;mantissa:=M;
      end;
   end else	 
   if M < 0 then
   begin
      while M <= Mininf do
      begin 
	 if M mod 10 < 0 then Closed:=false else
	 if M mod 10 > 0 then halt;
	 M:=M div 10;
	 E:=E+1;
      end;
	 
      while M > (Mininf div 10) do
      begin M:=M*10; E:=E-1; 
      end;

      if E > Maxexp then {overflow-set to most negative value}
      begin 
         S:=MinusFiniteS;
         Closed:=false;
      end 
      else
      if E < Minexp then {underflow-set to zero}
      begin
         S:=ZeroS;
         Closed:=false;
      end else
      begin
         cardinality:=finite;exp:=E;mantissa:=M;
      end;
   end;
end;
end;{NormalizeUp}

procedure NormalizeDn(E,M:integer;var S:Sreal;var Closed:boolean);
begin
with S do
begin
   if M=0 then S:=ZeroS else
   if M>0 then
   begin
      while M >= Maxinf do
      begin 
	 if M mod 10 > 0 then Closed:=false else
	 if M mod 10 < 0 then halt;
	 M:=M div 10;
	 E:=E+1;
      end;
	 
      while (M < Maxinf div 10) do
      begin M:=M*10; E:=E-1; 
      end;

      if E > Maxexp then {overflow-set to largest positive value}
      begin 
	 S:=PlusFiniteS;
	 Closed:=false;
      end else
      if E < Minexp then {underflow-set to zero}
      begin S:=ZeroS; Closed:=false;
      end else
      begin cardinality:=finite;exp:=E;mantissa:=M;
      end;
   end else	 
   if M < 0 then
   begin
      while M <= Mininf do
      begin 
	 if M mod 10 < 0 then 
	 begin Closed:=false; M:=M div 10 -1;end
	 else 
	 if M mod 10 = 0 then M:=M div 10 
	 else halt;
	 E:=E+1;
      end;
	 
      while (M>Mininf div 10) do
      begin M:=M*10; E:=E-1; 
      end;

      if E > Maxexp then {overflow}
      begin 
         S:=MinusInfS;
         Closed:=false;
      end 
      else
      if E < Minexp then {underflow}
      begin S:=MinusSmallS; Closed:=false;
      end else
      begin
         cardinality:=finite;exp:=E;mantissa:=M;
      end;
   end;
end;
end;{NormalizeDn}

procedure WriteS(X:Sreal);
var E,M:integer;
begin
with X do
begin
   case edge of
   lin: write('[');
   lout: write('(');
   hin,hout:
   end;
   
   case cardinality of
   infinite: write('inf':Digits+4); 
   finite: 
      if mantissa = 0 then write(0:Digits+1,' ':3)
      else begin
         M:=mantissa;
	 E:=exp; 
         while (M mod 10 = 0) do
	 begin M:=M div 10; E:=E+1;
	 end;
         write(M:Digits+1,'e',E-Digits:2);
      end;
   end;
   
   case edge of 
   hin: write(']');
   hout:write(')');
   lin,lout:
   end;
end;
end;{WriteS}

procedure WriteInt(I:Int);
begin
   with I do begin WriteS(lo); write(','); WriteS(hi); end;
end;{WriteInt}
   
procedure DumpS(X:Sreal);
begin
with X do
   write(edge:4,cardinality:9,mantissa:7,exp:3);
end;{DumpS}

procedure DumpInt(I:Int);
begin
   with I do begin DumpS(lo); write(' || '); DumpS(hi); end;
end;{DumpInt}
   
procedure ReadInt(var I:Int);

var   Ch:char;
      Cll,Clu:boolean;
	
   procedure ReadSUp(var X:Sreal; var Closed:boolean);
   var E,M:integer;
   begin
      with X do
      begin
         deblank;
         case input^ of
         '~':begin X:=PlusInfS;read(Ch);
	     end;
         '-','+','0','1','2','3','4','5','6','7','8','9':
	 begin
	    cardinality:=finite;
   	    read(M);
	    read(E); E:=E+Digits;
	    NormalizeUp(E,M,X,Closed);
	 end;
	 end;{case}
      end;
   end;{ReadSUp}

   procedure ReadSDn(var X:Sreal; var Closed:boolean);
   var E,M:integer;
       Ch:char;
   begin
      with X do
      begin
         deblank;
         case input^ of
         '~':begin X:=MinusInfS;read(Ch);
	     end;
         '-','+','0','1','2','3','4','5','6','7','8','9':
	 begin
	    cardinality:=finite;
   	    read(M);
	    read(E); E:=E+Digits;
	    NormalizeDn(E,M,X,Closed);
	 end;
	 end;{case}
      end;
   end;{ReadSDn}
begin{ReadInt}
   with I do 
   begin 
      deblank; read(Ch); 
      case Ch of
      '[':Cll:=true;
      '(':Cll:=false;
      end;
      ReadSDn(lo,Cll);if Cll then lo.edge:=lin else lo.edge:=lout;
      deblank;
      read(Ch); assert(Ch=',');
      Clu:=true;
      ReadSUp(hi,Clu);
      deblank;
      read(Ch);
      case Ch of
      ']':if Clu then hi.edge:=hin else hi.edge:=hout;
      ')':hi.edge:=hout;
      end;
   end;
end;{ReadInt}
   
procedure DumpTables;
var tL:Loc; tPar:0..Par; tOp:OpType;
begin
	for tOp := print to stop do
	   writeln(tOp:6,ParN[tOp]:2);
	writeln;

	for tL := 1 to End do
	with I[tL] do
	begin
	   write(Code:5);
	   for tPar := 0 to Par do
	      if Pars[tPar] <> 0 then write(Pars[tPar]:4);
	   writeln;
	end;
	writeln('number of memory locations used:',MaxDMem:0);
	writeln;
end;{DumpTables}
	
procedure AlignUp
   (E0:ExpT;M0:ManT;E1:ExpT;M1:ManT;var E,N0,N1:integer;var Closed:boolean);
{Align mantissas M0,M1 preserving accuracy and rounding up wherever possible}
{common resulting exponents in E, and mantissas in N0,N1}
var D:Positive;
begin
   if M0=0 then begin E:=E1;N0:=0;N1:=M1;end else
   if M1=0 then begin E:=E0;N0:=M0;N1:=0;end else
   if E0=E1 then
   begin E:=E0; N0:=M0; N1:=M1;
   end else
   if (E0>E1) then AlignUp(E1,M1,E0,M0,E,N1,N0,Closed) else
   begin
      D:=E1-E0;
      if D>= 2*Digits then
      begin 
         N1:=M1*Maxinf; E:=E1-Digits;
	 if M0<0 then N0:=0 else N0:=1;
	 Closed:=false;
      end else
      if D > Digits then
      begin 
         N1:=M1*Maxinf; E:=E1-Digits; 
	 if (M0 mod Shift[D-Digits]) = 0 
	 then N0:=(M0 div Shift[D-Digits])
	 else
	    if M0 > 0 then N0:=(M0 div Shift[D-Digits])+1
	              else N0:=(M0 div Shift[D-Digits]);
      end else
      {Digits>=D>=0}
      begin N1:=M1*Shift[D]; E:=E1-D; N0:=M0;
      end;
   end;
end;{AlignUp}

function gtS(X,Y:Sreal):boolean;
{X>Y  careful need to be able to compare x] and (x etc.}
var gt:boolean;
begin
   if (X.exp=Y.exp)and(X.mantissa=Y.mantissa) then gt:=X.edge>Y.edge else
   if X.exp = Y.exp then gt:= (X.mantissa > Y.mantissa) else
   if X.mantissa = 0 then gt:= 0 > Y.mantissa else
   if Y.mantissa = 0 then gt:= X.mantissa > 0 else
   if (X.mantissa>0) and (Y.mantissa>0) then gt:= (X.exp > Y.exp) else
   if (X.mantissa>0) and (Y.mantissa<0) then gt:= true else
   if (X.mantissa<0) and (Y.mantissa>0) then gt:= false else
   if (X.mantissa<0) and (Y.mantissa<0) then gt:= (X.exp < Y.exp) 
   else  writeln('error in gtS');
   
   gtS:=gt;
end;{gtS}
   
function geS(X,Y:Sreal):boolean;
{X>=Y  careful need to be able to compare x] and (x etc.}
begin
   if (X.exp=Y.exp)and(X.mantissa=Y.mantissa) then geS:=X.edge>=Y.edge else
   if X.exp = Y.exp then geS:= (X.mantissa >= Y.mantissa) else
   if X.mantissa = 0 then geS:= 0 >= Y.mantissa else
   if Y.mantissa = 0 then geS:= X.mantissa >= 0 else
   if (X.mantissa>0) and (Y.mantissa>0) then geS:= (X.exp > Y.exp) else
   if (X.mantissa>0) and (Y.mantissa<0) then geS:= true else
   if (X.mantissa<0) and (Y.mantissa>0) then geS:= false else
   if (X.mantissa<0) and (Y.mantissa<0) then geS:= (X.exp < Y.exp) 
   else  writeln('error in geS');
end;{geS}
   
function Point(X:Int):boolean;
{X=[x,x]}
begin
with X do
   Point:=(lo.edge=lin)and (hi.edge=hin) and 
	  (lo.mantissa=hi.mantissa) and
	  (lo.exp=hi.exp);
end;{Point}

procedure maxS(X,Y:Sreal;var max:Sreal);
begin
	if gtS(X,Y) then max:=X else max:=Y;
end;

procedure minS(X,Y:Sreal;var min:Sreal);
begin
	if gtS(X,Y) then min:=Y else min:=X;
end;

procedure Inter(P,Q:Int;var R:Int);
begin
   minS(P.hi,Q.hi,R.hi);
   maxS(P.lo,Q.lo,R.lo);
end;

function CheckHi(X:Sreal):boolean;
var OK:boolean;
begin
   OK:=true;
   with X do
   begin
      case cardinality of
      infinite:
         if (exp=Maxexp)and(mantissa=Maxinf) then
	 else writeln('**Invalid hi infinity');
      finite:
      begin
         if (mantissa=Maxinf) or (mantissa=Mininf) then
	 begin OK:=false; writeln('**Invalid finite value - hi');
	 end;
	 
         if mantissa = 0 then
	    if (exp=0) then 
	    else 
	    begin OK:=false; writeln('**Invalid zero - hi')
	    end
	 else
	 begin
	    if (mantissa > 0) then
	       if mantissa >= (Maxinf div 10) then {OK}
	       else 
	       begin OK:=false; writeln('**Incorrect normalization - hi') 
	       end
	    else{mantissa<0}
	       if mantissa > (Mininf div 10) then
	       begin OK:=false; writeln('**Incorrect normalization - hi') 
	       end;
	 end;
      end;
      end;{case}

      if not (edge in [hin,hout]) then
      begin
         OK:=false;
	 writeln('**hi edge value incorrect');
      end;
   end;
   
   CheckHi:=OK;
end;{CheckHi}
  
function CheckLo(X:Sreal):boolean;
var OK:boolean;
begin
   OK:=true;
   with X do
   begin
      case cardinality of
      infinite:
         if (exp=Maxexp)and(mantissa=Mininf) then
	 else writeln('**Invalid lo infinity');
      finite:
      begin
         if (mantissa=Maxinf) or (mantissa=Mininf) then
	 begin OK:=false; writeln('**Invalid finite value - hi');
	 end;
	 
         if mantissa = 0 then
	    if (exp=0) then 
	    else 
	    begin OK:=false; writeln('**Invalid zero - lo')
	    end
	 else
	 begin
	       if (mantissa > 0) then
	          if mantissa >= (Maxinf div 10) then{OK}
		  else 
		  begin OK:=false; writeln('**Incorrect normalization - lo') 
		  end
	       else{mantissa<0}
	          if mantissa > (Mininf div 10) then
		  begin OK:=false; writeln('**Incorrect normalization - lo') 
		  end;
	 end;
      end;
      end;{case}

      if not (edge in [lin,lout]) then
      begin
         OK:=false;
	 writeln('**lo edge value incorrect');
      end;
   end;
   
   CheckLo:=OK;
end;{CheckLo}
  
function CheckInt(I:Int):boolean;
var OK:boolean;
begin
   OK:=CheckHi(I.hi) and CheckLo(I.lo);
   if gtS(I.lo,I.hi) then
   begin
      OK:=false;
      writeln('**Limits out of order');
   end;

   if not OK then 
   begin writeln('**Error in Check'); DumpInt(I);
   end;
   
   CheckInt:=OK;
end;

procedure DumpMem(var DCurr:DataMem);
var tD:Ptr; tL:Loc;
begin
   with DCurr do
   begin
        writeln('LastHalve:',LastHalve:0);
	
    	for tL:= 1 to End do
	   writeln(tL:3,S[tL]:2,RHalve[tL]);
	writeln;
	
	for tD:= 1 to MaxDMem do 
	begin 
	   write(tD:5);
	   DumpInt(D[tD]);
	   assert(CheckInt(D[tD]));
	   writeln;
	end;
	writeln;
   end;
end;{DumpMem}

procedure WriteMem(var DCurr:DataMem);
var tD:Ptr; 
begin
   with DCurr do
   begin
	for tD:= 1 to MaxDMem do 
	if (DF.PF[tD] > PNull) or (Debug > activity) then
	begin 
	   write(tD:5);
	   WriteInt(D[tD]);
	   writeln;
	end;
	writeln;
   end;
end;{WriteMem}

procedure OuterExec
(PC:Loc0;DCurr:DataMem;Change:boolean;First:State;
 var OldCounter:Positive;Level:Positive);

var Counter:Positive;
    Fail,AllPoints,LocalChange:boolean;

procedure NewOuter(F:State);
begin OuterExec(PC,DCurr,Change,F,Counter,Level+1);
end;

{!!}
procedure execprint(PC:Loc; L:Ptr; R0:Int);
begin
   DF.PF[L]:=PSoln;
   writeln;
   write(PC:3,L:5);
   WriteInt(R0);
   writeln;
end;

procedure execpr(var Sr:State; L:Ptr);
begin
   Sr:=-1; DF.PF[L]:=PPrint;
end;{execpr}

procedure exectr(var Sr:State; L:Ptr);
begin
   Sr:=-1; DF.PF[L]:=PTrace;
end;{exectr}

procedure execsoln(var Sr:State; L:Ptr);
begin
   Sr:=-1; DF.PF[L]:=PSoln;
end;{execsoln}

procedure execreadr(var Sr:State;var R0:Int);
begin
   writeln;
   write('<<');
   ReadInt(R0);
   Sr:=-1;
end;

function GetReal(E,M:integer):real;
{convert E-exponent,M-mantissa into genuine Pascal real number}
var x:real;
begin
   x:=M/Maxinf;
   while E>0 do begin x:=x*10; E:=E-1; end; 
   while E<0 do begin x:=x/10; E:=E+1; end;
   GetReal:=x; 
end;{GetReal} 
   
procedure Ratio(Lo,Hi:Sreal;var ERat,MRat:integer); 
{compute ratio of Hi to Lo in exponent mantissa form}
begin
   if Lo.mantissa=0 then
   begin{treat zero as if smallest possible positive number}
      ERat:=Hi.exp-Minexp;
      MRat:=Hi.mantissa*10;
   end else
   if Hi.mantissa=0 then
   begin{treat zero as if smallest possible negative number}
      ERat:=Minexp-Lo.exp;
      MRat:=Lo.mantissa*10;
   end
   else begin
      ERat:=Hi.exp-Lo.exp;
      MRat:=(Hi.mantissa*Maxinf) div Lo.mantissa;
   end;
end;{Ratio}
    
function Adjacent(X:Int):boolean;
{are hi and lo bounds adjacent points}
begin
   with X do
   if (hi.mantissa=0) or (lo.mantissa=0) then
      Adjacent:=
         ((hi.mantissa=0)and(lo.mantissa=Mininf div 10)and(lo.exp=Minexp)) or
         ((lo.mantissa=0)and(hi.mantissa=Maxinf div 10)and(hi.exp=Minexp)) 
   else
      Adjacent:=
         ((lo.exp=hi.exp)and(lo.mantissa+1=hi.mantissa)) or
	 ((hi.exp=lo.exp+1)and(hi.mantissa=(lo.mantissa div 10)+1)) or
	 ((hi.exp=lo.exp-1)and((hi.mantissa div 10)-1=lo.mantissa));
end;{Adjacent}

procedure exechalve
   (var PC:Loc0;var Sr:State;var R0:Int;var OK:boolean;var Change:boolean);
{Reduce range of R0 (suceeds twice for two 'halves')}

var EDiff,MDiff,ERat,MRat,MidE,MidM,M0,M1,HiM,HiE:integer;
    Dummy:boolean;
    Mid:Sreal;
    R,D:real;
    OldPC:Loc;
   
    procedure AtEnd;{What to do afer a successful halve}
    begin  
	DCurr.LastHalve:=PC; PC:=0; Sr:=0;
    end;

begin{exechalve}
OldPC:=PC;
with R0 do
 begin
      if DCurr.LastHalve >= PC then {not our turn yet} else
      if (lo.mantissa = hi.mantissa) and (lo.exp=hi.exp) and
         (lo.edge=lin) and (hi.edge=hin)
      then {single point cant be divided} Sr:=-1 
      else
      if Adjacent(R0) and 
	 (((lo.edge=lout) and (hi.edge=hout)) or
	  ((lo.cardinality=infinite)and(hi.edge=hout)) or 
	  ((hi.cardinality=infinite)and(lo.edge=lout))
	 )
      then Sr:=-1
      else
      if Sr=0 then
         begin
            AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);
            MDiff:=M0+M1;
	    D:=GetReal(EDiff,MDiff);
	    if D < DCurr.RHalve[PC]*HalveThreshold 
	    then {already narrowed enough dont bother} 
	       Change:=true {otherwise can terminate too early}
	    else begin
	       DCurr.RHalve[PC]:=D;
               NewOuter(1);
               NewOuter(2);
	       OK:=false;{fail after both alternatives tried}
	    end
         end
   else{Sr=1,2}
   if Adjacent(R0)
   then begin{two adjacent points - needs special care}
      if (hi.edge=hin) and (hi.cardinality=finite) then
      begin
         case Sr of
	 1:hi.edge:=hout;
	 2:begin lo:=hi; lo.edge:=lin;
	   end;
	 end;

         AtEnd;
      end
      else if (lo.edge=lin) and (lo.cardinality=finite) then 
      begin
         case Sr of
	 1:begin hi:=lo; hi.edge:=hin;
	   end;
	 2:lo.edge:=lout;
	 end;
         AtEnd;
      end else {cant be narrowed} Sr:=-1;

   end{adjacent} else
   begin
      if (lo.mantissa < 0) and (hi.mantissa > 0) then
      begin
         MidM:=0; MidE:=0;
      end else
      begin
         Ratio(lo,hi,ERat,MRat);
         if MRat < 0 then MRat:=-MRat;
         R:=GetReal(ERat,MRat);
(*writeln(ERat,MRat,R);*)
         AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);
         MDiff:=M0+M1;
         if (R > 4) or (R < 0.25) then
         begin{divide hi by sqrt of ratio to get midpoint}
	    if hi.mantissa = 0 
	    then begin HiM:=Mininf div 10; HiE:=Minexp;
	    end else
	    begin HiM:=hi.mantissa; HiE:=hi.exp;
	    end;
	    if ERat < 0 then MidE:=HiE-((ERat-1) div 2)
	 	        else MidE:=HiE-(ERat div 2);
	    if odd(ERat) 
	       then MidM:=trunc(HiM*(Maxinf div 100)/sqrt(MRat*10))
	       else MidM:=trunc(HiM*(Maxinf div 100)/sqrt(MRat));
(*writeln(MidE,MidM);*)
         end else
         begin{take (hi+lo)/2 as midpoint}
            MidM:=MDiff div 2 - M1;
	    MidE:=EDiff;
         end;
      end;
      if MidM >= 0 then NormalizeDn(MidE,MidM,Mid,Dummy)
      		   else NormalizeUp(MidE,MidM,Mid,Dummy);
      case Sr of
      1:begin hi:=Mid; hi.edge:=hout;
        end;
      2:begin lo:=Mid; lo.edge:=lin;
        end;
      end;
(*DumpInt(R0);writeln;*)
      AtEnd;
   end;{if Sr}

   AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);
   MDiff:=M0+M1;
   DCurr.RHalve[OldPC]:=GetReal(EDiff,MDiff);

 end;{with}
end;{exechalve}

procedure exechalves
   (var PC:Loc0;var Sr:State;var R0:Int;var OK:boolean;var Change:boolean);
{Reduce range of R0 (suceeds twice for two 'halves')}
{Simple version thats averages exponents}

var EDiff,MDiff,ERat,MRat,MidE,MidM,M0,M1,HiM,HiE:integer;
    Dummy:boolean;
    Mid:Sreal;
    R,D:real;
    OldPC:Loc;
   
    procedure AtEnd;{What to do afer a successful halve}
    begin  
	DCurr.LastHalve:=PC; PC:=0; Sr:=0;
    end;

    procedure Average(Lo,Hi:Sreal;var Exp:integer);
    {compute average of exponents allowing for zero}
    {infinities happen to work because of representation}
    var Le,He:integer;
    begin
       if Lo.mantissa = 0 then
	  Le := Minexp
       else
	  Le := Lo.exp;
       if Hi.mantissa = 0 then
	  He := Minexp
       else
	  He := Hi.exp;
       Exp:= (He + Le - 2*Minexp) div 2 + Minexp;
writeln(Exp,Hi.exp,Lo.exp,Minexp,He,Le);
    end;{Average}

begin{exechalves}
OldPC:=PC;
with R0 do
 begin
      if DCurr.LastHalve >= PC then {not our turn yet} else
      if (lo.mantissa = hi.mantissa) and (lo.exp=hi.exp) and
         (lo.edge=lin) and (hi.edge=hin)
      then {single point cant be divided} Sr:=-1 
      else
      if Adjacent(R0) and 
	 (((lo.edge=lout) and (hi.edge=hout)) or
	  ((lo.cardinality=infinite)and(hi.edge=hout)) or 
	  ((hi.cardinality=infinite)and(lo.edge=lout))
	 )
      then Sr:=-1
      else
      if Sr=0 then
         begin
            AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);
            MDiff:=M0+M1;
	    D:=GetReal(EDiff,MDiff);
	    if D < DCurr.RHalve[PC]*HalveThreshold 
	    then {already narrowed enough dont bother} 
	       Change:=true {otherwise can terminate too early}
	    else begin
	       DCurr.RHalve[PC]:=D;
               NewOuter(1);
               NewOuter(2);
	       OK:=false;{fail after both alternatives tried}
	    end
         end
   else{Sr=1,2}
   if Adjacent(R0)
   then begin{two adjacent points - needs special care}
      if (hi.edge=hin) and (hi.cardinality=finite) then
      begin
         case Sr of
	 1:hi.edge:=hout;
	 2:begin lo:=hi; lo.edge:=lin;
	   end;
	 end;

         AtEnd;
      end
      else if (lo.edge=lin) and (lo.cardinality=finite) then 
      begin
         case Sr of
	 1:begin hi:=lo; hi.edge:=hin;
	   end;
	 2:lo.edge:=lout;
	 end;
         AtEnd;
      end else {cant be narrowed} Sr:=-1;

   end{adjacent} else
   begin
      if (lo.mantissa < 0) and (hi.mantissa > 0) then
      begin
         MidM:=0; MidE:=0;
      end else
      begin
         Ratio(lo,hi,ERat,MRat);
(*writeln(ERat,MRat,R);*)
         AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);
         MDiff:=M0+M1;
         if (ERat > 1) or (ERat < -1) then
         begin{Average exponents}
	    if hi.mantissa <= 0 
	    then begin MidM:= -Splitman;
	    end else
	    begin MidM:= Splitman; assert(lo.mantissa >= 0);
	    end;
            Average(lo,hi,MidE);
         end else
         begin{take (hi+lo)/2 as midpoint}
            MidM:=MDiff div 2 - M1;
	    MidE:=EDiff;
         end;
      end;
      if MidM >= 0 then NormalizeDn(MidE,MidM,Mid,Dummy)
      		   else NormalizeUp(MidE,MidM,Mid,Dummy);
      case Sr of
      1:begin lo:=Mid; lo.edge:=lin;
        end;
      2:begin hi:=Mid; hi.edge:=hout;
        end;
      end;
(*DumpInt(R0);writeln;*)
      AtEnd;
   end;{if Sr}

   AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);
   MDiff:=M0+M1;
   DCurr.RHalve[OldPC]:=GetReal(EDiff,MDiff);

 end;{with}
end;{exechalves}

procedure execlinh
   (var PC:Loc0;var Sr:State;var R0:Int;var OK:boolean;var Change:boolean);
{Reduce range of R0 (suceeds twice for two 'halves')}

var EDiff,MDiff,MidE,MidM,M0,M1:integer;
    Dummy:boolean;
    Mid:Sreal;
    D:real;
    OldPC:Loc;
   
    procedure AtEnd;{What to do afer a successful halve}
    begin  
	DCurr.LastHalve:=PC; PC:=0; Sr:=0;
    end;

begin{execlinh}
OldPC:=PC;
with R0 do
 begin
      if DCurr.LastHalve >= PC then {not our turn yet} else
      if (lo.mantissa = hi.mantissa) and (lo.exp=hi.exp) and
         (lo.edge=lin) and (hi.edge=hin)
      then {single point cant be divided} Sr:=-1 
      else
      if Adjacent(R0) and 
	 (((lo.edge=lout) and (hi.edge=hout)) or
	  ((lo.cardinality=infinite)and(hi.edge=hout)) or 
	  ((hi.cardinality=infinite)and(lo.edge=lout))
	 )
      then Sr:=-1
      else
      if Sr=0 then
         begin
            AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);
            MDiff:=M0+M1;
	    D:=GetReal(EDiff,MDiff);
	    if D < DCurr.RHalve[PC]*HalveThreshold
	    then {already narrowed enough dont bother} 
	       Change:=true {otherwise possible to terminate early}
	    else begin
	       DCurr.RHalve[PC]:=D;
               NewOuter(1);
               NewOuter(2);
	       OK:=false;{fail after both alternatives tried}
	    end
         end
   else{Sr=1,2}
   if Adjacent(R0)
   then begin{two adjacent points - needs special care}
      if (hi.edge=hin) and (hi.cardinality=finite) then
      begin
         case Sr of
	 1:begin lo:=hi; lo.edge:=lin;
	   end;
	 2:hi.edge:=hout;
	 end;
         AtEnd;
      end
      else if (lo.edge=lin) and (lo.cardinality=finite) then 
      begin
         case Sr of
	 1:lo.edge:=lout;
	 2:begin hi:=lo; hi.edge:=hin;
	   end;
	 end;
         AtEnd;
      end else {cant be narrowed} Sr:=-1;
   end{adjacent} else
   begin
      if (lo.mantissa < 0) and (hi.mantissa > 0) then
      begin
         MidM:=0; MidE:=0;
      end else
      begin
         AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);
         MDiff:=M0+M1;
         MidM:=MDiff div 2 - M1;
	 MidE:=EDiff;
      end;
      if MidM >= 0 then NormalizeDn(MidE,MidM,Mid,Dummy)
      		   else NormalizeUp(MidE,MidM,Mid,Dummy);
      case Sr of
      1:begin lo:=Mid; lo.edge:=lin;
        end;
      2:begin hi:=Mid; hi.edge:=hout;
        end;
      end;
      
      AtEnd;
   end;{if Sr}

   AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);
   MDiff:=M0+M1;
   DCurr.RHalve[OldPC]:=GetReal(EDiff,MDiff);

 end;{with}
end;{execlinh}

procedure execmult(var Sr:State;T0,T1,T2:Int;var R0,R1,R2:Int;var OK:boolean);
var Q0,Q1,Q2:Int;

   procedure multS(S0,S1:Sreal;var U,D:Sreal);
   var M,E:integer;
       Closed,Clu,Cld:boolean;
   begin
      M:=S0.mantissa*S1.mantissa;
(*DumpS(S0);write('//');DumpS(S1);write(M);*)
      Closed:=(S0.edge in [hin,lin]) and (S1.edge in [hin,lin]);
      if ((S0.mantissa=0) and (S0.edge in [hin,lin])) or
         ((S1.mantissa=0) and (S1.edge in [hin,lin]))
      then Closed:=true; 
      Clu:=Closed; Cld:=Closed;
      if (S0.cardinality=infinite) or (S1.cardinality=infinite) then
      begin
         if M < 0 then begin D:=MinusInfS; U:=MinusInfS; end else
	 if M > 0 then begin D:=PlusInfS; U:=PlusInfS; end else
	 begin {M=0} D:=ZeroS; U:=ZeroS; end;
	 Closed:=((S0.cardinality=infinite)and(S0.edge in [hin,lin]))or
	         ((S1.cardinality=infinite)and(S1.edge in [hin,lin]));
	 Clu:=Closed;Cld:=Closed;
      end
      else{everybody finite}
      begin
         E:=S0.exp+S1.exp-Digits;
	 NormalizeUp(E,M,U,Clu);
	 NormalizeDn(E,M,D,Cld);
      end;
      if Clu then U.edge:=hin else U.edge:=hout;
      if Cld then D.edge:=lin else D.edge:=lout;      
(*writeln(E);DumpS(U);write('::');DumpS(D);writeln;*)
   end;{multS}
         
   procedure mult(Ta,Tb:Int;var R:Int);
   var U0,U1,U2,U3,U4,U5,D0,D1,D2,D3,D4,D5:Sreal;
   begin
      multS(Ta.hi,Tb.hi,U0,D0);
      multS(Ta.hi,Tb.lo,U1,D1);
      multS(Ta.lo,Tb.hi,U2,D2);
      multS(Ta.lo,Tb.lo,U3,D3);
      maxS(U0,U1,U4);maxS(U2,U3,U5);maxS(U4,U5,R.hi);
      minS(D0,D1,D4);minS(D2,D3,D5);minS(D4,D5,R.lo);
   end;
   
   procedure InvS(S:Sreal;var W:Sreal);
   var E,M,Rem:integer;
       Closed:boolean;
   begin
      Closed:= S.edge in [hin,lin];
      if (S.cardinality = infinite) then
         W:=ZeroS
      else
      if (S.mantissa = 0) then
         case S.edge of
	 hin,hout:W:=MinusInfS;
	 lin,lout:W:=PlusInfS;
	 end
      else
      begin
         M:=(Maxinf*Maxinf) div S.mantissa;
	 Rem:=(Maxinf*Maxinf) mod S.mantissa;
	 if Rem < 0 then halt;
	 E:=-S.exp;
	 case S.edge of
	 lin,lout: begin 
	     	      if (Rem > 0) and (M > 0) then 
		      begin M:=M+1;Closed:=false; 
		      end;
		      NormalizeUp(E,M,W,Closed);
	           end;
	 hin,hout: begin 
	     	      if (Rem > 0) and (M < 0) then 
		      begin M:=M-1;Closed:=false;
		      end;
		      NormalizeDn(E,M,W,Closed);
	           end;
	 end;
      end;
      
      if Closed then
         case S.edge of
         hin:W.edge:=lin;
         lin:W.edge:=hin;
         end
      else
         case S.edge of
	 hin,hout:W.edge:=lout;
	 lin,lout:W.edge:=hout;
	 end;

      
   end;{InvS}	 
   
   procedure Inv(T:Int;var X:Int;Pos:boolean);
   {1/T positive -> X}
   {If 1/T splits to two intervals then use Pos to select which to use}
   begin
      if (T.lo.mantissa < 0) and (T.hi.mantissa > 0) then
         if (T.lo.cardinality=infinite) and (T.hi.cardinality=infinite) then
	    X:=All
	 else if Pos then
	 begin InvS(T.hi,X.lo); X.hi:=PlusInfS; X.hi.edge:=hin;
	 end else 
	 begin InvS(T.lo,X.hi); X.lo:=MinusInfS; X.lo.edge:=lin;
	 end
      else
      begin InvS(T.hi,X.lo); InvS(T.lo,X.hi);
      end;
   end;{Inv}
   
   procedure divi(Ta,Tb:Int;var R:Int);
   var X:Int;
   begin
      if (Tb.lo.mantissa < 0) and (Tb.hi.mantissa > 0) then
         if (Ta.lo.mantissa < 0) and (Ta.hi.mantissa > 0) then
	 { need do nothing as R will be set to [inf,inf]}
	 else
	 
         begin
	    {if both same sign get positive side of inverse}
	    {else get negative}
	    Inv(Tb,X,(Ta.hi.mantissa <= 0) = (R.hi.mantissa <= 0));
	    mult(Ta,X,R);
	 end
      else {Tb wont give split inverse}
      begin
         Inv(Tb,X,true);
	 mult(Ta,X,R);
      end;
(*
DumpInt(Tb);writeln('//');DumpInt(X);writeln;
DumpInt(Ta);writeln('\\');DumpInt(R);writeln;
*)
   end;
   
   function Split(T:Int):boolean;
   begin
      Split:=(T.lo.mantissa<0) and (T.hi.mantissa>0) 
      	      and ((T.lo.cardinality=finite) or (T.hi.cardinality=finite));
   end;{Split}

   function Zin(T:Int):boolean;
   {check if 0 in range of interval}
   begin
      if (T.lo.mantissa > 0) then Zin:=false else
      if (T.lo.mantissa = 0) then
	 Zin:=(T.lo.edge=lin) else
      if (T.hi.mantissa < 0) then Zin:=false else
      if (T.hi.mantissa = 0) then
         Zin:=(T.hi.edge=hin) 
      else
         Zin:=true;
   end;{Zin}
   
begin{execmult}
   case Sr of
   0,10:begin
        if T2=Zero then
           if (T1=Zero) or (T0=Zero) then Sr:=-1
           else
	   if not Zin(T0) then begin R1:=Zero; Sr:=-1; end else
	   if not Zin(T1) then begin R0:=Zero; Sr:=-1; end 
	   else
           begin
              NewOuter(11); NewOuter(12);OK:=false;     
           end
        else if (Sr=0) then
        begin
	   if (T0.hi.mantissa > 0) and (T0.lo.mantissa < 0) and Split(T1) 
           then  begin NewOuter(1); NewOuter(2); OK:=false; end
           else if (T1.hi.mantissa > 0) and 
	           (T1.lo.mantissa < 0) and Split(T0) 
                then  begin NewOuter(3); NewOuter(4); OK:=false; end;
	end;
     end;
   1:begin R0.lo:=ZeroS; R0.lo.edge:=lin; T0:=R0; Sr:=10;
     end;
   2:begin R0.hi:=ZeroS; R0.hi.edge:=hout; T0:=R0; Sr:=10;
     end;
   3:begin R1.lo:=ZeroS; R1.lo.edge:=lin; T1:=R1; Sr:=10;
     end;
   4:begin R1.hi:=ZeroS; R1.hi.edge:=hout; T1:=R1; Sr:=10;
     end;
   11:begin R0:=Zero; Sr:=-1;
      end;
   12:begin R1:=Zero; Sr:=-1;
      end;
   end;
   
   if OK and (Sr<>-1) then
   begin
      mult(T0,T1,Q2); Inter(R2,Q2,R2);
      Q1:=R1; divi(T2,T0,Q1); Inter(R1,Q1,R1);
      Q0:=R0; divi(T2,T1,Q0); Inter(R0,Q0,R0);
      Sr:=10;
   end;
end;{execmult}

procedure execadd(T0,T1,T2:Int;var R0,R1,R2:Int);
  procedure addhi(S0,S1:Sreal; var S2:Sreal);
  var Closed:boolean;  Exp,M0,M1:integer;
  begin{addhi}
  with S2 do
  begin
     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
     begin  
        S2:=PlusInfS;
        Closed:=((S0.cardinality=infinite)and(S0.edge=hin))or
	        ((S1.cardinality=infinite)and(S1.edge=hin));
     end else
     begin
        Closed:=(S0.edge=hin)and(S1.edge=hin);
        AlignUp(S0.exp,S0.mantissa,S1.exp,S1.mantissa,Exp,M0,M1,Closed);
	NormalizeUp(Exp,M0+M1,S2,Closed)
     end;
     if Closed then S2.edge:=hin else S2.edge:=hout;
  end;
  end;{addhi}
  
  procedure addlo(S0,S1:Sreal; var S2:Sreal);
  var Closed:boolean;  Exp,M0,M1:integer;
  begin{addlo}
  with S2 do
  begin
     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
     begin  
        S2:=MinusInfS;
        Closed:=((S0.cardinality=infinite)and(S0.edge=lin))or
	        ((S1.cardinality=infinite)and(S1.edge=lin));
     end else
     begin
        Closed:=(S0.edge=lin)and(S1.edge=lin);
        AlignUp(S0.exp,-S0.mantissa,S1.exp,-S1.mantissa,Exp,M0,M1,Closed);
	NormalizeUp(Exp,M0+M1,S2,Closed); mantissa:=-mantissa;
     end;
     if Closed then S2.edge:=lin else S2.edge:=lout;
  end;
  end;{addlo}
  
  procedure subhi(S0,S1:Sreal; var S2:Sreal);
  var Closed:boolean;  Exp,M0,M1:integer;
  begin{subhi}
  with S2 do
  begin
     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
     begin  
        S2:=PlusInfS;
        Closed:=((S0.cardinality=infinite)and(S0.edge=hin))or
	        ((S1.cardinality=infinite)and(S1.edge=lin));
     end else
     begin
        Closed:=(S0.edge=hin)and(S1.edge=lin);
        AlignUp(S0.exp,S0.mantissa,S1.exp,-S1.mantissa,Exp,M0,M1,Closed);
	NormalizeUp(Exp,M0+M1,S2,Closed);
     end;
     if Closed then S2.edge:=hin else S2.edge:=hout;
  end;
  end;{subhi}
  
  procedure sublo(S0,S1:Sreal; var S2:Sreal);
  var Closed:boolean;  Exp,M0,M1:integer;
  begin{sublo}
  with S2 do
  begin
     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
     begin  
        S2:=MinusInfS;
        Closed:=((S0.cardinality=infinite)and(S0.edge=lin))or
	        ((S1.cardinality=infinite)and(S1.edge=hin));
     end else
     begin
        Closed:=(S0.edge=lin)and(S1.edge=hin);
        AlignUp(S0.exp,-S0.mantissa,S1.exp,S1.mantissa,Exp,M0,M1,Closed);
	NormalizeUp(Exp,M0+M1,S2,Closed);mantissa:=-mantissa;
     end;
     if Closed then S2.edge:=lin else S2.edge:=lout;
  end;
  end;{sublo}
  
begin{execadd}
   addhi(T0.hi,T1.hi,R2.hi);
   addlo(T0.lo,T1.lo,R2.lo);
   
   subhi(T2.hi,T0.lo,R1.hi);
   sublo(T2.lo,T0.hi,R1.lo);
   
   subhi(T2.hi,T1.lo,R0.hi);
   sublo(T2.lo,T1.hi,R0.lo);
end;{execadd}




procedure execintgr(var Sr:State; var R:Int);
      
  procedure floor (var R : Sreal);
  var sign , dum : boolean ;
      E, M ,t    : integer ;
  
  begin
     sign := false ;
     with R do
        begin
           if (mantissa < 0) then
              begin
                 sign := true ;
                 mantissa := - mantissa ;
              end ;
           if (exp <= 0) then
              begin
                 if sign or ((mantissa = 0) & (edge = hout)) then
                    begin
                       M := 1 ; 
                       sign := true ;
                    end 
                 else
                    M := 0 ;
                 E := Digits ;
                 NormalizeUp (E,M,R,dum) ;
                 edge := hin ;
              end 
        
           else {exp >0}
              if (exp <= Digits) then
                 begin
                    M := 1 ;
                    E := exp ;
                    while (E < Digits) do
                       begin
                          M := M * 10 ;
                          E := E + 1 ;
                       end ;
                    t := mantissa mod M ;
                    M := mantissa div M ;
                    if (sign & ((edge = hout) or(t > 0))) then
                       M := M + 1 ; 
                    if (not sign & (t = 0)) & (edge = hout) then
                       M := M - 1 ;
                    E := Digits ;
                    NormalizeUp (E,M,R,dum) ;
                    edge := hin ;
                 end 
              else
                 if ((edge = hout)&(exp = (Digits+1))) & (not sign & (mantissa = Splitman)) then
                    begin
                       mantissa := Maxman ;
                       exp := Digits ;
                       edge := hin ;
                    end ;
           if sign then
              mantissa := - mantissa ;
        end ;{with R}
  end ; {floor} 
  procedure ceiling (var R : Sreal);
  var sign , dum : boolean ;
      E, M , t   : integer ;
  
  begin
     sign := false ;
     with R do
        begin
           if (mantissa < 0) then
              begin
                 sign := true ;
                 mantissa := - mantissa ;
              end ;
           if (exp <= 0) then
              begin
                 if sign or ((mantissa = 0) & (edge = lin)) then
                    M := 0 
                 else
                    M := 1 ;
                 E := Digits ;
                 NormalizeDn (E,M,R,dum) ;
                 edge := lin ;
              end 
        
           else {exp > 0}
              if (exp <= Digits) then
                 begin
                    M := 1 ;
                    E := exp ;
                    while (E < Digits) do
                       begin
                          M := M * 10 ;
                          E := E + 1 ;
                       end ;
                    t := mantissa mod M ;
                    M := mantissa div M ;
                    if ( not sign & ((edge = lout) or(t > 0))) then
                       M := M + 1 ;
                    if (sign & (t = 0)) & (edge = lout) then
                       M := M - 1 ;
                    E := Digits ;
                    NormalizeDn (E,M,R,dum) ;
                    edge := lin ;
                 end 
              else
                 if ((edge = lout)&(exp = (Digits+1))) & (sign & (mantissa = Splitman)) then
                    begin
                       mantissa := Maxman ;
                       exp := Digits ;
                       edge := lin ;
                    end ;
           if sign then
              mantissa := - mantissa ;
        end ;{with R}
  end ; {ceiling} 
begin
   with R do
      begin
(*         writeln ('IN EXECINTGR :') ;
         writeln ;
         writeln ('HI : ', hi.mantissa , hi.exp) ;
         writeln ;
         writeln ('LO : ', lo.mantissa , lo.exp) ;
         writeln ;
*)
         if (hi.cardinality <> infinite) then
            floor (hi) ;
         if (lo.cardinality <> infinite) then
            ceiling (lo) ;
         if ((hi.mantissa = lo.mantissa) & (hi.exp = lo.exp)) then
            Sr := - 1 ;
(*         writeln ('OUT EXECINTGR :') ;
         writeln ;
         writeln ('HI : ', hi.mantissa , hi.exp) ;
         writeln ;
         writeln ('LO : ', lo.mantissa , lo.exp) ;
         writeln ;
*)
      end ;
end;{execintgr}













  procedure execlb (R1 : Int ; var R : Int) ;
  begin
     R := R1 ;
     with R.lo do
        if (cardinality = infinite) then
           R.hi := MinusFiniteS 
        else
           R.hi := R.lo ;
     R.hi.edge := hin ;
     R.lo := MinusInfS ;
  end ;

procedure execub (var X , Xd : Int) ;
var     Dum : Int ;     
  begin
     Xd := X ;
     execadd (Xd, Dum, Zero, Dum, Xd, Dum) ;
     execlb (Xd,Xd) ;
     execadd (Xd, Dum, Zero, Dum, Xd, Dum) ;
  end ;

procedure execcopy (R0 :Int; var R1:Int);
begin
  R1:=R0;
end;

procedure execless(var Sr:State; var R0,R1:Int);
{R0 < R1}
begin
   if Point(R0) or Point(R1) then Sr:=-1;
   if gtS(R1.lo,R0.hi) then Sr:= -1 else
   begin
      R0.hi:=R1.hi;
      R0.hi.edge:=hout;
      R1.lo:=R0.lo;
      R1.lo.edge:=lout;
   end;
end;{execless}

procedure execleq(var Sr:State; var R0,R1:Int);
{R0 =< R1}
begin
   if Point(R0) or Point(R1) then Sr:=-1;
   if geS(R1.lo,R0.hi) then Sr:= -1 else
   begin
      R0.hi:=R1.hi;
      R1.lo:=R0.lo;
   end;
end;{execleq}

procedure execnoteq(var Sr:State; var R0,R1:Int);
{R0 <> R1}
begin
   case Sr of
   0:{nothing done yet}
     begin
     if gtS(R0.lo,R1.hi) or gtS(R1.lo,R0.hi) 
     then Sr:=-1 {no need to check in future}
     else 
     begin
        if Point(R0) then 
	begin
	   OuterExec(PC,DCurr,true,1,Counter,Level+1);
	   Sr:=2;
	   execless(Sr,R1,R0);
	end else
	if Point(R1) then
	begin
	   OuterExec(PC,DCurr,true,2,Counter,Level+1);
	   Sr:=1;
	   execless(Sr,R0,R1);
	end;
     end;
     end;
   1:execless(Sr,R0,R1);
   2:execless(Sr,R1,R0);
   end;
end;{execnoteq}

procedure execsqrr(var R0,R1:Int);
begin{execsqrr}
end;{execsqrr}

procedure execminr(var R0,R1,R2:Int);
begin{execminr}
end;{execminr}

procedure execmaxr(var R0,R1,R2:Int);
  procedure chmaxhi(S0,S1:Sreal; var S2:Sreal);
  var Closed:boolean;  Exp,M0,M1:integer;
  begin{chmaxhi}
  with S2 do
  begin
     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
     begin  
        S2:=PlusInfS;
        Closed:=((S0.cardinality=infinite)and(S0.edge=hin))or
	        ((S1.cardinality=infinite)and(S1.edge=hin));
     end else
     begin
        Closed:=(S0.edge=hin)and(S1.edge=hin);
        AlignUp(S0.exp,S0.mantissa,S1.exp,S1.mantissa,Exp,M0,M1,Closed);
        if M1 > M0 then
           M0 := M1 ;
	NormalizeUp(Exp,M0,S2,Closed)
     end;
     if Closed then S2.edge:=hin else S2.edge:=hout;
  end;
  end;{chmaxhi}
  
  procedure chmaxlo(S0,S1:Sreal; var S2:Sreal);
  var Closed:boolean;  Exp,M0,M1:integer;
  begin{chmaxlo}
  with S2 do
  begin
     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
     begin  
        S2:=MinusInfS;
        Closed:=((S0.cardinality=infinite)and(S0.edge=lin))or
	        ((S1.cardinality=infinite)and(S1.edge=lin));
     end else
     begin
        Closed:=(S0.edge=lin)and(S1.edge=lin);
        AlignUp(S0.exp,-S0.mantissa,S1.exp,-S1.mantissa,Exp,M0,M1,Closed);
	NormalizeUp(Exp,M0+M1,S2,Closed); mantissa:=-mantissa;
     end;
     if Closed then S2.edge:=lin else S2.edge:=lout;
  end;
  end;{addlo}
begin{execmaxr}
end;{execmaxr}

procedure execmodu(var R0,R1,R2:Int);
begin{execmodu}
end;{execmodu}

procedure execabsr(var R0,R1:Int);
begin{execabsr}
end;{execabsr}

procedure exectrig(var R0,R1,R2:Int);
begin{exectrig}
end;{exectrig}

procedure execexpr(var R0,R1:Int);
begin{execexpr}
end;{execexpr}


function Exec(I:Instr;var PC:Loc0;var Change:boolean):boolean;
var
	R:array[0..Par] of Int;  {working registers}
	Sr:State;  {State register}
	P:0..Par;
	E:boolean;
	NewPC:Loc0;
	TraceChange:boolean;

   procedure WritePars; {write out list of parameter registers for curr ins}
   begin
   with I do
   begin
      write(PC:2,Code:5,Sr:3);
      for P := 0 to Par do
         if Pars[P] <> 0 then 
	 begin
	    write(Pars[P]:3);
	    WriteInt(R[P]);
	 end;
      writeln;
   end;
   end;{WritePars}

begin{Exec}
with I,DCurr do
begin
   Counter:=Counter+1;
   {get parameters}
   for P := 0 to ParN[Code] do 
   begin R[P]:=D[Pars[P]]; assert(CheckInt(R[P]));
   end;
   
   Sr:=S[PC];
   if Debug >= trace then  begin write(' '); WritePars; end;
   E:=true;
   Change:=false;
   NewPC:=PC;

{!!}case Code of 
   print: execprint(PC,Pars[0],R[0]);
   pr   : execpr(Sr,Pars[0]);
   tr   : exectr(Sr,Pars[0]);
   soln : execsoln(Sr,Pars[0]);
   readr: execreadr(Sr,R[0]);
   halve: exechalve(NewPC,Sr,R[0],E,Change);
   halves:exechalves(NewPC,Sr,R[0],E,Change);
   linh : execlinh(NewPC,Sr,R[0],E,Change);
   mult : execmult (Sr,R[0],R[1],R[2],R[0],R[1],R[2],E);
   add  : execadd  (R[0],R[1],R[2],R[0],R[1],R[2]);
   intgr: execintgr(Sr,R[0]);
   less : execless (Sr,R[0],R[1]);
   leq  : execleq  (Sr,R[0],R[1]);
   noteq: execnoteq(Sr,R[0],R[1]);
   sqrr : execsqrr(R[0],R[1]);
   minr : execminr(R[0],R[1],R[2]);
   maxr : execmaxr(R[0],R[1],R[2]);
   modu : execmodu(R[0],R[1],R[2]);
   absr : execabsr(R[0],R[1]);
   trig : exectrig(R[0],R[1],R[2]);
   expr : execexpr(R[0],R[1]);
   lb   : execlb (R[0],R[1]);
   ub   : execub (R[0],R[1]);
   copy : execcopy(R[0],R[1]);
   end;

   TraceChange:=false;
   AllPoints:=true;
   for P := 0 to ParN[Code] do
   with D[Pars[P]] do
   begin
      if DF.PF[Pars[P]]=PPrint then TraceChange:=true;
      assert(CheckLo(R[P].lo));assert(CheckHi(R[P].hi));
      if ParIntersect [Code] then
         begin
            maxS(R[P].lo,lo,R[P].lo);
            minS(R[P].hi,hi,R[P].hi);
         end ;
      if gtS(R[P].lo,R[P].hi) then 
      begin E:=false; assert(CheckLo(R[P].lo));assert(CheckHi(R[P].hi));
      end
      else begin
         if D[Pars[P]] <> R[P] then 
         begin 
	    D[Pars[P]] := R[P]; 
	    Change:=true;
	    if DF.PF[Pars[P]] = PTrace then TraceChange:=true;
         end;
         AllPoints:=AllPoints and Point(R[P]);
         assert(CheckInt(R[P])); assert(CheckInt(D[Pars[P]]));
      end;
   end;

   if (Debug=activity) and TraceChange then writeln;
   if (Debug >=activity) then 
   begin if Change then write('*') else write ('.');
   end;
   Exec:=E;
   if E then
   begin
      if AllPoints then Sr:=-1; 
      if (Sr <> S[PC]) then begin S[PC]:=Sr; Change:=true; end;
      if (Debug=activity) and TraceChange then WritePars;
      if Debug >= post then  WritePars;
      if Debug = dump then DumpMem(DCurr);
   end else 
   if Debug >= activity then 
   begin writeln('FAILED'); write(' '); WritePars; 
   end;
   PC:=NewPC;
end;
end;{Exec}

begin{OuterExec}
   writeln;
   writeln(Level:2,'Entering  Count:',OldCounter:0); OldCounter:=0;
   Counter:=0;
   Fail:=false;
   if First <> 0 then DCurr.S[PC]:=First;
   {Run simulation until failure or nothing further to be done}
   repeat
        if (PC = End) then 
   	begin PC:=1; Change:=false; DCurr.LastHalve:=1; end;
   	while (PC < End) and not Fail and not GlobalEnd do
   	with I[PC] do
   	begin
   	   if DCurr.S[PC] > -1 then
	   begin Fail:=not Exec(I[PC],PC,LocalChange); 
	      Change:=Change or LocalChange;
	   end;
   	   PC:=PC+1;
   	end;
   until Fail or (not Change) or GlobalEnd;
   writeln;
   write(Level:2,'Exiting  Count:',Counter:0);
   if not (Fail or GlobalEnd) then
   begin 
      if (Cut=once) then GlobalEnd:=true;
      writeln('SOLUTION');
      WriteMem(DCurr);
   end 
   else writeln;
end;{OuterExec}


procedure Clear;
var tL:Loc; 
    tD,tDF:Ptr; 
    tPar:1..Par; 
    DI:1..Digits;
    J:1..Maxexp;
    MaxDiff:real;
begin
   Shift[0]:=1;
   for DI:= 1 to Digits do Shift[DI]:=Shift[DI-1]*10;

   with PlusInfS do
   begin
      edge:=hin;cardinality:=infinite;mantissa:=Maxinf;
      exp:=Maxexp;
   end;
   with MinusInfS do
   begin
      edge:=lin;cardinality:=infinite;mantissa:=Mininf;
      exp:=Maxexp;
   end;
   with PlusFiniteS do
   begin
      edge:=hin;cardinality:=finite;mantissa:=Maxman;
      exp:=Maxexp;
   end;
   with MinusFiniteS do
   begin
      edge:=lin;cardinality:=finite;mantissa:=Minman;
      exp:=Maxexp;
   end;
   with ZeroS do
   begin exp:=0;mantissa:=0;edge:=hin;cardinality:=finite;
   end;
   with PlusSmallS do
   begin exp:=Minexp;mantissa:=Maxinf div 10; cardinality:=finite;
   end;
   with MinusSmallS do
   begin exp:=Minexp;mantissa:=Mininf div 10; cardinality:=finite;
   end;
   


   with Zero do
   begin lo:=ZeroS;lo.edge:=lin; hi:=ZeroS;hi.edge:=hin;
   end;
   with All do
   begin hi:=PlusInfS; lo:=MinusInfS;
   end;
   with AllFinite do
   begin lo:=MinusFiniteS; hi:=PlusFiniteS;
   end;

   with DF do
   begin
        for tDF:= 1 to DMem do PF[tDF]:=PNull;
   end;
  
   with DInit do
   begin
	for tD:= 1 to DMem do
	   if Verifiable then D[tD]:=AllFinite
	   		 else D[tD]:=All;
	LastHalve:=1;

	MaxDiff:=2;
	for J:=1 to Maxexp do MaxDiff:=MaxDiff*10;
	
	for tL := 1 to IMem do
	begin
	   RHalve[tL]:=MaxDiff;
	   S[tL]:=0;
	   with I[tL] do
	   for tPar := 1 to Par do
		Pars[tPar]:=0;
	end;

{!!}	ParN[print]:=0;
        ParN[pr]:=0;
        ParN[tr]:=0;
        ParN[soln]:=0;
	ParN[halve]:=0;
	ParN[halves]:=0;
	ParN[readr]:=0;
	ParN[linh]:=0;
	ParN[mult]:=2;
	ParN[add]:=2;
	ParN[intgr]:= 0;
	ParN[less]:= 1;
	ParN[leq]:= 1;
	ParN[noteq]:= 1;
	ParN[sqrr]:= 1;
	ParN[minr]:=2;
	ParN[maxr]:=2;
	ParN[modu]:= 1;
	ParN[absr]:= 1;
	ParN[trig]:=2;
	ParN[expr]:= 1;
        ParN[lb]:= 1;
        ParN[ub]:= 1; 
        ParN[copy]:= 1; 
	ParN[stop]:=-1;
{!!}	ParIntersect[print]:= true;
        ParIntersect[pr]:= true;
        ParIntersect[tr]:= true;
        ParIntersect[soln]:= true;
	ParIntersect[halve]:=true;
	ParIntersect[halves]:=true;
	ParIntersect[readr]:=true;
	ParIntersect[linh]:=true;
	ParIntersect[mult]:=true;
	ParIntersect[add]:=true;
	ParIntersect[intgr]:= true;
	ParIntersect[less]:= true;
	ParIntersect[leq]:= true;
	ParIntersect[noteq]:= true;
	ParIntersect[sqrr]:= true;
	ParIntersect[minr]:= true;
	ParIntersect[maxr]:= true;
	ParIntersect[modu]:= true;
	ParIntersect[absr]:= true;
	ParIntersect[trig]:= true;
	ParIntersect[expr]:= true;
        ParIntersect[lb]:= false;
        ParIntersect[ub]:= false;
	ParIntersect[stop]:= true;
	ParIntersect[copy]:= true;
   end;
end;{Clear}
	
procedure ReadInstr;
var
	tP:0..Par;
	Op:OpType;
	tDat:Ptr;
begin
   with DInit do
   begin
	End:=1;
	MaxDMem:=0;
	repeat
	   with I[End] do
	   begin
	      read(Op);
	      Code:=Op;
	      for tP := 0 to ParN[Op] do with I[End] do 
	      begin
	         read(tDat); Pars[tP]:=tDat;
		 if tDat>MaxDMem then MaxDMem:=tDat;
		 if MaxDMem > DMem then 
		 begin writeln('Too many variables');halt;
		 end;
	      end;
	      readln;
	   end;
	   End:=End+1; 
	   if End >= IMem then begin writeln('Too many instructions');halt;end;
	until Op = stop;
	End:=End-1;

	while not eof do {read constant values for memory locations}
	begin

   	   read(tDat);
	   if tDat > DMem then writeln('Variable out of range',tDat,DMem);
	   ReadInt(D[tDat]);
	   readln;
	end;
   end;
end;{ReadInstr}

begin
	GlobalEnd:=false;
	InitialOptions;
	readln(Cut);
	writeln(Cut);
	Clear;
	{ set to initial values, read instructions}
	ReadInstr;
	if Debug = dump then begin DumpTables; DumpMem(DInit); end;
	if Debug >= activity then WriteMem(DInit);
	Dummy:=0;
	OuterExec(1,DInit,false,0,Dummy,0);
	if Debug = dump then DumpMem(DInit);
end.
<head>
<title>Compression Pointers</title>
<META HTTP-EQUIV="Keywords" CONTENT="compression, compression, compression">
</head>
<body>
<BODY BGCOLOR=#FFFFFF>

<center>
<H1> Compression Pointers </h1>



</center>

<p>
<a href="#Resources">Compression resources</a>, <a href="#Conferences">conferences</a>, and some <a href="#Research">research
groups and companies</a>, are listed towards the end of this page. <p>

Use this <a href="form.html">handy form</a> to add something to this page, or to simply say you liked this page<i> <img src="new.gif">
<p>

</i>



<p>

<h2>What's New?</h2><p>


<a href="http://www.teaser.fr/~jlgailly/">Jean-loup Gailly</a> -- <i>Mr. gzip,
PNG, CCR (1996-06-10)</i>
<img src="new.gif">
<br>

<a href="http://www.creative.net/~tristan/MPEG">MPEG Pointers and Resources</a>
<img src="new.gif">
<br>

<a href="http://www-isl.stanford.edu/~gray/">Robert M. Gray</a> -- <i>Signal
compression, VQ, image quality evaluation (1996-04-22)</i><img src="new.gif">
<br>

<a href="http://www-isl.stanford.edu/~gray/compression.html">Compression and
Classification Group</a> -- <i>ISL,EE,Stanford (1996-04-22)</i><img src="new.gif">
<br>

<a href="http://www-isl.stanford.edu/~gray/iii.html">Signal Processing
and the International Information Infrastructure</a> -- <i>Web sites (1996-04-22)</i> <img src="new.gif">
<br>

<a href="http://www.cs.sc.edu:80/~valenta/">Valenta, Vladimir</a> -- <i>(1996-04-22)</i>
<br>


<a href="http://patpwww.epfl.ch:80/~jordan/Subjects/Parallel/parallel.html">Jordan, Frederic</a> -- <i>Parallel Image Compression (1996-04-12)</i> <img src="new.gif">
<br>
<a href="http://www.garlic.com/biz/eotek">Electro-Optical Technologies, Inc.</a> -- <i>Consultant (1996-04-12)</i> <img src="new.gif">
<br>
<a href="http://quicktime.apple.com">quicktime.apple.com</a> -- <i>Quicktime site (1996-03-11)</i> <img src="new.gif">
<br>
<a href="http://www.chips.ibm.com/products/aldc/index.html">IBM Hardware</a> -- <i>Compression chips (1996-03-11)</i> <img src="new.gif">
<br>






















<!---

<img src="new.gif"><i>Do you have, or know of, a research position where an image compression guru with a Ph.D. would feel at
home?  Let me know if you do...<a
href="mailto:singlis@cs.waikato.ac.nz"><b>send me some email!</b></a>, or <a
href="http://www.cs.waikato.ac.nz/~singlis/cv.html"><b>check out my
c.v.</b>
</a> 
</i>

-->

<p>


<p>


<h2><i>People</i></h2>
<h2>A</h2>

<a href="http://quest.jpl.nasa.gov/Mark.Adler/">Adler, Mark</a> -- <i>Info-ZIP; Zip, UnZip, gzip and zlib co-author; PNG group</i>
<p>

<h2>B</h2>

<a href="http://www.eese.qut.edu.au/~mbaker/">Baker, Matthew</a> -- <i>Region based video compression</i>
<p>
<a href="http://www.eecs.wsu.edu/~bamberg/">Bamberger, Roberto H.</a>
<p>
<a href="http://sutherland.eese.qut.edu.au/~dbell">Bell, Daniel</a> -- <i>Region based image compression</i>
<p>
<a href="http://www.cosc.canterbury.ac.nz/~tim">Bell, Tim</a> -- <i>compression, computer science for children, and computers and music.</i> 
<p>
<a href="http://www.polytechnique.fr/poly/~bellard/">Bellard, Fabrice</a> -- <i>Author of LZEXE</I>
<p>
<a href="http://www.cevis.uni-bremen.de/~willy/">Berghorn, Willy </a>
<p>
<a href="http://www.best.com/~bhaskara">Bhaskaran, Vasudev</a> -- <i>Image and Video compression</i> 
<p>
<a href="http://wwwvms.utexas.edu/~cbloom/index.html">Bloom, Charles</a> -- <i>text compression, LZ methods, PPM methods...</i>
<p>
<a href="http://www.ime.usp.br/~rbrito">Brito, Roger</a> -- <i>Arithmetic Coding, LZW, Text Compression</i>
<p>
<a href="http://www.engineering.usu.edu/ece/faculty/scottb.html">Budge, Scott E.</a> -- <i>medical/lossy image compression</i>
<p>
<a href="http://www.elec.uow.edu.au/people/staff/burnett/biography.html">Burnett, Ian</a> -- <i>Speech coding, prototype waveform techniques</I> <img src="new.gif">
<p>


<h2>C</h2>

<a href="http://gabor.eecs.berkeley.edu/~wychan/">Chan, Christopher</a> -- <i>universal lossy source coding, adaptive VQ</i>
<p>
<a href="http://www.compsci.com/~chao">Chao, Hong-yang</a> -- <I>Lightning strike image compressor </i> 
<p>
<a href="http://monet.uwaterloo.ca:80/schao/">Chao, Stewart</a>
<p>
<a href="http://diana.ecs.soton.ac.uk/~pjc94r/">Cherriman, Peter</a>
<p>
<a href="http://www-video.eecs.berkeley.edu/erl/sccheung.html">Cheung, S.C.</a> -- <i>Scalable video compression algorithms (18th Feb 1996)</i> <img src="new.gif">
<p>

<a href="http://etro.vub.ac.be/chchrist.html">Christopoulos, Charilaos</a> -- <i> Image and Video compression </i>
<p>
<a href="http://sipi.usc.edu/~chrysafi/">Chrysafis, Christos</a> 
<p>
<a href="http://www.ee.gatech.edu/research/DSP/students/wchung/index.html">Chung, Wilson C.</a> -- <i>R-D image and video coding, subband/wavelet, filter banks</i> 
<p>
<a href="mailto:aclark@hayes.com">Clark, Alan</a> -- <i>primary contact for V.42bis. Developed BTLZ variant of LZW</i>
<p>
<a href="http://www.cs.waikato.ac.nz/cs/Staff/jgc.html">Cleary, John</a> -- <i>PPM, PPM*, K*</i>
<p>
<a href="http://www.cs.brandeis.edu/dept/faculty/cohn/">Cohn, Martin</a>
<p>

<a href="http://plg.uwaterloo.ca/~gvcormac">Cormack, Gordon V.</a> -- <I>DMC</i>
<p>
<a href="http://www.ee.duke.edu/~cec/index.html">Cramer, Chris</a> -- <i>neural network image compression</i>
<p>

<h2>D</h2>
<a href="http://www.cs.dartmouth.edu/~jmd/">Danskin, John</a> -- <i>Protocol compression, document compression (9th Feb 1996)</i> 
<p>
<a href="http://www.cs.dartmouth.edu/~gdavis">Davis, Geoff</a> -- <i>wavelets, image compression, medical</i>
<p>
<a href="http://www-mddsp.enel.ucalgary.ca/People/adilger/">Dilger, Andreas</a> -- <i>fractal block coding of video sequences</i>
<p>


<h2>E</h2>
<a href="http://info.cipic.ucdavis.edu/~estes/index.html">Estes, Robert</a>
<p>



<h2>F</h2>
<a href="http://inls.ucsd.edu/y/Fractals/">Fisher, Yuval</a> -- <i>Fractal Image Compression</i>
<p>
<a href="http://www.wmin.ac.uk/~ajoec1/homepage.html">Ford, Adrian</a> -- <i>Subjective and Objective Compression quality (5th Mar 1996)</i> <img src="new.gif">
<p>

<h2>G</h2> 
<a href="http://www.teaser.fr/~jlgailly/">Jean-loup Gailly</a> --
<i>Mr. gzip, PNG, CCR (1996-06-10)</i>
<p>

<a href="http://www.ece.ucsb.edu/faculty/gersho/default.html">Gersho, Allen</a> -- <i>Vector Quantisation, Image Compression</i>
<p>
<a href="http://life.anu.edu.au/ci/vol1/goertzel.html">Goertzel, Ben</a>
<p>
<a href="http://info.lut.ac.uk/departments/el/research/sys/compression.html">Gooch, Mark</a> -- <i>High Performance Hardware Compression (7th Feb 1996)</i> 
<p>
<a href="http://robotics.eecs.berkeley.edu/~vkgoyal/">Goyal, Vivek</a> -- <i>overcomplete representations, adaptive transform coding, VQ</i>
<p> 
<a href="http://www-isl.stanford.edu/~gray/">Robert M. Gray</a> -- <i>Signal
compression, VQ, image quality evaluation</i><img src="new.gif">
<p>

<h2>H</h2>
<a href="http://cork.informatik.uni-wuerzburg.de/mitarbeiter/ulli">Hafner, Ullrich</a> -- <i>WFA image compression</i>
<p>
<a href="http://www.ics.uci.edu/~dan/">Hirschberg, Dan</a> -- <i>algorithm theory, compression</i> 
<p>
<a href="http://wolfpack.larc.nasa.gov/holland.html">Holland, Scott</a>
<p>
<a href="http://www.csc.uvic.ca/home/nigelh/nigelh.html">Horspool, R. Nigel</a> -- <i>text compression, ECG compression</i>

<h2>I</h2>
<a href="http://www.cs.waikato.ac.nz/~singlis">Inglis, Stuart</a> -- <i>image compression, OCR, lossy/lossless document compression</I>
<p>

<h2>J</h2>
<a href="http://www.cs.uiowa.edu/~jones/compress/index.html">Jones, Douglas</a> -- <i>splay-tree based compression and encryption</i>
<p>
<a href="http://info.lut.ac.uk/departments/el/research/sys/compression.html">Jones, Simon</a> -- <i>Lossless compression, High Performance Hardware (7th Feb 1996) </i> 
<p>
<a href="http://patpwww.epfl.ch:80/~jordan/Subjects/Parallel/parallel.html">Jordan, Frederic</a> -- <i>Parallel Image Compression (12th April 1996)</i> <img src="new.gif">
<p>
<a href="mailto:robjung@world.std.com">Jung, Robert K.</a> -- <i><a href="http://www.info.fundp.ac.be/~fta/arj.html">ARJ</a> </i>
<p>
<a href="http://www.cs.tu-berlin.de/~jutta/toast.html">jutta</a>
<p>



<h2>K</h2>
<a href="http://links.uwaterloo.ca">Kominek, John</a> -- <I>Fractal and spline based compression</i>
<p>
<a href="http://info.lut.ac.uk/departments/el/research/sys/elmk3.html">Kjelso, Morten</a> -- <i>Main memory compression, High performance hardware</i> 
<p>
<a href="http://wwwcip.informatik.uni-erlangen.de/user/mskuhn">Kuhn, Markus</a> -- <i>JBIG implementation</i> <img src="new.gif">
<p>
<a href="http://sipi.usc.edu/faculty/Kuo.html">Kuo, C.-C. Jay</a>
<p>
<a href="http://kaarna.cc.jyu.fi:80/~kuru/">Kuru, Esa</a>
<p>
<a href="http://www.prz.tu-berlin.de:80/~teo/">Kyfonidis, Theodoros</a>
<p>

<h2>L</h2>
<a href="http://www.icsi.berkeley.edu/~lampart/">Lamparter, Bernd</a>
<p>
<a href="http://www.cse.ucsc.edu/cgi-bin/faculty?langdon">Langdon, Glen</a>
<p>
<a href="http://www.dna.lth.se/~jesper/">Larsson, Jesper</a> -- <i>algorithms and data structures, text compression</i> <img src="new.gif">
<p>


<h2>M</h2>
<a href="http://glimpse.cs.arizona.edu:1994/udi.html">Manber, Udi</a>
<p>
<a href="http://www.elec.rma.ac.be/~jma/compression.html">Mangen, Jean-Michel</a> -- <i>image compression, wavelets, satellite</I>
<p>
<a href="http://www.cs.mu.oz.au/~alistair">Moffat, Alistair</a> -- <i>text and index compression, coding methods, information retrieval, document databases</i>
<p>
<a href="http://deskfish.cs.titech.ac.jp/squish/squish_index.html">Montgomery, Christopher</a> -- <i>OggSquish, audio compression</i>
<p>
<a href="mailto:umueller@amiga.physik.unizh.ch">Mueller, Urban Dominik</a> -- <i>XPK system</I>
<p>
<h2>N</h2>
<a href="ftp://ai.toronto.edu/pub/radford/www/index.html">Neal, Radford</a>
<p>
<a href="http://www.cs.waikato.ac.nz/~cgn">Nevill-Manning, Craig</a>
<p>
<a href="http://phoenix.bath.ac.uk/jez/jez.html">Nicholls, Jeremy</a>
<p>
<a href="http://www.acti.com/matt/">Noah, Matt</a> -- <i>speech, ATC, ACELP and IMBE</i>
<p>
<a href="http://www.eecs.wsu.edu/~vnuri/">Nuri, Veyis</a> -- <i>wavelets, data compression, DSP (speech & image)</I>

<h2>O</h2>
<a href="ftp://replicant.csci.unt.edu/pub/oleg/README.html">Oleg</a> -- <i>Lots of code</i>
<p>
<a href="http://sipi.usc.edu/faculty/Ortega/Ortega.html">Ortega, Antonio</a> -- <i>Video compression, Packet video, Adaptive quantization</i>
<p>
<a href="http://www.cs.dartmouth.edu:80/~cowen/">Owen, Charles</a>
<p>

<h2>P</h2>
<a
href="http://www-mddsp.enel.ucalgary.ca/People/provine/compression.html">Provine,
Joseph</a> -- <i>Model based coding</i>
<p>

<h2>R</h2>
<a href="http://monet.uwaterloo.ca/~john/btpc.html">Robinson, John</a> -- <i>Binary Tree Predictive Coding</i>
<p>
<a href="http://quest.jpl.nasa.gov/Info-ZIP/people/greg/">Roelofs, Greg</a> -- <i>Info-ZIP; primary UnZip author; PNG group</i>
<p>
<a href="http://www.ece.ucsb.edu/faculty/rose/default.html">Rose, Kenneth</a>
<p>
<a href="http://www.nettuno.it/fiera/telvox/telvox.htm">Russo, Roberto Maria</a> -- <I>Multiplatform Data Compression</i>
<p>

<h2>S</h2>
<a href="http://harc.edu:80/~schmidt/">Schmidt, Bill</a>
<p>
<a href="http://koa.ifa.hawaii.edu/~shaw/shaw.html">Shaw, Sandy C.</a>
<p>
<a href="http://www.comm.toronto.edu/~kamran/kamran.html">Sharifi, Kamran</a> -- <i>Video over ATM networks</i>
<p>
<a href="http://calypso.unl.edu/~sunil/">Shende, Sunil M.</a>
<p>
<a href="http://viewprint2.berkeley.edu/KleinLab/Amnon/Amnon.html">Silverstein, D. Amnon</a>
<p>
<a href="http://www-plateau.cs.berkeley.edu/people/smoot">Smoot, Steve</a> -- <i>MPEG</i>
<p>
<a href="http://www.cs.brandeis.edu/dept/faculty/storer/">Storer, James A.</a>
<p>
<a href="http://rice.ecs.soton.ac.uk/index.html">Streit, Jurgen</a> -- <i>Low bitrate coding</i>
<p>
<a href="http://www_nt.e-technik.uni-rostock.de/~ts/index.html">Strutz, Tilo</a> -- <i>Wavelet image compressor, demonstration execs</i> <img src="new.gif">
<p>


<h2>T</h2>
<a href="http://zaphod.csci.unt.edu:80/~srt/">Tate, Steve</a>
<p>
<a href="http://www.cs.waikato.ac.nz/~wjt">Teahan, Bill</a> -- <i>PPM, PPM*, master of the Calgary Corpus</i>
<p>
<a href="http://lightning.eee.strath.ac.uk/~duncan/">Thomson, Duncan</a> -- <i>ECG compression with ANNs</i>
<p>
<a href="http://outside.gsfc.nasa.gov/GRSS/">Tilton, James C.</a>
<p>
<a href="http://www.uni-karlsruhe.de/~un55/">Tomczyk, Marek</a>
<p>
<a href="http://munkora.cs.mu.oz.au/~aht">Turpin, Andrew</a> -- <i>Prefix Codes</i> 
<p>

<h2>V</h2>
<a href="http://gabor.eecs.berkeley.edu/~martin/">Vetterli, Martin</a> -- <i>wavelets, subband coding, video compression, computational complexity</i>
<p>
<a href="http://www.cs.duke.edu/~jsv/HomePage.html">Vitter, Jeff</a>
<p>
<a href="http://www.eee.strath.ac.uk/~stathis/home.html">Voukelatos, Stathis</a>
<p>
<a href="http://www.xs4all.nl/~aipnl">de Vries, Nico</a> -- <i>AIP-NL, UltraCompressor II development</i> <img src="new.gif">
<p>

<h2>W</h2>

<a href="http://ipcl.ee.queensu.ca/wareham/wareham.html">Wareham, Paul</a> -- <i>Region-oriented video coding</I>
<p>
<a href="mailto://Wegs59@aol.com">Wegener, Al</a> -- <i>DSP, lossless audio compression and AC-2</i> 
<p>
<a href="http://www-dsp.rice.edu:80/~weid/">Wei, Dong</a> -- <i>Wavelet compression</i>
<p>
<a href="http://www.rocksoft.com/~ross">Williams, Ross</a>
<p>
<a href="http://www.cs.waikato.ac.nz/~ihw">Witten, Ian</a> -- <i>PPM, mg, arithmetic coding</i>
<p>
<a href="http://www.sees.bangor.ac.uk/~gerry/sp_summary.html">Wolff, Gerry</a>
<p>
<a href="http://sipi.usc.edu/~wwoo/">Woo, Woon-Tack</a> -- <i>stereo image and video compression (12th Feb 1996)</i>
<p>
<a href="http://www.csd.uwo.ca/faculty/wu/">Wu, Xiaolin</a> -- <i>CALIC</i>
<P>


<h2>Z</h2>
<a href="http://www.cs.rmit.edu.au/~jz">Zobel, Justin</a> -- <i>index compression, database compression</i>
<p>

<br>
<br>


<a name="Conferences">

<h2><i>Conferences</i></h2>
<a href="http://www.cs.brandeis.edu:80/~dcc/index.html"><b>Data Compression Conference (DCC), Snowbird, Utah, USA.</b></a><br>
<p>

<a name="Resources">

<h2><i>Resources</i></h2>
<dt>
<i><b>Where to get answers...</b></i>
<dd>
<dd><a href="http://info.itu.ch/">International Telecommunication Union (ITU)</a> -- <i>standards documents (CCITT)</i>
<br>
<dd><a href="http://www.cis.ohio-state.edu/hypertext/faq/usenet/compression-faq/top.html">comp.compression -- Frequently Asked Questions</a> -- <i>Come here 1st!</i>
<dd>
<a href="http://www.cis.ohio-state.edu/hypertext/faq/usenet/jpeg-faq/faq.html">JPEG - Frequently Asked Questions</a>
<dd>
<a href="http://www.crs4.it/HTML/LUIGI/MPEG/mpegfaq.html">MPEG - Frequently Asked Questions</a>
<dd>
<a href="ftp://rtfm.mit.edu:/pub/usenet/news.answers/standards-faq">Standards - Frequenty Asked Questions</a>
<dd>
<a href="news:comp.compression.research">usenet newsgroup: comp.compression.research</a>
<br>
<dd>
<a href="http://www.mi.net/act/act.html">Archive Compression Test</a> -- <i>Summary of all archivers</i> 
<br>
<dd>
<a href="http://dip1.ee.uct.ac.za/fractal.bib.html">Fractal compression bibliography</a> -- <i>bibtex file</i>
<br>
<dd>
<a href="http://goethe.ira.uka.de/edu/proseminar.html">LZ/Complexity Seminars</a> -- <i>(in German)</i>
<br>
<dd>
<a href="http://www.cs.waikato.ac.nz/~singlis/ratios.html">Comparitive Compression Ratios</a> -- <i>Sofar...B&W, Gray Scale, Text Compression</i>
<br>
<dd>
<a href="http://www.cs.ucl.ac.uk/mice/mpeggloss.html">VCN (Video, Compression, Networking)
Glossary</a>
<br>
<dd>
<a href="http://www.cs.waikato.ac.nz/~nzdl/">Digital Library -- search for compression</a>
<br>
</dt>

<br>
<dt>
<i><b>Reports/Ph.D. Theses</b></i>
<dd>
<a href="http://www.cs.brown.edu/publications/techreports/reports/CS-93-28.html">Paul Howards Ph.D. thesis</a><br>
<dd><i>The Design and Analysis of Efficient Lossless Data Compression Systems</i>
<br>
</dt>



<br>
<dt>
<i><b>Source code</b></i>
<dd>
<a href="ftp://munnari.oz.au/pub/arith_coder">Arithmetic coding routines</a> 
<dd><i>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp(from Moffat, Neal and Witten, Proc. DCC, April 1995)</i>
<br>
<dd>
<a href="ftp://ftp.cpsc.ucalgary.ca/pub/projects/ar.cod">CACM Arithmetic coding package</a>
<dd><i>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp(Witten, Neal and Cleary, CACM 30:520-541, June 1987)</i>
<br>
<dd>
<a href="ftp://nic.funet.fi/pub/graphics/misc/test-images/jbig.tar.gz">JBIG Source code</a> <i>Includes a Q-coder</i>
<br>
<dd><a href="http://wwwcip.informatik.uni-erlangen.de/user/mskuhn">Markus Kuhn's JBIG implementation</a> 
<br>
<dd>
<a href="ftp://media-lab.media.mit.edu/pub/k-arith-code/">k-arithmetic coder</a>
<br>
<dd>
<a href="ftp://garbo.uwasa.fi/pc/programming/lds_11.zip">Lossless Data Compression toolkit 1.1</a>
<br>
<dd>
<a href="http://www.cs.uiowa.edu/~jones/compress/index.html">Splay Trees Code</a> -- <i>by Douglas W. Jones</i>
<br>
<dd><a href="ftp://ftp.cl.cam.ac.uk/users/djw3">Block compression code</a> -- <i>Excellent text compressor</i>
<br>

</dt>

<br>
<dt>
<i><b>Test Files</b></i>
<dd>
<a href="ftp://nic.funet.fi/pub/graphics/misc/test-images/">Test Images</a> -- <i>CCITT images (pbm), Lena etc. (Sun raster)</i>
<br>
<dd>
Stockholm test images -- <i>You have to buy a CDROM, thats all I know! :-(</i>
<dd>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mail me at <a href="mailto:singlis@cs.waikato.ac.nz">singlis@cs.waikato.ac.nz</a> if you know anything about them.
<br>
<dd>
<a href="ftp://ftp.cpsc.ucalgary.ca/pub/projects/text.compression.corpus/">Calgary Text Compression Corpus</a><i> (Text Compression, Bell, Cleary and Witten, 1990)</i>
<br>
</dt>

<br>

<a name="Research">


<h2><i>Research Projects, Standards & Companies</i></h2>

<p>
<dt>
<i><b>Research/Free software Groups</b></i>
<dd><a href="http://www-isl.stanford.edu/~gray/compression.html">Compression and
Classification Group</a> -- <i>ISL,EE,Stanford (22th April 1996)</i><img src="new.gif">

<dd><a href="http://www.bonzi.com">Voice email</a> -- <i>Lossless audio compression (18th Feb 1996)</i> 


<dd><a href="http://www.garlic.com/biz/eotek">Electro-Optical Technologies, Inc.</a> -- <i>Consultant (12th April 1996)</i> <img src="new.gif">

<dd><a href="http://quicktime.apple.com">quicktime.apple.com</a> -- <i>Quicktime site (11th Mar 1996)</i>

<dd><a href="http://www.atinternet.fr/image/">IMAGE etc.</a> -- <i>Commercial image compression software (Fractals/Wavelets) (29th Feb 1996)</i> <img src="new.gif">

<dd><a href="http://re7alpha.epm.ornl.gov/CcmDemo/">NCAR CCM Compression and Visualisation</a> -- <i>(18th Feb 1996)</i> <img src="new.gif">
<br>
<dd><a href="http://ipl.rpi.edu/SPIHT/">SPIHT</a> -- <I>Wavelet Natural Image Compressor (12th Feb 1996)</i> <img src="new.gif">
<br>
<dd><a href="http://info.lut.ac.uk/departments/el/research/sys/compression.html">Real-Time Lossless Compression Systems</a> -- <i>Loughborough University</i> <img src="new.gif">
<br>
<dd><a href="http://saigon.ece.wisc.edu/~waveweb/QMF.html">Web site for Multirate Signal Processing</a> -- <i>University of Wisconsin, Madison</i>
<br>
<dd><a href="http://quest.jpl.nasa.gov/Info-ZIP/">Info-ZIP</a> -- <i>free,
portable Zip and UnZip utilities</i>
<br>
<dd><a href="http://cesdis.gsfc.nasa.gov/">CEDIS</a> -- <i>NASA, Maryland, Image/data compression</i>
<br>
<dd><a href="http://www.c3.lanl.gov/~brislawn/ftp.html">CIC-3 Image Compression</a> -- <i>FBI Fingerprints</i>
<br>
<dd><a href="http://rainbow.ece.ucsb.edu/scl.html">Signal Compression Lab at UCSB</a>
<br>
<dd><a href="http://isdl.ee.washington.edu/COMPRESSION/homepage.html">University of
Washington compression lab</a> -- <I>VQ, Wavelets, Shlomo</i>
<br>
</dt>


<p>
<dt>
<i><b>Snippets</b></i>
<dd><a href="http://www-isl.stanford.edu/~gray/iii.html">Signal Processing
and the International Information Infrastructure</a> -- <i>Web sites (22th April 1996)</i> <img src="new.gif">
<dd><a href="http://www.scu.edu.au/ausweb95/papers/management/vanzyl/">Increasing Web bandwith</a> -- <i>comparing GIF, JPEG, Fractal compression</i>
<br>
<dd><a href="http://www.yahoo.com/Art/Computer_Generated/Fractals">Fractal Links on Yahoo</a>
<br>
<dd><a href="http://www.ddj.com/old/ddjw001d.htm">Digital Speech Compression GSM 06.10 RPE-LTP</a> -- <i>DDJ</i>
<br>
<dd><a href="http://www.crc.ricoh.com/CREW/">CREW</a> -- <i>Continuous tone loss(y/less) wavelet compression</i>
<br>
<dd><a href="ftp://ftp.csd.uwo.ca/pub/from_wu/">CALIC -- Context-based adaptive lossless image compressor</a>
<br>
<dd><a href="http://www-plateau.cs.berkeley.edu/mpeg/index.html">Berkeley MPEG</a> -- <i>MPEG tools</i>
<br>
<dd><a href="http://www.creative.net/~tristan/MPEG">MPEG Pointers and Resources</a>
<BR>
</dt>





<p>
<dt>
<i><b>Wavelets</b></i>
<dd>
<a href="http://www.cis.upenn.edu/~eero/epic.html">
     EPIC (Efficient Pyramid Image Coder)</a> -- <i>by Eero Simoncelli</i>
<br>
<dd>
<a href="mailto://72234.2617@compuserve.com">Tucker, Michael</a> -- <i>FASTWAVE, audio/image compression</i>
<br>
<dd>
<a href="http://www.harc.edu">HARC</a> -- <i>Lossy Wavelet Compression technology</i>
<br>
<dd>
<a href="http://gabor.eecs.berkeley.edu/">UC Berkeley Wavelet Group</a>
<br>
<dd>
<a href="http://www.c3.lanl.gov/~cjhamil/Wavelets/main.html">Khoros Wavetlet and Compression Toolbox</a>
<br>
<dd>
<a href="http://arabigo.math.scarolina.edu:80/~wavelet/">The Wavelet Digest</a>
<br>
<dd>
<a href="http://jazz.rice.edu/publications.html">Rice DSP Publications Archive</a> -- <i>Wavelets, Time Frequency/Scale</i>
<br>
</dt>

<p>
<dt>
<i><b>Fractals</b></i>
<dd>
<a href="http://inls.ucsd.edu/y/Fractals/">Fractal Image Compression</a> -- <i>Software, Pointers, Conferences</i>
<br>
<dd>
<a href="http://www.fractal.com/">Fractal Design Corporation</a>
<br>
<dd>
<a href="http://www.webcom.com/~verrando/university/ifs.html">New Fractal Image Compression program</a>
<br>
</dt>

<p>
<dt>
<i><b>Companies</b></i>
<dd><a href="http://www.chips.ibm.com/products/aldc/index.html">IBM Hardware</a> -- <i>Compression chips (11th Mar 1996)</i> <img src="new.gif">

<dd><a href="http://www.summus.com">Summus Wavelet Technology</a> -- <i>Wavelet image and video compressors (11th Mar 1996)</i> <img src="new.gif">
<dd><a href="http://www.mitsubishi.co.jp/jp/fractal/fractal.html">Fractal Image Compression</a> -- <I>Mitsubishi (18th Feb 1996)</i> <img src="new.gif">

<dd><a href="http://www.terran-int.com/">Terran Interactive</a> -- <i>Video compression for the Mac (1st Feb 1996)</i> <img src="new.gif">
<br>

<dd><a href="http://darvision.kaist.ac.kr/dvmpeg.html">DV Mpeg</a> -- <i>Windows drivers (18th Feb 1996)</I> <img src="new.gif">
<br>

<dd><a href="http://www.crawford.com/cs/welcome.html">Crawford Compression Services</a> -- <i>MPEG post-production (18th Feb 1996)</i> <img src="new.gif">
<br>

<dd><a href="http://www.shore.net/~ict">Intelligent Compression Technologies</a> <i>(18th Feb 1996)</i> <img src="new.gif">
<br>

<dd><a href="http://www.jpg.com">Pegasus Imaging</a> -- <i>Compression software/dev. kits (12th Feb 1996)</i> <img src="new.gif">
<br>
<dd><a href="http://www.aladdinsys.com/">Aladdin Systems</a> -- <i>StuffIt compression products</i>
<br>
<dd><a href="http://www.stac.com/">Stac Electronics</a> 
<br>
<dd><a href="http://www.ccinet.ab.ca/dcp.html">DCP Research</a> -- <i>Hardware solutions</i>
<br>
<dd><a href="http://www.aware.com/product_info/compression_overview.html">Aware Inc.</a> -- <i>Specialised compression company</i>
<br>
<dd><a href="http://www.inria.fr/rodeo/ivs.html">IVS - INRIA Videoconferencing System</a>
<br>
<dd><a href="http://sp25.ianus.cineca.it/telvox/telvoxen.htm">Telvox Teleinformatica</a> -- <i>Multiplatform Data Compressor</i>
<br>
<dd><a href="http://www.compression.com">Compression Technologies,
Inc</a> -- <i>Canada</i>
<br>
<dd><a href="http://www.optivision.com/">Optivision</a> -- <i>MPEG</i>
<br>
<dd><a href="http://www.pkware.com/">PKWARE</a> -- <i>Makers of PKZIP</i>
<br>
<dd><a href="http://www.infoanalytic.com/tayson/index.html">Multimedia Imaging Services</a>
<br>
</dt>

<p>
<dt>
<i><b>Audio compression</b></i>
<dd><a href="http://www.iis.fhg.de/departs/amm/index.html"> Fraunhofer Institut fr Integrierte Schaltungen</a> 
<br>
<dd><a href="http://svr-www.eng.cam.ac.uk/~ajr/speechCoding.html">Shorten</a>
<br>
<dd><a href="http://www.ddj.com/old/ddjw001d.htm">digital speech compression</a> 
<br>
<dd><a href="http://www.cs.tu-berlin.de/~phade/audiowww.html">Audio compression references</a> 
<br>
<dd><a href="http://www.fourmilab.ch/speakfree/windows/doc/compress.html">SpeakFreely - compression</a> 
<br>
<dd><a href="http://www.fourmilab.ch/speakfree/windows/speak_freely.html#contents">SpeakFreely - Contents</a> 
<br>
OBJECT=VARBTEMP0
VARBTEMP0:TYPE=BOOL

OBJECT=VARBTEMP0INSIDE
VARBTEMP0INSIDE:TYPE=BOOL

OBJECT=VARBTEMP1
VARBTEMP1:TYPE=BOOL

OBJECT=VARBTEMP1INSIDE
VARBTEMP1INSIDE:TYPE=BOOL

OBJECT=VARB_INVLOCK
VARB_INVLOCK:TYPE=BOOL
VARB_INVLOCK:VALUE=FALSE

OBJECT=VARB_KRETACTIVE
VARB_KRETACTIVE:TYPE=BOOL

OBJECT=VARB_KRETLOCK
VARB_KRETLOCK:TYPE=BOOL

OBJECT=VARB_KRETMOVE
VARB_KRETMOVE:TYPE=BOOL

OBJECT=VARB_KRETSHOW
VARB_KRETSHOW:TYPE=BOOL
VARB_KRETSHOW:VALUE=TRUE

OBJECT=VARB_LOCKMOVE
VARB_LOCKMOVE:TYPE=BOOL

OBJECT=VARB_REXLOCK
VARB_REXLOCK:TYPE=BOOL

OBJECT=VARB_REXMOVE
VARB_REXMOVE:TYPE=BOOL

OBJECT=VARB_REXSHOW
VARB_REXSHOW:TYPE=BOOL
VARB_REXSHOW:VALUE=TRUE

OBJECT=VARB_SCENEBKGDONTSCROLL
VARB_SCENEBKGDONTSCROLL:TYPE=BOOL
VARB_SCENEBKGDONTSCROLL:VALUE=FALSE

OBJECT=VARB_SCENEFIRSTENTER
VARB_SCENEFIRSTENTER:TYPE=BOOL

OBJECT=VARB_SCENELOCK
VARB_SCENELOCK:TYPE=BOOL
VARB_SCENELOCK:VALUE=FALSE

OBJECT=VARB_SEQARRLOCKTALK
VARB_SEQARRLOCKTALK:TYPE=BOOL

OBJECT=VARB_SEQARRPLAYING
VARB_SEQARRPLAYING:TYPE=BOOL
VARB_SEQARRPLAYING:VALUE=FALSE

OBJECT=VARB_SEQARRSTOPABLE
VARB_SEQARRSTOPABLE:TYPE=BOOL
VARB_SEQARRSTOPABLE:VALUE=TRUE

OBJECT=VARB_TELEPORTRUN
VARB_TELEPORTRUN:TYPE=BOOL
VARB_TELEPORTRUN:VALUE=FALSE

OBJECT=VARB_USEWASUSED
VARB_USEWASUSED:TYPE=BOOL

OBJECT=VARDTEMP0
VARDTEMP0:TYPE=DOUBLE

OBJECT=VARDTEMP0INSIDE
VARDTEMP0INSIDE:TYPE=DOUBLE

OBJECT=VARDTEMP1
VARDTEMP1:TYPE=DOUBLE

OBJECT=VARDTEMP1INSIDE
VARDTEMP1INSIDE:TYPE=DOUBLE

OBJECT=VARDTEMP2
VARDTEMP2:TYPE=DOUBLE

OBJECT=VARDTEMP2INSIDE
VARDTEMP2INSIDE:TYPE=DOUBLE

OBJECT=VARD_3DELAPSED
VARD_3DELAPSED:TYPE=DOUBLE

OBJECT=VARD_INVMENUANGLE
VARD_INVMENUANGLE:TYPE=DOUBLE
VARD_INVMENUANGLE:VALUE=36

OBJECT=VARD_INVMENUOPACITY
VARD_INVMENUOPACITY:TYPE=DOUBLE

OBJECT=VARD_KRETSPEED
VARD_KRETSPEED:TYPE=DOUBLE

OBJECT=VARD_REXSPEED
VARD_REXSPEED:TYPE=DOUBLE

OBJECT=VARD_TEMPANGLE
VARD_TEMPANGLE:TYPE=DOUBLE

OBJECT=VARICUTSCENEEXIT
VARICUTSCENEEXIT:TYPE=INTEGER
VARICUTSCENEEXIT:ONBRUTALCHANGED^1={BEHCUTFINISHED^RUN();}

OBJECT=VARITEMP0
VARITEMP0:TYPE=INTEGER

OBJECT=VARITEMP0INSIDE
VARITEMP0INSIDE:TYPE=INTEGER

OBJECT=VARITEMP1
VARITEMP1:TYPE=INTEGER

OBJECT=VARITEMP1INSIDE
VARITEMP1INSIDE:TYPE=INTEGER

OBJECT=VARITEMP2
VARITEMP2:TYPE=INTEGER

OBJECT=VARITEMP2INSIDE
VARITEMP2INSIDE:TYPE=INTEGER

OBJECT=VARITEMP3
VARITEMP3:TYPE=INTEGER

OBJECT=VARITEMP3INSIDE
VARITEMP3INSIDE:TYPE=INTEGER

OBJECT=VARI_3DPATHID
VARI_3DPATHID:TYPE=INTEGER
VARI_3DPATHID:VALUE=9000

OBJECT=VARI_ANIMFINISH
VARI_ANIMFINISH:TYPE=INTEGER
VARI_ANIMFINISH:ONBRUTALCHANGED={VARSTEMP0INSIDE^SET(["ANNOBJECT"+VARI_ANIMFINISH]);VARSTEMP1INSIDE^SET(*VARSTEMP0INSIDE^GETEVENTNAME());@IF("VARSTEMP1INSIDE","!_",""PLAY"","BFITMP1","");}

OBJECT=VARI_BKGX
VARI_BKGX:TYPE=INTEGER

OBJECT=VARI_BKGXLAST
VARI_BKGXLAST:TYPE=INTEGER

OBJECT=VARI_BKGXOFFSET
VARI_BKGXOFFSET:TYPE=INTEGER

OBJECT=VARI_BKGY
VARI_BKGY:TYPE=INTEGER

OBJECT=VARI_BKGYLAST
VARI_BKGYLAST:TYPE=INTEGER

OBJECT=VARI_BKGYOFFSET
VARI_BKGYOFFSET:TYPE=INTEGER

OBJECT=VARI_CLICKPOSX
VARI_CLICKPOSX:TYPE=INTEGER

OBJECT=VARI_CLICKPOSY
VARI_CLICKPOSY:TYPE=INTEGER

OBJECT=VARI_INVMAINRADIUS
VARI_INVMAINRADIUS:TYPE=INTEGER

OBJECT=VARI_INVMENUVISIBLE
VARI_INVMENUVISIBLE:TYPE=INTEGER
VARI_INVMENUVISIBLE:VALUE=-1

OBJECT=VARI_INVMENUX
VARI_INVMENUX:TYPE=INTEGER

OBJECT=VARI_INVMENUY
VARI_INVMENUY:TYPE=INTEGER

OBJECT=VARI_INVENTORYCOUNT
VARI_INVENTORYCOUNT:TYPE=INTEGER

OBJECT=VARI_KRETDIRTOGADA
VARI_KRETDIRTOGADA:TYPE=INTEGER

OBJECT=VARI_KRETDISTANCEX
VARI_KRETDISTANCEX:TYPE=INTEGER

OBJECT=VARI_KRETDISTANCEY
VARI_KRETDISTANCEY:TYPE=INTEGER

OBJECT=VARI_NEXTTRIGGER
VARI_NEXTTRIGGER:TYPE=INTEGER
VARI_NEXTTRIGGER:VALUE=-1

OBJECT=VARI_NEXTTRIGGERKRET
VARI_NEXTTRIGGERKRET:TYPE=INTEGER
VARI_NEXTTRIGGERKRET:VALUE=-1

OBJECT=VARI_NEXTTRIGGERTYPEKRETSELECTOR
VARI_NEXTTRIGGERTYPEKRETSELECTOR:TYPE=INTEGER
VARI_NEXTTRIGGERTYPEKRETSELECTOR:VALUE=0
VARI_NEXTTRIGGERTYPEKRETSELECTOR:ONBRUTALCHANGED^1={BEHCLICKKRET^RUN();*["BEHCLICKKRET_"+SOBJECT|IDNAME]^RUN();@IF("VARS_GOALREX","_","SOBJECT|IDNAME","BFITMP2","BFITMP3");}

OBJECT=VARI_NEXTTRIGGERTYPESELECTOR
VARI_NEXTTRIGGERTYPESELECTOR:TYPE=INTEGER
VARI_NEXTTRIGGERTYPESELECTOR:VALUE=0
VARI_NEXTTRIGGERTYPESELECTOR:ONBRUTALCHANGED^0={BEHINVHIDECURRENTITEM^RUN();}
VARI_NEXTTRIGGERTYPESELECTOR:ONBRUTALCHANGED^1={VARS_CLICKPLACE^SET(SOBJECT|IDNAME);@IF("VARS_CURRENTITEM","!_",""NULL"","BFITMP8","BFITMP9");}
VARI_NEXTTRIGGERTYPESELECTOR:ONBRUTALCHANGED^2={@IF(BEHINVCHECKSPACE^RUN(),"_","TRUE","BFITMP10","BFITMP11");}
VARI_NEXTTRIGGERTYPESELECTOR:ONBRUTALCHANGED^3={@IF("SOBJECT|SPARAM1","!_",""NULL"","BFITMP13","");G_SARCADESCENEEXIT^SET(SOBJECT|IDNAME);@IF("SOBJECT|IPARAM2","_","0","BFITMP15","BFITMP16");}
VARI_NEXTTRIGGERTYPESELECTOR:ONBRUTALCHANGED^120={VARSTEMP0INSIDE^SET(VARS_CURRENTITEM);@IF("VARS_CURRENTITEMOBJECT","!_",""NULL"","BFITMP19","");}

OBJECT=VARI_OBJECTTYPESELECTOR
VARI_OBJECTTYPESELECTOR:TYPE=INTEGER
VARI_OBJECTTYPESELECTOR:ONBRUTALCHANGED^104={VARS_REXNAME^SET(SOBJECT|NAME);ANNREX^LOAD(SOBJECT|NAME);BEHREXINIT^RUN();VARD_REXSPEED^SET(SOBJECT|IPARAM0);@IF("VARD_REXSPEED","_","0.0","BFITMP20","");@IF("SOBJECT|SPARAM1","_",""NULL"","BFITMP21","BFITMP22");@IF("SOBJECT|IPARAM1","_","0","BFITMP25","BFITMP26");}
VARI_OBJECTTYPESELECTOR:ONBRUTALCHANGED^140={VARS_KRETNAME^SET(SOBJECT|NAME);ANNKRET^LOAD(SOBJECT|NAME);BEHKRETINIT^RUN();VARD_KRETSPEED^SET(SOBJECT|IPARAM0);@IF("VARD_KRETSPEED","_","0.0","BFITMP27","");VARI_KRETDISTANCEX^SET([VARD_KRETSPEED@5]);VARI_KRETDISTANCEY^SET(VARI_KRETDISTANCEX);@IF("SOBJECT|SPARAM1","_",""NULL"","BFITMP28","BFITMP29");VARB_KRETACTIVE^SET(TRUE);@IF("SOBJECT|IPARAM1","_","0","BFITMP32","BFITMP33");}
VARI_OBJECTTYPESELECTOR:ONBRUTALCHANGED^101={CANVASOBSERVER^SETBACKGROUND(SOBJECT|NAME);VARI_SCENEMAXPRIORITY^SET([SOBJECT|IPARAM1+1]);VARITEMP0INSIDE^SET(SOBJECT|IPARAM0);VARITEMP1INSIDE^SET(SOBJECT|IPARAM1);@IF("VARITEMP0INSIDE'0||VARITEMP1INSIDE'0","BFITMP34","");@IF("SOBJECT|IPARAM2","_","1","BFITMP35","");VARITEMP0INSIDE^SUB(800);VARITEMP1INSIDE^SUB(600);VARITEMP0INSIDE^DIV(2);VARITEMP1INSIDE^DIV(2);VARI_BKGXOFFSET^SET([0-VARITEMP0INSIDE]);VARI_BKGYOFFSET^SET([0-VARITEMP1INSIDE]);VARITEMP0INSIDE^ADD(800);VARITEMP1INSIDE^ADD(600);WPATH^SETBKGSIZE(VARI_BKGXOFFSET,VARITEMP0INSIDE,VARI_BKGYOFFSET,VARITEMP1INSIDE);WPATH^SETREFOBJECT(100);VARITEMP0INSIDE^SUB(800);VARITEMP1INSIDE^SUB(600);WPATH^SETMOVEFLAGS(VARITEMP0INSIDE,VARITEMP1INSIDE);}
VARI_OBJECTTYPESELECTOR:ONBRUTALCHANGED^108={VARI_NULL^SET(0);}
VARI_OBJECTTYPESELECTOR:ONBRUTALCHANGED^146={ARRGONAME1^ADD(SOBJECT|IDNAME);ARRGO1X^ADD(SOBJECT|IPARAM0);ARRGO1Y^ADD(SOBJECT|IPARAM1);}
VARI_OBJECTTYPESELECTOR:ONBRUTALCHANGED^145={ARRSTARTNAME1^ADD(SOBJECT|IDNAME);ARRSTART1X^ADD(SOBJECT|IPARAM0);ARRSTART1Y^ADD(SOBJECT|IPARAM1);}
VARI_OBJECTTYPESELECTOR:ONBRUTALCHANGED^106={ARRGONAME0^ADD(SOBJECT|IDNAME);ARRGO0X^ADD(SOBJECT|IPARAM0);ARRGO0Y^ADD(SOBJECT|IPARAM1);}
VARI_OBJECTTYPESELECTOR:ONBRUTALCHANGED^105={ARRSTARTNAME0^ADD(SOBJECT|IDNAME);ARRSTART0X^ADD(SOBJECT|IPARAM0);ARRSTART0Y^ADD(SOBJECT|IPARAM1);}
VARI_OBJECTTYPESELECTOR:ONBRUTALCHANGED^103={WPATH^SETACTIVE(SOBJECT|IPARAM0,SOBJECT|IPARAM1,SOBJECT|IPARAM2);}
VARI_OBJECTTYPESELECTOR:ONBRUTALCHANGED^102={WPATH^LOAD(SOBJECT|NAME);}
VARI_OBJECTTYPESELECTOR:ONBRUTALCHANGED={VARSTEMP0INSIDE^SET(["ANNOBJECT"+VARI_TEMPNO]);*VARSTEMP0INSIDE^LOAD(SOBJECT|NAME);*VARSTEMP0INSIDE^PLAY("PLAY");GRPMOVE^ADD(VARSTEMP0INSIDE);@IF("SOBJECT|TYPE","_","2","BFITMP38","BFITMP39");VARSTEMP2INSIDE^SET(*VARSTEMP0INSIDE^GETEVENTNAME(0));VARSTEMP1INSIDE^SET(VARSTEMP2INSIDE);VARITEMP0INSIDE^SET(VARSTEMP1INSIDE^FIND("-"));VARSTEMP1INSIDE^SUB(VARITEMP0INSIDE,[VARSTEMP2INSIDE^LENGTH()-VARITEMP0INSIDE]);VARSTEMP2INSIDE^SUB(0,[VARITEMP0INSIDE+1]);VARITEMP0INSIDE^SET(VARSTEMP1INSIDE);ARRGOTOX^ADD(VARITEMP0INSIDE);VARSTEMP1INSIDE^SET(VARSTEMP2INSIDE);VARITEMP0INSIDE^SET(VARSTEMP1INSIDE^FIND("-"));@IF("VARITEMP0INSIDE",">","-1","BFITMP40","BFITMP41");VARI_TEMPNO^INC();}

OBJECT=VARI_POSKRETX
VARI_POSKRETX:TYPE=INTEGER

OBJECT=VARI_POSKRETXGOTO
VARI_POSKRETXGOTO:TYPE=INTEGER

OBJECT=VARI_POSKRETXSAVE
VARI_POSKRETXSAVE:TYPE=INTEGER

OBJECT=VARI_POSKRETXTRIGGET
VARI_POSKRETXTRIGGET:TYPE=INTEGER

OBJECT=VARI_POSKRETY
VARI_POSKRETY:TYPE=INTEGER

OBJECT=VARI_POSKRETYGOTO
VARI_POSKRETYGOTO:TYPE=INTEGER

OBJECT=VARI_POSKRETYSAVE
VARI_POSKRETYSAVE:TYPE=INTEGER

OBJECT=VARI_POSKRETYTRIGGER
VARI_POSKRETYTRIGGER:TYPE=INTEGER

OBJECT=VARI_POSREXX
VARI_POSREXX:TYPE=INTEGER

OBJECT=VARI_POSREXXGOTO
VARI_POSREXXGOTO:TYPE=INTEGER

OBJECT=VARI_POSREXXSAVE
VARI_POSREXXSAVE:TYPE=INTEGER

OBJECT=VARI_POSREXXTRIGGER
VARI_POSREXXTRIGGER:TYPE=INTEGER

OBJECT=VARI_POSREXY
VARI_POSREXY:TYPE=INTEGER

OBJECT=VARI_POSREXYGOTO
VARI_POSREXYGOTO:TYPE=INTEGER

OBJECT=VARI_POSREXYSAVE
VARI_POSREXYSAVE:TYPE=INTEGER

OBJECT=VARI_POSREXYTRIGGER
VARI_POSREXYTRIGGER:TYPE=INTEGER

OBJECT=VARI_REXDIRTOGADA
VARI_REXDIRTOGADA:TYPE=INTEGER

OBJECT=VARI_SCENEIDLECLICKS
VARI_SCENEIDLECLICKS:TYPE=INTEGER
VARI_SCENEIDLECLICKS:VALUE=0

OBJECT=VARI_SCENEMAXPRIORITY
VARI_SCENEMAXPRIORITY:TYPE=INTEGER
VARI_SCENEMAXPRIORITY:VALUE=601

OBJECT=VARI_SEQARRNUMSNDS
VARI_SEQARRNUMSNDS:TYPE=INTEGER

OBJECT=VARI_SEQARRSNDINDEX
VARI_SEQARRSNDINDEX:TYPE=INTEGER

OBJECT=VARI_TEMPITER
VARI_TEMPITER:TYPE=INTEGER

OBJECT=VARI_TEMPNO
VARI_TEMPNO:TYPE=INTEGER

OBJECT=VARI_TEMPSELECTOR
VARI_TEMPSELECTOR:TYPE=INTEGER

OBJECT=VARI_NULL
VARI_NULL:TYPE=INTEGER

OBJECT=VARSAUXCLICKED
VARSAUXCLICKED:TYPE=STRING

OBJECT=VARSCURRARCADE
VARSCURRARCADE:TYPE=STRING

OBJECT=VARSCURRITEMS
VARSCURRITEMS:TYPE=STRING

OBJECT=VARSTAKENAME
VARSTAKENAME:TYPE=STRING

OBJECT=VARSTEMP0
VARSTEMP0:TYPE=STRING

OBJECT=VARSTEMP0INSIDE
VARSTEMP0INSIDE:TYPE=STRING

OBJECT=VARSTEMP1
VARSTEMP1:TYPE=STRING

OBJECT=VARSTEMP1INSIDE
VARSTEMP1INSIDE:TYPE=STRING

OBJECT=VARSTEMP2
VARSTEMP2:TYPE=STRING

OBJECT=VARSTEMP2INSIDE
VARSTEMP2INSIDE:TYPE=STRING

OBJECT=VARS_ARCADEEXITNAME
VARS_ARCADEEXITNAME:TYPE=STRING

OBJECT=VARS_ARCADESCENELAST
VARS_ARCADESCENELAST:TYPE=STRING

OBJECT=VARS_CLICKBOTHPLACE
VARS_CLICKBOTHPLACE:TYPE=STRING

OBJECT=VARS_CLICKCOMMENTPLACE
VARS_CLICKCOMMENTPLACE:TYPE=STRING

OBJECT=VARS_CLICKINVENTORYSELECTOR
VARS_CLICKINVENTORYSELECTOR:TYPE=STRING
VARS_CLICKINVENTORYSELECTOR:ONBRUTALCHANGED^NULL={VARS_CLICKOBJECTSELECTOR^SET(CANVASOBSERVER^GETGRAPHICSAT(MOUSE^GETPOSX(),MOUSE^GETPOSY(),TRUE,1,VARI_SCENEMAXPRIORITY,FALSE));}
VARS_CLICKINVENTORYSELECTOR:ONBRUTALCHANGED={VARSTEMP0INSIDE^SET(VARS_CLICKINVENTORYSELECTOR);ANNSELECT^HIDE();VARS_CURRENTITEMOBJECT^SET([VARSTEMP0INSIDE+"_1"]);*VARSTEMP0INSIDE^SETFRAME("PLAY",1);*VARSTEMP0INSIDE^CLONE(1);*VARS_CURRENTITEMOBJECT^SETPRIORITY(2901);VARSTEMP0INSIDE^SUB(0,7);VARITEMP0INSIDE^SET(VARSTEMP0INSIDE);VARITEMP1INSIDE^SET(0);@LOOP("{VARI_TEMPITER^SET(_I_);DBITEMS^SELECT(VARI_TEMPITER);SITEM^SET("DBITEMS_CURSOR");@IF("SITEM|EMPTY","_","1","BFITMP43","");}",0,10,1);DBITEMS^SELECT(VARITEMP2INSIDE);SITEM^SET("DBITEMS_CURSOR");VARS_CURRENTITEM^SET(SITEM|NAME);@LOOP("{VARI_TEMPITER^SET(_I_);VARSTEMP2INSIDE^SET(["ANNITEM"+VARI_TEMPITER]);*VARSTEMP2INSIDE^SETPRIORITY(2999);}",0,VARI_INVENTORYCOUNT,1);VARI_INVMENUVISIBLE^SET(-1);STL_INVENTORY^PLAY("ELAPSE");ANNSELECT^HIDE();*["BEHUSE_"+VARS_CURRENTITEM]^RUN();}

OBJECT=VARS_CLICKOBJECTSELECTOR
VARS_CLICKOBJECTSELECTOR:TYPE=STRING
VARS_CLICKOBJECTSELECTOR:ONBRUTALCHANGED^ANNREX={VARI_NEXTTRIGGER^SET(-1);VARI_NEXTTRIGGERKRET^SET(-1);VARS_CLICKPLACE^SET(NULL);VARS_CLICKBOTHPLACE^SET(NULL);@IF("VARS_CURRENTITEMOBJECT","!_",""NULL"","BFITMP47","BFITMP48");}
VARS_CLICKOBJECTSELECTOR:ONBRUTALCHANGED^ANNKRET={VARI_NEXTTRIGGER^SET(-1);VARI_NEXTTRIGGERKRET^SET(-1);VARS_CLICKPLACE^SET(NULL);VARS_CLICKBOTHPLACE^SET(NULL);}
VARS_CLICKOBJECTSELECTOR:ONBRUTALCHANGED={VARI_NEXTTRIGGER^SET(-1);VARI_NEXTTRIGGERKRET^SET(-1);VARS_CLICKPLACE^SET(NULL);VARS_CLICKBOTHPLACE^SET(NULL);@IF("VARI_INVMENUVISIBLE","_","1","BFITMP49","");ARRIDLETIME^CHANGEAT(0,0);ARRIDLETIME^CHANGEAT(1,0);@IF(VARS_CLICKOBJECTSELECTOR^FIND("ANNOBJECT"),">","-1","BFITMP57","BFITMP58");}

OBJECT=VARS_CLICKPLACE
VARS_CLICKPLACE:TYPE=STRING

OBJECT=VARS_CURRENTITEM
VARS_CURRENTITEM:TYPE=STRING
VARS_CURRENTITEM:VALUE=NULL

OBJECT=VARS_CURRENTITEMOBJECT
VARS_CURRENTITEMOBJECT:TYPE=STRING
VARS_CURRENTITEMOBJECT:VALUE=NULL

OBJECT=VARS_FOCUSON
VARS_FOCUSON:TYPE=STRING
VARS_FOCUSON:VALUE=NULL

OBJECT=VARS_FOCUSONLAST
VARS_FOCUSONLAST:TYPE=STRING
VARS_FOCUSONLAST:VALUE=NULL

OBJECT=VARS_GOALKRET
VARS_GOALKRET:TYPE=STRING

OBJECT=VARS_GOALREX
VARS_GOALREX:TYPE=STRING

OBJECT=VARS_INVMAINMOVEINVENTORYSELECTOR
VARS_INVMAINMOVEINVENTORYSELECTOR:TYPE=STRING
VARS_INVMAINMOVEINVENTORYSELECTOR:ONBRUTALCHANGED={@IF(*VARS_INVMAINMOVEINVENTORYSELECTOR^GETOPACITY(),"_","255","BFITMP59","BFITMP60");}
VARS_INVMAINMOVEINVENTORYSELECTOR:ONBRUTALCHANGED^NULL={ANNSELECT^HIDE();}

OBJECT=VARS_INVMAINMOVEOBJECTSELECTOR
VARS_INVMAINMOVEOBJECTSELECTOR:TYPE=STRING
VARS_INVMAINMOVEOBJECTSELECTOR:ONBRUTALCHANGED={G_CURSOR^SETOBJECT(VARS_INVMAINMOVEOBJECTSELECTOR);@IF(VARS_INVMAINMOVEOBJECTSELECTOR^FIND("ANNOBJECT"),">","-1","BFITMP63","");}
VARS_INVMAINMOVEOBJECTSELECTOR:ONBRUTALCHANGED^NULL={G_CURSOR^SETOBJECT(VARS_INVMAINMOVEOBJECTSELECTOR);@IF("VARS_FOCUSONLAST!'NULL&&VARS_CURRENTITEMOBJECT'"NULL"","BFITMP64","");}

OBJECT=VARS_KRETIDLENAME
VARS_KRETIDLENAME:TYPE=STRING
VARS_KRETIDLENAME:VALUE=BEHDEFAULTIDLE

OBJECT=VARS_KRETNAME
VARS_KRETNAME:TYPE=STRING
VARS_KRETNAME:VALUE=NULL

OBJECT=VARS_REXIDLENAME
VARS_REXIDLENAME:TYPE=STRING
VARS_REXIDLENAME:VALUE=BEHDEFAULTIDLE

OBJECT=VARS_REXNAME
VARS_REXNAME:TYPE=STRING

OBJECT=VARS_SCENETEMPOBJS
VARS_SCENETEMPOBJS:TYPE=STRING

OBJECT=VARS_SEQARRDIRSELECTOR
VARS_SEQARRDIRSELECTOR:TYPE=STRING
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^R={VARI_KRETDIRTOGADA^SET(0);VARI_REXDIRTOGADA^SET(0);}
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^RU={VARI_KRETDIRTOGADA^SET(1);VARI_REXDIRTOGADA^SET(1);}
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^UR={VARI_KRETDIRTOGADA^SET(1);VARI_REXDIRTOGADA^SET(1);}
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^U={VARI_KRETDIRTOGADA^SET(2);VARI_REXDIRTOGADA^SET(2);}
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^LU={VARI_KRETDIRTOGADA^SET(3);VARI_REXDIRTOGADA^SET(3);}
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^UL={VARI_KRETDIRTOGADA^SET(3);VARI_REXDIRTOGADA^SET(3);}
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^L={VARI_KRETDIRTOGADA^SET(4);VARI_REXDIRTOGADA^SET(4);}
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^LD={VARI_KRETDIRTOGADA^SET(5);VARI_REXDIRTOGADA^SET(5);}
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^DL={VARI_KRETDIRTOGADA^SET(5);VARI_REXDIRTOGADA^SET(5);}
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^D={VARI_KRETDIRTOGADA^SET(6);VARI_REXDIRTOGADA^SET(6);}
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^RD={VARI_KRETDIRTOGADA^SET(7);VARI_REXDIRTOGADA^SET(7);}
VARS_SEQARRDIRSELECTOR:ONBRUTALCHANGED^DR={VARI_KRETDIRTOGADA^SET(7);VARI_REXDIRTOGADA^SET(7);}

OBJECT=VARS_SEQARREMOT
VARS_SEQARREMOT:TYPE=STRING

OBJECT=VARS_SEQARREXIT
VARS_SEQARREXIT:TYPE=STRING
VARS_SEQARREXIT:VALUE=NULL

OBJECT=VARS_SEQARRKTOGADA
VARS_SEQARRKTOGADA:TYPE=STRING

OBJECT=VARS_SEQARRNAME
VARS_SEQARRNAME:TYPE=STRING

OBJECT=VARS_SEQARROBJECTSELECTOR
VARS_SEQARROBJECTSELECTOR:TYPE=STRING
VARS_SEQARROBJECTSELECTOR:ONBRUTALCHANGED^KRETES={VARS_SEQARRKTOGADA^SET("ANNKRET");@IF("VARB_KRETSHOW","_","TRUE","BFITMP65","");SNDATGOAL^PLAY();}
VARS_SEQARROBJECTSELECTOR:ONBRUTALCHANGED^REX={VARS_SEQARRKTOGADA^SET("ANNREX");@IF("VARB_KRETSHOW","_","TRUE","BFITMP66","");SNDATGOAL^PLAY();}
VARS_SEQARROBJECTSELECTOR:ONBRUTALCHANGED^NAR={VARS_SEQARRKTOGADA^SET(NULL);ANNCHARACTER^STOP(FALSE);ANNCHARACTER^LOAD("PIXEL.ANN");SEQBLANK^PLAY("GADABLANK");}
VARS_SEQARROBJECTSELECTOR:ONBRUTALCHANGED={VARITEMP0INSIDE^SET(DBOBJECTS^FIND("IDNAME",VARS_SEQARROBJECTSELECTOR,0));ANNCHARACTER^STOP(FALSE);ANNCHARACTER^LOAD("PIXEL.ANN");@IF("VARITEMP0INSIDE","_","-1","BFITMP67","BFITMP68");VARSTEMP1INSIDE^SET(["GADABLANK"+VARS_SEQARREMOT]);SEQBLANK^PLAY(VARSTEMP1INSIDE);}

OBJECT=VARS_TELEPORTDEST
VARS_TELEPORTDEST:TYPE=STRING

OBJECT=VARS_USEITEM
VARS_USEITEM:TYPE=STRING

OBJECT=VARS_USEPLACE
VARS_USEPLACE:TYPE=STRING

OBJECT=ANNCHARACTER
ANNCHARACTER:TYPE=ANIMO
ANNCHARACTER:VISIBLE=FALSE
ANNCHARACTER:FILENAME=PIXEL.ANN
ANNCHARACTER:TOCANVAS=TRUE
ANNCHARACTER:PRIORITY=0
ANNCHARACTER:FPS=16
ANNCHARACTER:PRELOAD=TRUE
ANNCHARACTER:RELEASE=TRUE
ANNCHARACTER:MONITORCOLLISION=FALSE
ANNCHARACTER:MONITORCOLLISIONALPHA=FALSE

OBJECT=ANNITEM0
ANNITEM0:TYPE=ANIMO
ANNITEM0:VISIBLE=FALSE
ANNITEM0:FILENAME=TEMPLATE.ANN
ANNITEM0:TOCANVAS=TRUE
ANNITEM0:PRIORITY=601
ANNITEM0:FPS=16
ANNITEM0:PRELOAD=TRUE
ANNITEM0:RELEASE=TRUE
ANNITEM0:MONITORCOLLISION=FALSE
ANNITEM0:MONITORCOLLISIONALPHA=FALSE

OBJECT=ANNITEM1
ANNITEM1:TYPE=ANIMO
ANNITEM1:VISIBLE=FALSE
ANNITEM1:FILENAME=TEMPLATE.ANN
ANNITEM1:TOCANVAS=TRUE
ANNITEM1:PRIORITY=601
ANNITEM1:FPS=16
ANNITEM1:PRELOAD=TRUE
ANNITEM1:RELEASE=TRUE
ANNITEM1:MONITORCOLLISION=FALSE
ANNITEM1:MONITORCOLLISIONALPHA=FALSE

OBJECT=ANNITEM2
ANNITEM2:TYPE=ANIMO
ANNITEM2:VISIBLE=FALSE
ANNITEM2:FILENAME=TEMPLATE.ANN
ANNITEM2:TOCANVAS=TRUE
ANNITEM2:PRIORITY=601
ANNITEM2:FPS=16
ANNITEM2:PRELOAD=TRUE
ANNITEM2:RELEASE=TRUE
ANNITEM2:MONITORCOLLISION=FALSE
ANNITEM2:MONITORCOLLISIONALPHA=FALSE

OBJECT=ANNITEM3
ANNITEM3:TYPE=ANIMO
ANNITEM3:VISIBLE=FALSE
ANNITEM3:FILENAME=TEMPLATE.ANN
ANNITEM3:TOCANVAS=TRUE
ANNITEM3:PRIORITY=601
ANNITEM3:FPS=16
ANNITEM3:PRELOAD=TRUE
ANNITEM3:RELEASE=TRUE
ANNITEM3:MONITORCOLLISION=FALSE
ANNITEM3:MONITORCOLLISIONALPHA=FALSE

OBJECT=ANNITEM4
ANNITEM4:TYPE=ANIMO
ANNITEM4:VISIBLE=FALSE
ANNITEM4:FILENAME=TEMPLATE.ANN
ANNITEM4:TOCANVAS=TRUE
ANNITEM4:PRIORITY=601
ANNITEM4:FPS=16
ANNITEM4:PRELOAD=TRUE
ANNITEM4:RELEASE=TRUE
ANNITEM4:MONITORCOLLISION=FALSE
ANNITEM4:MONITORCOLLISIONALPHA=FALSE

OBJECT=ANNITEM5
ANNITEM5:TYPE=ANIMO
ANNITEM5:VISIBLE=FALSE
ANNITEM5:FILENAME=TEMPLATE.ANN
ANNITEM5:TOCANVAS=TRUE
ANNITEM5:PRIORITY=601
ANNITEM5:FPS=16
ANNITEM5:PRELOAD=TRUE
ANNITEM5:RELEASE=TRUE
ANNITEM5:MONITORCOLLISION=FALSE
ANNITEM5:MONITORCOLLISIONALPHA=FALSE

OBJECT=ANNITEM6
ANNITEM6:TYPE=ANIMO
ANNITEM6:VISIBLE=FALSE
ANNITEM6:FILENAME=TEMPLATE.ANN
ANNITEM6:TOCANVAS=TRUE
ANNITEM6:PRIORITY=601
ANNITEM6:FPS=16
ANNITEM6:PRELOAD=TRUE
ANNITEM6:RELEASE=TRUE
ANNITEM6:MONITORCOLLISION=FALSE
ANNITEM6:MONITORCOLLISIONALPHA=FALSE

OBJECT=ANNITEM7
ANNITEM7:TYPE=ANIMO
ANNITEM7:VISIBLE=FALSE
ANNITEM7:FILENAME=TEMPLATE.ANN
ANNITEM7:TOCANVAS=TRUE
ANNITEM7:PRIORITY=601
ANNITEM7:FPS=16
ANNITEM7:PRELOAD=TRUE
ANNITEM7:RELEASE=TRUE
ANNITEM7:MONITORCOLLISION=FALSE
ANNITEM7:MONITORCOLLISIONALPHA=FALSE

OBJECT=ANNITEM8
ANNITEM8:TYPE=ANIMO
ANNITEM8:VISIBLE=FALSE
ANNITEM8:FILENAME=TEMPLATE.ANN
ANNITEM8:TOCANVAS=TRUE
ANNITEM8:PRIORITY=601
ANNITEM8:FPS=16
ANNITEM8:PRELOAD=TRUE
ANNITEM8:RELEASE=TRUE
ANNITEM8:MONITORCOLLISION=FALSE
ANNITEM8:MONITORCOLLISIONALPHA=FALSE

OBJECT=ANNITEM9
ANNITEM9:TYPE=ANIMO
ANNITEM9:VISIBLE=FALSE
ANNITEM9:FILENAME=TEMPLATE.ANN
ANNITEM9:TOCANVAS=TRUE
ANNITEM9:PRIORITY=601
ANNITEM9:FPS=16
ANNITEM9:PRELOAD=TRUE
ANNITEM9:RELEASE=TRUE
ANNITEM9:MONITORCOLLISION=FALSE
ANNITEM9:MONITORCOLLISIONALPHA=FALSE

OBJECT=ANNKRET
ANNKRET:TYPE=ANIMO
ANNKRET:VISIBLE=FALSE
ANNKRET:FILENAME=KRET20.ANN
ANNKRET:TOCANVAS=TRUE
ANNKRET:PRIORITY=0
ANNKRET:FPS=16
ANNKRET:PRELOAD=TRUE
ANNKRET:RELEASE=TRUE
ANNKRET:MONITORCOLLISION=FALSE
ANNKRET:MONITORCOLLISIONALPHA=FALSE
ANNKRET:ONSIGNAL^ATGOAL={@IF("VARI_NEXTTRIGGERKRET",">","-1","BFITMP70","");}
ANNKRET:ONFRAMECHANGED={BEHKRETFRAMECHANGE^RUN();}

OBJECT=ANNOBJECT0
ANNOBJECT0:TYPE=ANIMO
ANNOBJECT0:VISIBLE=FALSE
ANNOBJECT0:FILENAME=TEMPLATE.ANN
ANNOBJECT0:TOCANVAS=TRUE
ANNOBJECT0:PRIORITY=0
ANNOBJECT0:FPS=16
ANNOBJECT0:PRELOAD=TRUE
ANNOBJECT0:RELEASE=TRUE
ANNOBJECT0:MONITORCOLLISION=FALSE
ANNOBJECT0:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT0:ONFINISHED={VARI_ANIMFINISH^SET(0);}

OBJECT=ANNOBJECT1
ANNOBJECT1:TYPE=ANIMO
ANNOBJECT1:VISIBLE=FALSE
ANNOBJECT1:FILENAME=TEMPLATE.ANN
ANNOBJECT1:TOCANVAS=TRUE
ANNOBJECT1:PRIORITY=0
ANNOBJECT1:FPS=16
ANNOBJECT1:PRELOAD=TRUE
ANNOBJECT1:RELEASE=TRUE
ANNOBJECT1:MONITORCOLLISION=FALSE
ANNOBJECT1:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT1:ONFINISHED={VARI_ANIMFINISH^SET(1);}

OBJECT=ANNOBJECT10
ANNOBJECT10:TYPE=ANIMO
ANNOBJECT10:VISIBLE=FALSE
ANNOBJECT10:FILENAME=TEMPLATE.ANN
ANNOBJECT10:TOCANVAS=TRUE
ANNOBJECT10:PRIORITY=0
ANNOBJECT10:FPS=16
ANNOBJECT10:PRELOAD=TRUE
ANNOBJECT10:RELEASE=TRUE
ANNOBJECT10:MONITORCOLLISION=FALSE
ANNOBJECT10:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT10:ONFINISHED={VARI_ANIMFINISH^SET(10);}

OBJECT=ANNOBJECT11
ANNOBJECT11:TYPE=ANIMO
ANNOBJECT11:VISIBLE=FALSE
ANNOBJECT11:FILENAME=TEMPLATE.ANN
ANNOBJECT11:TOCANVAS=TRUE
ANNOBJECT11:PRIORITY=0
ANNOBJECT11:FPS=16
ANNOBJECT11:PRELOAD=TRUE
ANNOBJECT11:RELEASE=TRUE
ANNOBJECT11:MONITORCOLLISION=FALSE
ANNOBJECT11:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT11:ONFINISHED={VARI_ANIMFINISH^SET(11);}

OBJECT=ANNOBJECT12
ANNOBJECT12:TYPE=ANIMO
ANNOBJECT12:VISIBLE=FALSE
ANNOBJECT12:FILENAME=TEMPLATE.ANN
ANNOBJECT12:TOCANVAS=TRUE
ANNOBJECT12:PRIORITY=0
ANNOBJECT12:FPS=16
ANNOBJECT12:PRELOAD=TRUE
ANNOBJECT12:RELEASE=TRUE
ANNOBJECT12:MONITORCOLLISION=FALSE
ANNOBJECT12:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT12:ONFINISHED={VARI_ANIMFINISH^SET(12);}

OBJECT=ANNOBJECT13
ANNOBJECT13:TYPE=ANIMO
ANNOBJECT13:VISIBLE=FALSE
ANNOBJECT13:FILENAME=TEMPLATE.ANN
ANNOBJECT13:TOCANVAS=TRUE
ANNOBJECT13:PRIORITY=0
ANNOBJECT13:FPS=16
ANNOBJECT13:PRELOAD=TRUE
ANNOBJECT13:RELEASE=TRUE
ANNOBJECT13:MONITORCOLLISION=FALSE
ANNOBJECT13:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT13:ONFINISHED={VARI_ANIMFINISH^SET(13);}

OBJECT=ANNOBJECT14
ANNOBJECT14:TYPE=ANIMO
ANNOBJECT14:VISIBLE=FALSE
ANNOBJECT14:FILENAME=TEMPLATE.ANN
ANNOBJECT14:TOCANVAS=TRUE
ANNOBJECT14:PRIORITY=0
ANNOBJECT14:FPS=16
ANNOBJECT14:PRELOAD=TRUE
ANNOBJECT14:RELEASE=TRUE
ANNOBJECT14:MONITORCOLLISION=FALSE
ANNOBJECT14:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT14:ONFINISHED={VARI_ANIMFINISH^SET(14);}

OBJECT=ANNOBJECT15
ANNOBJECT15:TYPE=ANIMO
ANNOBJECT15:VISIBLE=FALSE
ANNOBJECT15:FILENAME=TEMPLATE.ANN
ANNOBJECT15:TOCANVAS=TRUE
ANNOBJECT15:PRIORITY=0
ANNOBJECT15:FPS=16
ANNOBJECT15:PRELOAD=TRUE
ANNOBJECT15:RELEASE=TRUE
ANNOBJECT15:MONITORCOLLISION=FALSE
ANNOBJECT15:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT15:ONFINISHED={VARI_ANIMFINISH^SET(15);}

OBJECT=ANNOBJECT16
ANNOBJECT16:TYPE=ANIMO
ANNOBJECT16:VISIBLE=FALSE
ANNOBJECT16:FILENAME=TEMPLATE.ANN
ANNOBJECT16:TOCANVAS=TRUE
ANNOBJECT16:PRIORITY=0
ANNOBJECT16:FPS=16
ANNOBJECT16:PRELOAD=TRUE
ANNOBJECT16:RELEASE=TRUE
ANNOBJECT16:MONITORCOLLISION=FALSE
ANNOBJECT16:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT16:ONFINISHED={VARI_ANIMFINISH^SET(16);}

OBJECT=ANNOBJECT17
ANNOBJECT17:TYPE=ANIMO
ANNOBJECT17:VISIBLE=FALSE
ANNOBJECT17:FILENAME=TEMPLATE.ANN
ANNOBJECT17:TOCANVAS=TRUE
ANNOBJECT17:PRIORITY=0
ANNOBJECT17:FPS=16
ANNOBJECT17:PRELOAD=TRUE
ANNOBJECT17:RELEASE=TRUE
ANNOBJECT17:MONITORCOLLISION=FALSE
ANNOBJECT17:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT17:ONFINISHED={VARI_ANIMFINISH^SET(17);}

OBJECT=ANNOBJECT18
ANNOBJECT18:TYPE=ANIMO
ANNOBJECT18:VISIBLE=FALSE
ANNOBJECT18:FILENAME=TEMPLATE.ANN
ANNOBJECT18:TOCANVAS=TRUE
ANNOBJECT18:PRIORITY=0
ANNOBJECT18:FPS=16
ANNOBJECT18:PRELOAD=TRUE
ANNOBJECT18:RELEASE=TRUE
ANNOBJECT18:MONITORCOLLISION=FALSE
ANNOBJECT18:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT18:ONFINISHED={VARI_ANIMFINISH^SET(18);}

OBJECT=ANNOBJECT19
ANNOBJECT19:TYPE=ANIMO
ANNOBJECT19:VISIBLE=FALSE
ANNOBJECT19:FILENAME=TEMPLATE.ANN
ANNOBJECT19:TOCANVAS=TRUE
ANNOBJECT19:PRIORITY=0
ANNOBJECT19:FPS=16
ANNOBJECT19:PRELOAD=TRUE
ANNOBJECT19:RELEASE=TRUE
ANNOBJECT19:MONITORCOLLISION=FALSE
ANNOBJECT19:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT19:ONFINISHED={VARI_ANIMFINISH^SET(19);}

OBJECT=ANNOBJECT2
ANNOBJECT2:TYPE=ANIMO
ANNOBJECT2:VISIBLE=FALSE
ANNOBJECT2:FILENAME=TEMPLATE.ANN
ANNOBJECT2:TOCANVAS=TRUE
ANNOBJECT2:PRIORITY=0
ANNOBJECT2:FPS=16
ANNOBJECT2:PRELOAD=TRUE
ANNOBJECT2:RELEASE=TRUE
ANNOBJECT2:MONITORCOLLISION=FALSE
ANNOBJECT2:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT2:ONFINISHED={VARI_ANIMFINISH^SET(2);}

OBJECT=ANNOBJECT20
ANNOBJECT20:TYPE=ANIMO
ANNOBJECT20:VISIBLE=FALSE
ANNOBJECT20:FILENAME=TEMPLATE.ANN
ANNOBJECT20:TOCANVAS=TRUE
ANNOBJECT20:PRIORITY=0
ANNOBJECT20:FPS=16
ANNOBJECT20:PRELOAD=TRUE
ANNOBJECT20:RELEASE=TRUE
ANNOBJECT20:MONITORCOLLISION=FALSE
ANNOBJECT20:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT20:ONFINISHED={VARI_ANIMFINISH^SET(20);}

OBJECT=ANNOBJECT21
ANNOBJECT21:TYPE=ANIMO
ANNOBJECT21:VISIBLE=FALSE
ANNOBJECT21:FILENAME=TEMPLATE.ANN
ANNOBJECT21:TOCANVAS=TRUE
ANNOBJECT21:PRIORITY=0
ANNOBJECT21:FPS=16
ANNOBJECT21:PRELOAD=TRUE
ANNOBJECT21:RELEASE=TRUE
ANNOBJECT21:MONITORCOLLISION=FALSE
ANNOBJECT21:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT21:ONFINISHED={VARI_ANIMFINISH^SET(21);}

OBJECT=ANNOBJECT22
ANNOBJECT22:TYPE=ANIMO
ANNOBJECT22:VISIBLE=FALSE
ANNOBJECT22:FILENAME=TEMPLATE.ANN
ANNOBJECT22:TOCANVAS=TRUE
ANNOBJECT22:PRIORITY=0
ANNOBJECT22:FPS=16
ANNOBJECT22:PRELOAD=TRUE
ANNOBJECT22:RELEASE=TRUE
ANNOBJECT22:MONITORCOLLISION=FALSE
ANNOBJECT22:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT22:ONFINISHED={VARI_ANIMFINISH^SET(22);}

OBJECT=ANNOBJECT23
ANNOBJECT23:TYPE=ANIMO
ANNOBJECT23:VISIBLE=FALSE
ANNOBJECT23:FILENAME=TEMPLATE.ANN
ANNOBJECT23:TOCANVAS=TRUE
ANNOBJECT23:PRIORITY=0
ANNOBJECT23:FPS=16
ANNOBJECT23:PRELOAD=TRUE
ANNOBJECT23:RELEASE=TRUE
ANNOBJECT23:MONITORCOLLISION=FALSE
ANNOBJECT23:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT23:ONFINISHED={VARI_ANIMFINISH^SET(23);}

OBJECT=ANNOBJECT24
ANNOBJECT24:TYPE=ANIMO
ANNOBJECT24:VISIBLE=FALSE
ANNOBJECT24:FILENAME=TEMPLATE.ANN
ANNOBJECT24:TOCANVAS=TRUE
ANNOBJECT24:PRIORITY=0
ANNOBJECT24:FPS=16
ANNOBJECT24:PRELOAD=TRUE
ANNOBJECT24:RELEASE=TRUE
ANNOBJECT24:MONITORCOLLISION=FALSE
ANNOBJECT24:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT24:ONFINISHED={VARI_ANIMFINISH^SET(24);}

OBJECT=ANNOBJECT25
ANNOBJECT25:TYPE=ANIMO
ANNOBJECT25:VISIBLE=FALSE
ANNOBJECT25:FILENAME=TEMPLATE.ANN
ANNOBJECT25:TOCANVAS=TRUE
ANNOBJECT25:PRIORITY=0
ANNOBJECT25:FPS=16
ANNOBJECT25:PRELOAD=TRUE
ANNOBJECT25:RELEASE=TRUE
ANNOBJECT25:MONITORCOLLISION=FALSE
ANNOBJECT25:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT25:ONFINISHED={VARI_ANIMFINISH^SET(25);}

OBJECT=ANNOBJECT26
ANNOBJECT26:TYPE=ANIMO
ANNOBJECT26:VISIBLE=FALSE
ANNOBJECT26:FILENAME=TEMPLATE.ANN
ANNOBJECT26:TOCANVAS=TRUE
ANNOBJECT26:PRIORITY=0
ANNOBJECT26:FPS=16
ANNOBJECT26:PRELOAD=TRUE
ANNOBJECT26:RELEASE=TRUE
ANNOBJECT26:MONITORCOLLISION=FALSE
ANNOBJECT26:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT26:ONFINISHED={VARI_ANIMFINISH^SET(26);}

OBJECT=ANNOBJECT27
ANNOBJECT27:TYPE=ANIMO
ANNOBJECT27:VISIBLE=FALSE
ANNOBJECT27:FILENAME=TEMPLATE.ANN
ANNOBJECT27:TOCANVAS=TRUE
ANNOBJECT27:PRIORITY=0
ANNOBJECT27:FPS=16
ANNOBJECT27:PRELOAD=TRUE
ANNOBJECT27:RELEASE=TRUE
ANNOBJECT27:MONITORCOLLISION=FALSE
ANNOBJECT27:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT27:ONFINISHED={VARI_ANIMFINISH^SET(27);}

OBJECT=ANNOBJECT28
ANNOBJECT28:TYPE=ANIMO
ANNOBJECT28:VISIBLE=FALSE
ANNOBJECT28:FILENAME=TEMPLATE.ANN
ANNOBJECT28:TOCANVAS=TRUE
ANNOBJECT28:PRIORITY=0
ANNOBJECT28:FPS=16
ANNOBJECT28:PRELOAD=TRUE
ANNOBJECT28:RELEASE=TRUE
ANNOBJECT28:MONITORCOLLISION=FALSE
ANNOBJECT28:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT28:ONFINISHED={VARI_ANIMFINISH^SET(28);}

OBJECT=ANNOBJECT29
ANNOBJECT29:TYPE=ANIMO
ANNOBJECT29:VISIBLE=FALSE
ANNOBJECT29:FILENAME=TEMPLATE.ANN
ANNOBJECT29:TOCANVAS=TRUE
ANNOBJECT29:PRIORITY=0
ANNOBJECT29:FPS=16
ANNOBJECT29:PRELOAD=TRUE
ANNOBJECT29:RELEASE=TRUE
ANNOBJECT29:MONITORCOLLISION=FALSE
ANNOBJECT29:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT29:ONFINISHED={VARI_ANIMFINISH^SET(29);}

OBJECT=ANNOBJECT3
ANNOBJECT3:TYPE=ANIMO
ANNOBJECT3:VISIBLE=FALSE
ANNOBJECT3:FILENAME=TEMPLATE.ANN
ANNOBJECT3:TOCANVAS=TRUE
ANNOBJECT3:PRIORITY=0
ANNOBJECT3:FPS=16
ANNOBJECT3:PRELOAD=TRUE
ANNOBJECT3:RELEASE=TRUE
ANNOBJECT3:MONITORCOLLISION=FALSE
ANNOBJECT3:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT3:ONFINISHED={VARI_ANIMFINISH^SET(3);}

OBJECT=ANNOBJECT30
ANNOBJECT30:TYPE=ANIMO
ANNOBJECT30:VISIBLE=FALSE
ANNOBJECT30:FILENAME=TEMPLATE.ANN
ANNOBJECT30:TOCANVAS=TRUE
ANNOBJECT30:PRIORITY=0
ANNOBJECT30:FPS=16
ANNOBJECT30:PRELOAD=TRUE
ANNOBJECT30:RELEASE=TRUE
ANNOBJECT30:MONITORCOLLISION=FALSE
ANNOBJECT30:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT30:ONFINISHED={VARI_ANIMFINISH^SET(30);}

OBJECT=ANNOBJECT31
ANNOBJECT31:TYPE=ANIMO
ANNOBJECT31:VISIBLE=FALSE
ANNOBJECT31:FILENAME=TEMPLATE.ANN
ANNOBJECT31:TOCANVAS=TRUE
ANNOBJECT31:PRIORITY=0
ANNOBJECT31:FPS=16
ANNOBJECT31:PRELOAD=TRUE
ANNOBJECT31:RELEASE=TRUE
ANNOBJECT31:MONITORCOLLISION=FALSE
ANNOBJECT31:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT31:ONFINISHED={VARI_ANIMFINISH^SET(31);}

OBJECT=ANNOBJECT32
ANNOBJECT32:TYPE=ANIMO
ANNOBJECT32:VISIBLE=FALSE
ANNOBJECT32:FILENAME=TEMPLATE.ANN
ANNOBJECT32:TOCANVAS=TRUE
ANNOBJECT32:PRIORITY=0
ANNOBJECT32:FPS=16
ANNOBJECT32:PRELOAD=TRUE
ANNOBJECT32:RELEASE=TRUE
ANNOBJECT32:MONITORCOLLISION=FALSE
ANNOBJECT32:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT32:ONFINISHED={VARI_ANIMFINISH^SET(32);}

OBJECT=ANNOBJECT33
ANNOBJECT33:TYPE=ANIMO
ANNOBJECT33:VISIBLE=FALSE
ANNOBJECT33:FILENAME=TEMPLATE.ANN
ANNOBJECT33:TOCANVAS=TRUE
ANNOBJECT33:PRIORITY=0
ANNOBJECT33:FPS=16
ANNOBJECT33:PRELOAD=TRUE
ANNOBJECT33:RELEASE=TRUE
ANNOBJECT33:MONITORCOLLISION=FALSE
ANNOBJECT33:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT33:ONFINISHED={VARI_ANIMFINISH^SET(33);}

OBJECT=ANNOBJECT34
ANNOBJECT34:TYPE=ANIMO
ANNOBJECT34:VISIBLE=FALSE
ANNOBJECT34:FILENAME=TEMPLATE.ANN
ANNOBJECT34:TOCANVAS=TRUE
ANNOBJECT34:PRIORITY=0
ANNOBJECT34:FPS=16
ANNOBJECT34:PRELOAD=TRUE
ANNOBJECT34:RELEASE=TRUE
ANNOBJECT34:MONITORCOLLISION=FALSE
ANNOBJECT34:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT34:ONFINISHED={VARI_ANIMFINISH^SET(34);}

OBJECT=ANNOBJECT35
ANNOBJECT35:TYPE=ANIMO
ANNOBJECT35:VISIBLE=FALSE
ANNOBJECT35:FILENAME=TEMPLATE.ANN
ANNOBJECT35:TOCANVAS=TRUE
ANNOBJECT35:PRIORITY=0
ANNOBJECT35:FPS=16
ANNOBJECT35:PRELOAD=TRUE
ANNOBJECT35:RELEASE=TRUE
ANNOBJECT35:MONITORCOLLISION=FALSE
ANNOBJECT35:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT35:ONFINISHED={VARI_ANIMFINISH^SET(35);}

OBJECT=ANNOBJECT36
ANNOBJECT36:TYPE=ANIMO
ANNOBJECT36:VISIBLE=FALSE
ANNOBJECT36:FILENAME=TEMPLATE.ANN
ANNOBJECT36:TOCANVAS=TRUE
ANNOBJECT36:PRIORITY=0
ANNOBJECT36:FPS=16
ANNOBJECT36:PRELOAD=TRUE
ANNOBJECT36:RELEASE=TRUE
ANNOBJECT36:MONITORCOLLISION=FALSE
ANNOBJECT36:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT36:ONFINISHED={VARI_ANIMFINISH^SET(36);}

OBJECT=ANNOBJECT37
ANNOBJECT37:TYPE=ANIMO
ANNOBJECT37:VISIBLE=FALSE
ANNOBJECT37:FILENAME=TEMPLATE.ANN
ANNOBJECT37:TOCANVAS=TRUE
ANNOBJECT37:PRIORITY=0
ANNOBJECT37:FPS=16
ANNOBJECT37:PRELOAD=TRUE
ANNOBJECT37:RELEASE=TRUE
ANNOBJECT37:MONITORCOLLISION=FALSE
ANNOBJECT37:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT37:ONFINISHED={VARI_ANIMFINISH^SET(37);}

OBJECT=ANNOBJECT38
ANNOBJECT38:TYPE=ANIMO
ANNOBJECT38:VISIBLE=FALSE
ANNOBJECT38:FILENAME=TEMPLATE.ANN
ANNOBJECT38:TOCANVAS=TRUE
ANNOBJECT38:PRIORITY=0
ANNOBJECT38:FPS=16
ANNOBJECT38:PRELOAD=TRUE
ANNOBJECT38:RELEASE=TRUE
ANNOBJECT38:MONITORCOLLISION=FALSE
ANNOBJECT38:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT38:ONFINISHED={VARI_ANIMFINISH^SET(38);}

OBJECT=ANNOBJECT39
ANNOBJECT39:TYPE=ANIMO
ANNOBJECT39:VISIBLE=FALSE
ANNOBJECT39:FILENAME=TEMPLATE.ANN
ANNOBJECT39:TOCANVAS=TRUE
ANNOBJECT39:PRIORITY=0
ANNOBJECT39:FPS=16
ANNOBJECT39:PRELOAD=TRUE
ANNOBJECT39:RELEASE=TRUE
ANNOBJECT39:MONITORCOLLISION=FALSE
ANNOBJECT39:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT39:ONFINISHED={VARI_ANIMFINISH^SET(39);}

OBJECT=ANNOBJECT4
ANNOBJECT4:TYPE=ANIMO
ANNOBJECT4:VISIBLE=FALSE
ANNOBJECT4:FILENAME=TEMPLATE.ANN
ANNOBJECT4:TOCANVAS=TRUE
ANNOBJECT4:PRIORITY=0
ANNOBJECT4:FPS=16
ANNOBJECT4:PRELOAD=TRUE
ANNOBJECT4:RELEASE=TRUE
ANNOBJECT4:MONITORCOLLISION=FALSE
ANNOBJECT4:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT4:ONFINISHED={VARI_ANIMFINISH^SET(4);}

OBJECT=ANNOBJECT40
ANNOBJECT40:TYPE=ANIMO
ANNOBJECT40:VISIBLE=FALSE
ANNOBJECT40:FILENAME=TEMPLATE.ANN
ANNOBJECT40:TOCANVAS=TRUE
ANNOBJECT40:PRIORITY=0
ANNOBJECT40:FPS=16
ANNOBJECT40:PRELOAD=TRUE
ANNOBJECT40:RELEASE=TRUE
ANNOBJECT40:MONITORCOLLISION=FALSE
ANNOBJECT40:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT40:ONFINISHED={VARI_ANIMFINISH^SET(40);}

OBJECT=ANNOBJECT41
ANNOBJECT41:TYPE=ANIMO
ANNOBJECT41:VISIBLE=FALSE
ANNOBJECT41:FILENAME=TEMPLATE.ANN
ANNOBJECT41:TOCANVAS=TRUE
ANNOBJECT41:PRIORITY=0
ANNOBJECT41:FPS=16
ANNOBJECT41:PRELOAD=TRUE
ANNOBJECT41:RELEASE=TRUE
ANNOBJECT41:MONITORCOLLISION=FALSE
ANNOBJECT41:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT41:ONFINISHED={VARI_ANIMFINISH^SET(41);}

OBJECT=ANNOBJECT42
ANNOBJECT42:TYPE=ANIMO
ANNOBJECT42:VISIBLE=FALSE
ANNOBJECT42:FILENAME=TEMPLATE.ANN
ANNOBJECT42:TOCANVAS=TRUE
ANNOBJECT42:PRIORITY=0
ANNOBJECT42:FPS=16
ANNOBJECT42:PRELOAD=TRUE
ANNOBJECT42:RELEASE=TRUE
ANNOBJECT42:MONITORCOLLISION=FALSE
ANNOBJECT42:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT42:ONFINISHED={VARI_ANIMFINISH^SET(42);}

OBJECT=ANNOBJECT43
ANNOBJECT43:TYPE=ANIMO
ANNOBJECT43:VISIBLE=FALSE
ANNOBJECT43:FILENAME=TEMPLATE.ANN
ANNOBJECT43:TOCANVAS=TRUE
ANNOBJECT43:PRIORITY=0
ANNOBJECT43:FPS=16
ANNOBJECT43:PRELOAD=TRUE
ANNOBJECT43:RELEASE=TRUE
ANNOBJECT43:MONITORCOLLISION=FALSE
ANNOBJECT43:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT43:ONFINISHED={VARI_ANIMFINISH^SET(43);}

OBJECT=ANNOBJECT44
ANNOBJECT44:TYPE=ANIMO
ANNOBJECT44:VISIBLE=FALSE
ANNOBJECT44:FILENAME=TEMPLATE.ANN
ANNOBJECT44:TOCANVAS=TRUE
ANNOBJECT44:PRIORITY=0
ANNOBJECT44:FPS=16
ANNOBJECT44:PRELOAD=TRUE
ANNOBJECT44:RELEASE=TRUE
ANNOBJECT44:MONITORCOLLISION=FALSE
ANNOBJECT44:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT44:ONFINISHED={VARI_ANIMFINISH^SET(44);}

OBJECT=ANNOBJECT45
ANNOBJECT45:TYPE=ANIMO
ANNOBJECT45:VISIBLE=FALSE
ANNOBJECT45:FILENAME=TEMPLATE.ANN
ANNOBJECT45:TOCANVAS=TRUE
ANNOBJECT45:PRIORITY=0
ANNOBJECT45:FPS=16
ANNOBJECT45:PRELOAD=TRUE
ANNOBJECT45:RELEASE=TRUE
ANNOBJECT45:MONITORCOLLISION=FALSE
ANNOBJECT45:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT45:ONFINISHED={VARI_ANIMFINISH^SET(45);}

OBJECT=ANNOBJECT46
ANNOBJECT46:TYPE=ANIMO
ANNOBJECT46:VISIBLE=FALSE
ANNOBJECT46:FILENAME=TEMPLATE.ANN
ANNOBJECT46:TOCANVAS=TRUE
ANNOBJECT46:PRIORITY=0
ANNOBJECT46:FPS=16
ANNOBJECT46:PRELOAD=TRUE
ANNOBJECT46:RELEASE=TRUE
ANNOBJECT46:MONITORCOLLISION=FALSE
ANNOBJECT46:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT46:ONFINISHED={VARI_ANIMFINISH^SET(46);}

OBJECT=ANNOBJECT47
ANNOBJECT47:TYPE=ANIMO
ANNOBJECT47:VISIBLE=FALSE
ANNOBJECT47:FILENAME=TEMPLATE.ANN
ANNOBJECT47:TOCANVAS=TRUE
ANNOBJECT47:PRIORITY=0
ANNOBJECT47:FPS=16
ANNOBJECT47:PRELOAD=TRUE
ANNOBJECT47:RELEASE=TRUE
ANNOBJECT47:MONITORCOLLISION=FALSE
ANNOBJECT47:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT47:ONFINISHED={VARI_ANIMFINISH^SET(47);}

OBJECT=ANNOBJECT48
ANNOBJECT48:TYPE=ANIMO
ANNOBJECT48:VISIBLE=FALSE
ANNOBJECT48:FILENAME=TEMPLATE.ANN
ANNOBJECT48:TOCANVAS=TRUE
ANNOBJECT48:PRIORITY=0
ANNOBJECT48:FPS=16
ANNOBJECT48:PRELOAD=TRUE
ANNOBJECT48:RELEASE=TRUE
ANNOBJECT48:MONITORCOLLISION=FALSE
ANNOBJECT48:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT48:ONFINISHED={VARI_ANIMFINISH^SET(48);}

OBJECT=ANNOBJECT49
ANNOBJECT49:TYPE=ANIMO
ANNOBJECT49:VISIBLE=FALSE
ANNOBJECT49:FILENAME=TEMPLATE.ANN
ANNOBJECT49:TOCANVAS=TRUE
ANNOBJECT49:PRIORITY=0
ANNOBJECT49:FPS=16
ANNOBJECT49:PRELOAD=TRUE
ANNOBJECT49:RELEASE=TRUE
ANNOBJECT49:MONITORCOLLISION=FALSE
ANNOBJECT49:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT49:ONFINISHED={VARI_ANIMFINISH^SET(49);}

OBJECT=ANNOBJECT5
ANNOBJECT5:TYPE=ANIMO
ANNOBJECT5:VISIBLE=FALSE
ANNOBJECT5:FILENAME=TEMPLATE.ANN
ANNOBJECT5:TOCANVAS=TRUE
ANNOBJECT5:PRIORITY=0
ANNOBJECT5:FPS=16
ANNOBJECT5:PRELOAD=TRUE
ANNOBJECT5:RELEASE=TRUE
ANNOBJECT5:MONITORCOLLISION=FALSE
ANNOBJECT5:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT5:ONFINISHED={VARI_ANIMFINISH^SET(5);}

OBJECT=ANNOBJECT50
ANNOBJECT50:TYPE=ANIMO
ANNOBJECT50:VISIBLE=FALSE
ANNOBJECT50:FILENAME=TEMPLATE.ANN
ANNOBJECT50:TOCANVAS=TRUE
ANNOBJECT50:PRIORITY=0
ANNOBJECT50:FPS=16
ANNOBJECT50:PRELOAD=TRUE
ANNOBJECT50:RELEASE=TRUE
ANNOBJECT50:MONITORCOLLISION=FALSE
ANNOBJECT50:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT50:ONFINISHED={VARI_ANIMFINISH^SET(50);}

OBJECT=ANNOBJECT51
ANNOBJECT51:TYPE=ANIMO
ANNOBJECT51:VISIBLE=FALSE
ANNOBJECT51:FILENAME=TEMPLATE.ANN
ANNOBJECT51:TOCANVAS=TRUE
ANNOBJECT51:PRIORITY=0
ANNOBJECT51:FPS=16
ANNOBJECT51:PRELOAD=TRUE
ANNOBJECT51:RELEASE=TRUE
ANNOBJECT51:MONITORCOLLISION=FALSE
ANNOBJECT51:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT51:ONFINISHED={VARI_ANIMFINISH^SET(51);}

OBJECT=ANNOBJECT52
ANNOBJECT52:TYPE=ANIMO
ANNOBJECT52:VISIBLE=FALSE
ANNOBJECT52:FILENAME=TEMPLATE.ANN
ANNOBJECT52:TOCANVAS=TRUE
ANNOBJECT52:PRIORITY=0
ANNOBJECT52:FPS=16
ANNOBJECT52:PRELOAD=TRUE
ANNOBJECT52:RELEASE=TRUE
ANNOBJECT52:MONITORCOLLISION=FALSE
ANNOBJECT52:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT52:ONFINISHED={VARI_ANIMFINISH^SET(52);}

OBJECT=ANNOBJECT53
ANNOBJECT53:TYPE=ANIMO
ANNOBJECT53:VISIBLE=FALSE
ANNOBJECT53:FILENAME=TEMPLATE.ANN
ANNOBJECT53:TOCANVAS=TRUE
ANNOBJECT53:PRIORITY=0
ANNOBJECT53:FPS=16
ANNOBJECT53:PRELOAD=TRUE
ANNOBJECT53:RELEASE=TRUE
ANNOBJECT53:MONITORCOLLISION=FALSE
ANNOBJECT53:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT53:ONFINISHED={VARI_ANIMFINISH^SET(53);}

OBJECT=ANNOBJECT54
ANNOBJECT54:TYPE=ANIMO
ANNOBJECT54:VISIBLE=FALSE
ANNOBJECT54:FILENAME=TEMPLATE.ANN
ANNOBJECT54:TOCANVAS=TRUE
ANNOBJECT54:PRIORITY=0
ANNOBJECT54:FPS=16
ANNOBJECT54:PRELOAD=TRUE
ANNOBJECT54:RELEASE=TRUE
ANNOBJECT54:MONITORCOLLISION=FALSE
ANNOBJECT54:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT54:ONFINISHED={VARI_ANIMFINISH^SET(54);}

OBJECT=ANNOBJECT55
ANNOBJECT55:TYPE=ANIMO
ANNOBJECT55:VISIBLE=FALSE
ANNOBJECT55:FILENAME=TEMPLATE.ANN
ANNOBJECT55:TOCANVAS=TRUE
ANNOBJECT55:PRIORITY=0
ANNOBJECT55:FPS=16
ANNOBJECT55:PRELOAD=TRUE
ANNOBJECT55:RELEASE=TRUE
ANNOBJECT55:MONITORCOLLISION=FALSE
ANNOBJECT55:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT55:ONFINISHED={VARI_ANIMFINISH^SET(55);}

OBJECT=ANNOBJECT56
ANNOBJECT56:TYPE=ANIMO
ANNOBJECT56:VISIBLE=FALSE
ANNOBJECT56:FILENAME=TEMPLATE.ANN
ANNOBJECT56:TOCANVAS=TRUE
ANNOBJECT56:PRIORITY=0
ANNOBJECT56:FPS=16
ANNOBJECT56:PRELOAD=TRUE
ANNOBJECT56:RELEASE=TRUE
ANNOBJECT56:MONITORCOLLISION=FALSE
ANNOBJECT56:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT56:ONFINISHED={VARI_ANIMFINISH^SET(56);}

OBJECT=ANNOBJECT57
ANNOBJECT57:TYPE=ANIMO
ANNOBJECT57:VISIBLE=FALSE
ANNOBJECT57:FILENAME=TEMPLATE.ANN
ANNOBJECT57:TOCANVAS=TRUE
ANNOBJECT57:PRIORITY=0
ANNOBJECT57:FPS=16
ANNOBJECT57:PRELOAD=TRUE
ANNOBJECT57:RELEASE=TRUE
ANNOBJECT57:MONITORCOLLISION=FALSE
ANNOBJECT57:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT57:ONFINISHED={VARI_ANIMFINISH^SET(57);}

OBJECT=ANNOBJECT58
ANNOBJECT58:TYPE=ANIMO
ANNOBJECT58:VISIBLE=FALSE
ANNOBJECT58:FILENAME=TEMPLATE.ANN
ANNOBJECT58:TOCANVAS=TRUE
ANNOBJECT58:PRIORITY=0
ANNOBJECT58:FPS=16
ANNOBJECT58:PRELOAD=TRUE
ANNOBJECT58:RELEASE=TRUE
ANNOBJECT58:MONITORCOLLISION=FALSE
ANNOBJECT58:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT58:ONFINISHED={VARI_ANIMFINISH^SET(58);}

OBJECT=ANNOBJECT59
ANNOBJECT59:TYPE=ANIMO
ANNOBJECT59:VISIBLE=FALSE
ANNOBJECT59:FILENAME=TEMPLATE.ANN
ANNOBJECT59:TOCANVAS=TRUE
ANNOBJECT59:PRIORITY=0
ANNOBJECT59:FPS=16
ANNOBJECT59:PRELOAD=TRUE
ANNOBJECT59:RELEASE=TRUE
ANNOBJECT59:MONITORCOLLISION=FALSE
ANNOBJECT59:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT59:ONFINISHED={VARI_ANIMFINISH^SET(59);}

OBJECT=ANNOBJECT6
ANNOBJECT6:TYPE=ANIMO
ANNOBJECT6:VISIBLE=FALSE
ANNOBJECT6:FILENAME=TEMPLATE.ANN
ANNOBJECT6:TOCANVAS=TRUE
ANNOBJECT6:PRIORITY=0
ANNOBJECT6:FPS=16
ANNOBJECT6:PRELOAD=TRUE
ANNOBJECT6:RELEASE=TRUE
ANNOBJECT6:MONITORCOLLISION=FALSE
ANNOBJECT6:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT6:ONFINISHED={VARI_ANIMFINISH^SET(6);}

OBJECT=ANNOBJECT7
ANNOBJECT7:TYPE=ANIMO
ANNOBJECT7:VISIBLE=FALSE
ANNOBJECT7:FILENAME=TEMPLATE.ANN
ANNOBJECT7:TOCANVAS=TRUE
ANNOBJECT7:PRIORITY=0
ANNOBJECT7:FPS=16
ANNOBJECT7:PRELOAD=TRUE
ANNOBJECT7:RELEASE=TRUE
ANNOBJECT7:MONITORCOLLISION=FALSE
ANNOBJECT7:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT7:ONFINISHED={VARI_ANIMFINISH^SET(7);}

OBJECT=ANNOBJECT8
ANNOBJECT8:TYPE=ANIMO
ANNOBJECT8:VISIBLE=FALSE
ANNOBJECT8:FILENAME=TEMPLATE.ANN
ANNOBJECT8:TOCANVAS=TRUE
ANNOBJECT8:PRIORITY=0
ANNOBJECT8:FPS=16
ANNOBJECT8:PRELOAD=TRUE
ANNOBJECT8:RELEASE=TRUE
ANNOBJECT8:MONITORCOLLISION=FALSE
ANNOBJECT8:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT8:ONFINISHED={VARI_ANIMFINISH^SET(8);}

OBJECT=ANNOBJECT9
ANNOBJECT9:TYPE=ANIMO
ANNOBJECT9:VISIBLE=FALSE
ANNOBJECT9:FILENAME=TEMPLATE.ANN
ANNOBJECT9:TOCANVAS=TRUE
ANNOBJECT9:PRIORITY=0
ANNOBJECT9:FPS=16
ANNOBJECT9:PRELOAD=TRUE
ANNOBJECT9:RELEASE=TRUE
ANNOBJECT9:MONITORCOLLISION=FALSE
ANNOBJECT9:MONITORCOLLISIONALPHA=FALSE
ANNOBJECT9:ONFINISHED={VARI_ANIMFINISH^SET(9);}

OBJECT=ANNREX
ANNREX:TYPE=ANIMO
ANNREX:VISIBLE=TRUE
ANNREX:FILENAME=REX.ANN
ANNREX:TOCANVAS=TRUE
ANNREX:PRIORITY=0
ANNREX:FPS=16
ANNREX:PRELOAD=TRUE
ANNREX:RELEASE=TRUE
ANNREX:MONITORCOLLISION=FALSE
ANNREX:MONITORCOLLISIONALPHA=FALSE
ANNREX:ONSIGNAL^NOPATH={BEHNOPATH^RUN();BEHINVHIDECURRENTITEM^RUN();}
ANNREX:ONSIGNAL^ATGOAL={BEHATGOAL^RUN();@IF("VARSAUXCLICKED","!_",""NULL"","BFITMP71","");@IF("VARI_NEXTTRIGGER","_","120","BFITMP74","BFITMP75");}
ANNREX:ONFOCUSON={VARI_TEMPITER^SET(0);}
ANNREX:ONFINISHED^BEZRUCH_STOP={BEHSEQARRSETDIR^RUN("D");VARSTEMP0INSIDE^SET(["IDLE_"+VARI_REXDIRTOGADA]);VARITEMP2INSIDE^SET(ANNREX^GETNOFINEVENT(VARSTEMP0INSIDE));ANNREX^SETFRAME(VARSTEMP0INSIDE,[VARITEMP2INSIDE-1]);}

OBJECT=ANNSELECT
ANNSELECT:TYPE=ANIMO
ANNSELECT:VISIBLE=TRUE
ANNSELECT:FILENAME=BUT.ANN
ANNSELECT:TOCANVAS=TRUE
ANNSELECT:PRIORITY=2900
ANNSELECT:FPS=16
ANNSELECT:PRELOAD=TRUE
ANNSELECT:RELEASE=TRUE
ANNSELECT:MONITORCOLLISION=FALSE
ANNSELECT:MONITORCOLLISIONALPHA=FALSE

OBJECT=STL_IDLE
STL_IDLE:TYPE=ANIMO
STL_IDLE:VISIBLE=FALSE
STL_IDLE:FILENAME=$COMMON\STL_IDLE.ANN
STL_IDLE:TOCANVAS=FALSE
STL_IDLE:PRIORITY=0
STL_IDLE:FPS=1
STL_IDLE:PRELOAD=TRUE
STL_IDLE:RELEASE=TRUE
STL_IDLE:MONITORCOLLISION=FALSE
STL_IDLE:MONITORCOLLISIONALPHA=FALSE
STL_IDLE:ONFRAMECHANGED^ELAPSE={@IF("SNDATGOAL^ISPLAYING()'TRUE||SEQBLANK^ISPLAYING()'TRUE","BFITMP76","");ARRIDLETIME^ADDAT(0,1);ARRIDLETIME^ADDAT(1,1);VARITEMP0INSIDE^SET([ARRIDLETIME^GET(0)%30]);@IF("VARITEMP0INSIDE'0&&SNDIDLEREX^ISPLAYING()'FALSE","BFITMP77","");VARITEMP0INSIDE^SET(ARRIDLETIME^GET(1));@IF("VARITEMP0INSIDE",">","20","BFITMP79","");}

OBJECT=STL_ARCADE
STL_ARCADE:TYPE=ANIMO
STL_ARCADE:VISIBLE=FALSE
STL_ARCADE:FILENAME=$COMMON\STL_ARCADE.ANN
STL_ARCADE:TOCANVAS=FALSE
STL_ARCADE:PRIORITY=0
STL_ARCADE:FPS=30
STL_ARCADE:PRELOAD=TRUE
STL_ARCADE:RELEASE=TRUE
STL_ARCADE:MONITORCOLLISION=FALSE
STL_ARCADE:MONITORCOLLISIONALPHA=FALSE
STL_ARCADE:ONFRAMECHANGED^ELAPSE={BEHSPYMOVE^RUN();VARD_3DELAPSED^SET(WPATH^MOVEOBJECTS());VARI_BKGX^SET(WPATH^GETBKGPOSX());VARI_BKGY^SET(WPATH^GETBKGPOSY());@IF("VARI_BKGX!'VARI_BKGXLAST||VARI_BKGY!'VARI_BKGYLAST","BFITMP81","");BEHANIMATEREX^RUN();@IF("VARB_KRETACTIVE","_","TRUE","BFITMP82","");BEHPOSTMOVE^RUN();}

OBJECT=STL_INVENTORY
STL_INVENTORY:TYPE=ANIMO
STL_INVENTORY:VISIBLE=FALSE
STL_INVENTORY:FILENAME=$COMMON\STL_INVENTORY.ANN
STL_INVENTORY:TOCANVAS=FALSE
STL_INVENTORY:PRIORITY=0
STL_INVENTORY:FPS=30
STL_INVENTORY:PRELOAD=TRUE
STL_INVENTORY:RELEASE=TRUE
STL_INVENTORY:MONITORCOLLISION=FALSE
STL_INVENTORY:MONITORCOLLISIONALPHA=FALSE
STL_INVENTORY:ONFRAMECHANGED^ELAPSE={@IF("VARI_INVMAINRADIUS'96&&VARI_INVMENUVISIBLE'1","BFITMP83","");BEHINVPLACEITEMS^RUN();VARI_INVMAINRADIUS^ADD([VARI_INVMENUVISIBLE*16]);VARD_INVMENUOPACITY^ADD([42.5*VARI_INVMENUVISIBLE]);@IF("VARI_INVMAINRADIUS","_","0","BFITMP84","");}

OBJECT=BTNITEM
BTNITEM:TYPE=BUTTON
BTNITEM:VISIBLE=FALSE
BTNITEM:ENABLE=TRUE
BTNITEM:DRAGGABLE=FALSE
BTNITEM:GFXONMOVE=ANNSELECT

OBJECT=TXTCOORDX
TXTCOORDX:TYPE=TEXT
TXTCOORDX:VISIBLE=TRUE
TXTCOORDX:FONT=FARIAL
TXTCOORDX:TOCANVAS=TRUE
TXTCOORDX:RECT=20,270,40,290
TXTCOORDX:PRIORITY=10000
TXTCOORDX:HJUSTIFY=LEFT
TXTCOORDX:MONITORCOLLISION=FALSE
TXTCOORDX:MONITORCOLLISIONALPHA=FALSE

OBJECT=TXTCOORDY
TXTCOORDY:TYPE=TEXT
TXTCOORDY:VISIBLE=TRUE
TXTCOORDY:FONT=FARIAL
TXTCOORDY:TOCANVAS=TRUE
TXTCOORDY:RECT=20,300,40,320
TXTCOORDY:PRIORITY=10000
TXTCOORDY:HJUSTIFY=LEFT
TXTCOORDY:VJUSTIFY=TRUE
TXTCOORDY:MONITORCOLLISION=FALSE
TXTCOORDY:MONITORCOLLISIONALPHA=FALSE

OBJECT=TXTCLICK
TXTCLICK:TYPE=TEXT
TXTCLICK:VISIBLE=TRUE
TXTCLICK:FONT=FARIAL
TXTCLICK:TOCANVAS=TRUE
TXTCLICK:RECT=20,330,40,350
TXTCLICK:PRIORITY=10000
TXTCLICK:HJUSTIFY=LEFT
TXTCLICK:VJUSTIFY=TRUE
TXTCLICK:MONITORCOLLISION=FALSE
TXTCLICK:MONITORCOLLISIONALPHA=FALSE

OBJECT=TXTDBG
TXTDBG:TYPE=TEXT
TXTDBG:VISIBLE=TRUE
TXTDBG:FONT=FARIAL
TXTDBG:TOCANVAS=TRUE
TXTDBG:RECT=20,360,40,380
TXTDBG:PRIORITY=10000
TXTDBG:HJUSTIFY=LEFT
TXTDBG:VJUSTIFY=TRUE
TXTDBG:MONITORCOLLISION=FALSE
TXTDBG:MONITORCOLLISIONALPHA=FALSE

OBJECT=SEQBLANK
SEQBLANK:TYPE=SEQUENCE
SEQBLANK:FILENAME=BLANK.SEQ
SEQBLANK:ONFINISHED={BEHSEQARRSTOPTALKSEQ^RUN();BEHSEQARRNEXT^RUN();}

OBJECT=GRPMOVE
GRPMOVE:TYPE=GROUP

OBJECT=GRPHIDE
GRPHIDE:TYPE=GROUP

OBJECT=SNDATGOAL
SNDATGOAL:TYPE=SOUND
SNDATGOAL:FILENAME=NULL_ATGOAL.WAV
SNDATGOAL:PRELOAD=FALSE
SNDATGOAL:FLUSHAFTERPLAYED=FALSE
SNDATGOAL:ONFINISHED={@IF("VARS_SEQARRKTOGADA'"ANNREX"||VARS_SEQARRKTOGADA'"ANNKRET"","BFITMP85","");}

OBJECT=SNDIDLEREX
SNDIDLEREX:TYPE=SOUND
SNDIDLEREX:FILENAME=NULL_IDLEREX.WAV
SNDIDLEREX:PRELOAD=TRUE
SNDIDLEREX:FLUSHAFTERPLAYED=FALSE
SNDIDLEREX:ONFINISHED={VARSTEMP0INSIDE^SET(ANNREX^GETEVENTNAME());ANNREX^STOP(FALSE);@IF(VARSTEMP0INSIDE^FIND("GADA"),"_","-1","BFITMP86","BFITMP87");}

OBJECT=SNDIDLEKRET
SNDIDLEKRET:TYPE=SOUND
SNDIDLEKRET:FILENAME=NULL_IDLEKRET.WAV
SNDIDLEKRET:PRELOAD=TRUE
SNDIDLEKRET:FLUSHAFTERPLAYED=FALSE
SNDIDLEKRET:ONFINISHED={VARSTEMP0INSIDE^SET(ANNKRET^GETEVENTNAME());ANNKRET^STOP(FALSE);@IF(VARSTEMP0INSIDE^FIND("GADA"),"_","-1","BFITMP88","BFITMP89");}

OBJECT=SNDTAKE
SNDTAKE:TYPE=SOUND
SNDTAKE:FILENAME=SFX_ARCADETAKE.WAV
SNDTAKE:PRELOAD=TRUE
SNDTAKE:FLUSHAFTERPLAYED=FALSE

OBJECT=SNDUSE
SNDUSE:TYPE=SOUND
SNDUSE:FILENAME=SFX_ARCADEUSE.WAV
SNDUSE:PRELOAD=TRUE
SNDUSE:FLUSHAFTERPLAYED=FALSE

OBJECT=FARIAL
FARIAL:TYPE=FONT
FARIAL:DEF_ARIAL_STANDARD_14=$COMMON\ARIAL14.FNT

OBJECT=ARRTABLE
ARRTABLE:TYPE=ARRAY

OBJECT=ARRGOTOX
ARRGOTOX:TYPE=ARRAY

OBJECT=ARRGOTOY
ARRGOTOY:TYPE=ARRAY

OBJECT=ARRIDLETIME
ARRIDLETIME:TYPE=ARRAY

OBJECT=ARRSTART0X
ARRSTART0X:TYPE=ARRAY

OBJECT=ARRSTART0Y
ARRSTART0Y:TYPE=ARRAY

OBJECT=ARRSTART1X
ARRSTART1X:TYPE=ARRAY

OBJECT=ARRSTART1Y
ARRSTART1Y:TYPE=ARRAY

OBJECT=ARRGO0X
ARRGO0X:TYPE=ARRAY

OBJECT=ARRGO0Y
ARRGO0Y:TYPE=ARRAY

OBJECT=ARRGO1Y
ARRGO1Y:TYPE=ARRAY

OBJECT=ARRGO1X
ARRGO1X:TYPE=ARRAY

OBJECT=ARRSTARTNAME0
ARRSTARTNAME0:TYPE=ARRAY

OBJECT=ARRSTARTNAME1
ARRSTARTNAME1:TYPE=ARRAY

OBJECT=ARRGONAME0
ARRGONAME0:TYPE=ARRAY

OBJECT=ARRGONAME1
ARRGONAME1:TYPE=ARRAY

OBJECT=ARRSEQUENCE
ARRSEQUENCE:TYPE=ARRAY

OBJECT=ARRTEMP
ARRTEMP:TYPE=ARRAY

OBJECT=MOUSE
MOUSE:TYPE=MOUSE
MOUSE:ONCLICK^LEFT={@IF("VARB_SCENELOCK","_","TRUE","BFITMP90","");@IF("VARB_SEQARRSTOPABLE'FALSE&&VARB_SEQARRPLAYING'TRUE","BFITMP91","");@IF("VARB_SEQARRLOCKTALK","_","TRUE","BFITMP98","BFITMP99");VARI_CLICKPOSX^SET(MOUSE^GETPOSX());VARI_CLICKPOSY^SET(MOUSE^GETPOSY());VARS_CLICKINVENTORYSELECTOR^SET(CANVASOBSERVER^GETGRAPHICSAT(VARI_CLICKPOSX,VARI_CLICKPOSY,TRUE,2998,2998,FALSE));}
MOUSE:ONMOVE={@IF("VARB_SEQARRSTOPABLE'FALSE&&VARB_SEQARRPLAYING'TRUE","BFITMP100","");@IF("VARB_SCENELOCK","_","TRUE","BFITMP101","");@IF("VARS_CURRENTITEMOBJECT","!_",""NULL"","BFITMP102","");VARS_INVMAINMOVEINVENTORYSELECTOR^SET(CANVASOBSERVER^GETGRAPHICSAT(MOUSE^GETPOSX(),MOUSE^GETPOSY(),TRUE,2998,2998,FALSE));VARS_INVMAINMOVEOBJECTSELECTOR^SET(CANVASOBSERVER^GETGRAPHICSAT(MOUSE^GETPOSX(),MOUSE^GETPOSY(),TRUE,1,VARI_SCENEMAXPRIORITY,FALSE));}

OBJECT=CNVLOADER
CNVLOADER:TYPE=CNVLOADER

OBJECT=CANVASOBSERVER
CANVASOBSERVER:TYPE=CANVAS_OBSERVER

OBJECT=FCOLOR
FCOLOR:TYPE=STATICFILTER
FCOLOR:ACTION=COLORCHANNEL

OBJECT=WPATH
WPATH:TYPE=WORLD
WPATH:FILENAME=TEMPLATE.SEK

OBJECT=SDIALOG
SDIALOG:TYPE=STRUCT
SDIALOG:FIELDS=GUID<INTEGER>,TEXT<STRING>

OBJECT=SITEM
SITEM:TYPE=STRUCT
SITEM:FIELDS=GUID<INTEGER>,NAME<STRING>,PARENT<INTEGER>,BASE<STRING>,EMPTY<INTEGER>

OBJECT=SOBJECT
SOBJECT:TYPE=STRUCT
SOBJECT:FIELDS=NAME<STRING>,IDNAME<STRING>,TYPE<INTEGER>,SPARAM0<STRING>,SPARAM1<STRING>,SPARAM2<STRING>,IPARAM0<INTEGER>,IPARAM1<INTEGER>,IPARAM2<INTEGER>

OBJECT=STEMPOBJ
STEMPOBJ:TYPE=STRUCT
STEMPOBJ:FIELDS=NAME<STRING>,IDNAME<STRING>,TYPE<INTEGER>,SPARAM0<STRING>,SPARAM1<STRING>,SPARAM2<STRING>,IPARAM0<INTEGER>,IPARAM1<INTEGER>,IPARAM2<INTEGER>

OBJECT=DBDIALOGS
DBDIALOGS:TYPE=DATABASE
DBDIALOGS:MODEL=SDIALOG

OBJECT=DBITEMS
DBITEMS:TYPE=DATABASE
DBITEMS:MODEL=SITEM

OBJECT=DBOBJECTS
DBOBJECTS:TYPE=DATABASE
DBOBJECTS:MODEL=SOBJECT

OBJECT=DBTEMPOBJ
DBTEMPOBJ:TYPE=DATABASE
DBTEMPOBJ:MODEL=SOBJECT

OBJECT=DBDEFAULT
DBDEFAULT:TYPE=DATABASE
DBDEFAULT:MODEL=SOBJECT

OBJECT=KEYBOARD
KEYBOARD:TYPE=KEYBOARD

OBJECT=_LOADGAME_
_LOADGAME_:TYPE=BEHAVIOUR
_LOADGAME_:CODE={@IF(G_ARRDATAS^FIND(G_SARCADESCENE),">","-1","BFITMP1122","BFITMP1123");}


OBJECT=_NEWGAME_
_NEWGAME_:TYPE=BEHAVIOUR
_NEWGAME_:CODE={@IF(G_ARRDATAS^FIND(G_SARCADESCENE),">","-1","BFITMP1124","BFITMP1125");}


OBJECT=__HELPEND__
__HELPEND__:TYPE=BEHAVIOUR
__HELPEND__:CODE={MOUSE^ENABLESIGNAL();KEYBOARD^ENABLE();CNVLOADER^RELEASE([G_SCUTSCENE+".CNV"]);__GRHELP__^REMOVEALL();G_MENU^SHOW(TRUE);VARICUTSCENEEXIT^SET(1);BEHAUXPAUSEEND^RUN();}


OBJECT=__HELPSTART__
__HELPSTART__:TYPE=BEHAVIOUR
__HELPSTART__:CODE={SCENENAME^SET(PRZYGODA^GETCURRENTSCENE());MOUSE^DISABLESIGNAL();__KEYB__^SET(KEYBOARD^ISENABLED());KEYBOARD^DISABLE();__HSPOTMAX__^SET(*SCENENAME^GETMAXHSPRIORITY());__HSPOTMIN__^SET(*SCENENAME^GETMINHSPRIORITY());*SCENENAME^GETPLAYINGANIMO("__GRHELP__");CNVLOADER^LOAD([G_SCUTSCENE+".CNV"]);G_MENU^SHOW(FALSE);}


OBJECT=__INIT__
__INIT__:TYPE=BEHAVIOUR
__INIT__:CODE={FCOLOR^SETPROPERTY("CANUNDO","TRUE");FCOLOR^SETPROPERTY("CHANNELS","B");__GAME_INIT__^RUN();BEHSETSCENE^RUN();BEHSAVESCENE^RUN();ARRIDLETIME^ADD(0,0);VARI_3DPATHID^SET(9000);VARI_NEXTTRIGGER^SET(-1);VARI_NEXTTRIGGERKRET^SET(-1);VARS_CLICKPLACE^SET(NULL);VARS_CLICKBOTHPLACE^SET(NULL);VARSCURRARCADE^SET(["$COMMON\"+G_SARCADESCENE+"0.DTA"]);VARSCURRITEMS^SET("$COMMON\ITEMS0.DTA");__LOAD_DB__^RUN();__LOAD_ITEMS__^RUN();ANNSELECT^SETANCHOR("CENTER");WPATH^SETGRAVITY(0,0,0);WPATH^SETACTIVE(100,FALSE);WPATH^SETACTIVE(101,FALSE);WPATH^SETVELOCITY(100,0,0,0);WPATH^SETVELOCITY(101,0,0,0);WPATH^SETLIMIT(100,-3000,-3000,0,3000,3000,0);WPATH^SETLIMIT(101,-3000,-3000,0,3000,3000,0);ANNREX^SETPOSITION(400,300);ANNKRET^SETPOSITION(400,300);WPATH^LINK(100,"ANNREX");@IF("VARB_KRETACTIVE","_","TRUE","BFITMP1126","");VARS_ARCADESCENELAST^SET(G_SARCADESCENELAST);G_SARCADESCENELAST^SET(G_SARCADESCENE);BEHINITSCRIPT^RUN();BEHPREINIT^RUN();STL_ARCADE^PLAY("ELAPSE");STL_IDLE^PLAY("ELAPSE");WPATH^START();VARI_TEMPITER^SET(DBOBJECTS^FIND("TYPE",102,0));BEHDBSELECTOBJ^RUN(VARI_TEMPITER);@IF("SOBJECT|IPARAM0","_","0","BFITMP1127","BFITMP1128");BEHPOSTINIT^RUN();}


OBJECT=__LOAD_DB__
__LOAD_DB__:TYPE=BEHAVIOUR
__LOAD_DB__:CODE={VARSTEMP0INSIDE^SET([G_SARCADESCENE+".CNV"]);CNVLOADER^LOAD(VARSTEMP0INSIDE);DBOBJECTS^LOAD(VARSCURRARCADE);VARI_TEMPITER^SET(DBOBJECTS^GETROWSNO());VARI_TEMPNO^SET(0);VARITEMP2INSIDE^SET(0);@LOOP("{VARI_TEMPITER^SET(_I_);DBOBJECTS^SELECT(VARI_TEMPITER);SOBJECT^SET("DBOBJECTS_CURSOR");VARI_OBJECTTYPESELECTOR^SET(SOBJECT|TYPE);}",0,DBOBJECTS^GETROWSNO(),1);VARBTEMP0^SET(FALSE);VARITEMP0INSIDE^SET(ARRSTARTNAME0^FIND(G_SARCADESCENELAST));@IF("VARITEMP0INSIDE","_","-1","BFITMP1130","");VARI_POSREXX^SET(ARRSTART0X^GET(VARITEMP0INSIDE));VARI_POSREXY^SET(ARRSTART0Y^GET(VARITEMP0INSIDE));VARI_POSREXXGOTO^SET(ARRGO0X^GET(VARITEMP0INSIDE));VARI_POSREXYGOTO^SET(ARRGO0Y^GET(VARITEMP0INSIDE));VARI_POSREXXSAVE^SET(VARI_POSREXX);VARI_POSREXYSAVE^SET(VARI_POSREXY);@IF("VARBTEMP0","_","TRUE","BFITMP1131","");VARDTEMP0^SET([VARI_POSREXX+VARI_BKGXOFFSET]);VARDTEMP1^SET([VARI_POSREXY+VARI_BKGYOFFSET]);VARDTEMP0^ADD(0.2);VARDTEMP1^ADD(0.2);WPATH^SETPOSITION(100,VARDTEMP0,VARDTEMP1,0.0);WPATH^FINDPATH(100,VARI_3DPATHID,[VARI_POSREXXGOTO+VARI_BKGXOFFSET],[VARI_POSREXYGOTO+VARI_BKGYOFFSET],0,FALSE);VARBTEMP0^SET(FALSE);@IF("VARB_KRETACTIVE","_","TRUE","BFITMP1135","");DBITEMS^LOAD(VARSCURRITEMS);BEHDBSELECTOBJT^RUN(102);@IF("SOBJECT|IPARAM0","_","0","BFITMP1136","");}


OBJECT=__LOAD_ITEMS__
__LOAD_ITEMS__:TYPE=BEHAVIOUR
__LOAD_ITEMS__:CODE={VARI_INVENTORYCOUNT^SET(0);@LOOP("{VARSTEMP0INSIDE^SET(["ANNITEM"+_I_]);*VARSTEMP0INSIDE^LOAD("TEMPLATE.ANN");*VARSTEMP0INSIDE^HIDE();}",0,10,1);@LOOP("{VARI_TEMPITER^SET(_I_);DBITEMS^SELECT(VARI_TEMPITER);SITEM^SET("DBITEMS_CURSOR");@IF("SITEM|EMPTY","_","1","BFITMP1137","");}",0,10,1);}


OBJECT=__PAUSEEND__
__PAUSEEND__:TYPE=BEHAVIOUR
__PAUSEEND__:CODE={MOUSE^ENABLESIGNAL();KEYBOARD^ENABLE();__GRHELP__^REMOVEALL();BEHAUXPAUSEEND^RUN();}


OBJECT=__PAUSESTART__
__PAUSESTART__:TYPE=BEHAVIOUR
__PAUSESTART__:CODE={SCENENAME^SET(PRZYGODA^GETCURRENTSCENE());MOUSE^DISABLESIGNAL();__KEYB__^SET(KEYBOARD^ISENABLED());KEYBOARD^DISABLE();__HSPOTMAX__^SET(*SCENENAME^GETMAXHSPRIORITY());__HSPOTMIN__^SET(*SCENENAME^GETMINHSPRIORITY());*SCENENAME^GETPLAYINGANIMO("__GRHELP__");}


OBJECT=__SAVEPOINT__
__SAVEPOINT__:TYPE=BEHAVIOUR
__SAVEPOINT__:CODE={BEHSAVEONMENU^RUN();VARI_TEMPSELECTOR^SET(DBOBJECTS^FIND("TYPE",105,0));DBOBJECTS^SELECT(VARI_TEMPSELECTOR);SOBJECT^SET("DBOBJECTS_CURSOR");@IF("SOBJECT|IDNAME","_",""SAVE"","BFITMP1138","BFITMP1139");VARI_TEMPSELECTOR^SET(DBOBJECTS^FIND("TYPE",106,0));DBOBJECTS^SELECT(VARI_TEMPSELECTOR);SOBJECT^SET("DBOBJECTS_CURSOR");@IF("SOBJECT|IDNAME","_",""SAVE"","BFITMP1140","BFITMP1141");VARI_TEMPSELECTOR^SET(DBOBJECTS^FIND("TYPE",145,0));DBOBJECTS^SELECT(VARI_TEMPSELECTOR);SOBJECT^SET("DBOBJECTS_CURSOR");@IF("SOBJECT|IDNAME","_",""SAVE"","BFITMP1142","BFITMP1143");VARI_TEMPSELECTOR^SET(DBOBJECTS^FIND("TYPE",146,0));DBOBJECTS^SELECT(VARI_TEMPSELECTOR);SOBJECT^SET("DBOBJECTS_CURSOR");@IF("SOBJECT|IDNAME","_",""SAVE"","BFITMP1144","BFITMP1145");}


OBJECT=BEHANIMATEKRET
BEHANIMATEKRET:TYPE=BEHAVIOUR
BEHANIMATEKRET:CODE={@IF("VARB_TELEPORTRUN'FALSE&&VARB_LOCKMOVE'FALSE","BFITMP1152","");}


OBJECT=BEHANIMATEREX
BEHANIMATEREX:TYPE=BEHAVIOUR
BEHANIMATEREX:CODE={@IF("VARB_LOCKMOVE","_","FALSE","BFITMP1167","");}


OBJECT=BEHARCADEGETLASTSCENE
BEHARCADEGETLASTSCENE:TYPE=BEHAVIOUR
BEHARCADEGETLASTSCENE:CODE={@RETURN(VARS_ARCADESCENELAST);}


OBJECT=BEHARCADEGOTO
BEHARCADEGOTO:TYPE=BEHAVIOUR
BEHARCADEGOTO:CODE={G_SARCADESCENE^SET($1);@IF(G_ARRDATAS^FIND(G_SARCADESCENE),">","-1","BFITMP1168","BFITMP1169");}


OBJECT=BEHARCADELOCKSCENE
BEHARCADELOCKSCENE:TYPE=BEHAVIOUR
BEHARCADELOCKSCENE:CODE={@IF("$1","_","TRUE","BFITMP1170","BFITMP1171");}


OBJECT=BEHARCADESETMAXPRIORITY
BEHARCADESETMAXPRIORITY:TYPE=BEHAVIOUR
BEHARCADESETMAXPRIORITY:CODE={VARI_SCENEMAXPRIORITY^SET($1);}


OBJECT=BEHARCADEISFIRSTENTER
BEHARCADEISFIRSTENTER:TYPE=BEHAVIOUR
BEHARCADEISFIRSTENTER:CODE={@RETURN(VARB_SCENEFIRSTENTER);}


OBJECT=BEHDBGETNAME
BEHDBGETNAME:TYPE=BEHAVIOUR
BEHDBGETNAME:CODE={@RETURN(SOBJECT|IDNAME);}


OBJECT=BEHDBGETPARAM0
BEHDBGETPARAM0:TYPE=BEHAVIOUR
BEHDBGETPARAM0:CODE={@RETURN(SOBJECT|IPARAM0);}


OBJECT=BEHDBGETPARAM1
BEHDBGETPARAM1:TYPE=BEHAVIOUR
BEHDBGETPARAM1:CODE={@RETURN(SOBJECT|IPARAM1);}


OBJECT=BEHDBGETPARAM2
BEHDBGETPARAM2:TYPE=BEHAVIOUR
BEHDBGETPARAM2:CODE={@RETURN(SOBJECT|IPARAM2);}


OBJECT=BEHDBGETSIZE
BEHDBGETSIZE:TYPE=BEHAVIOUR
BEHDBGETSIZE:CODE={@RETURN(DBOBJECTS^GETROWSNO());}


OBJECT=BEHDBGETTEMPPARAM0
BEHDBGETTEMPPARAM0:TYPE=BEHAVIOUR
BEHDBGETTEMPPARAM0:CODE={@RETURN(STEMPOBJ|IPARAM0);}


OBJECT=BEHDBGETTEMPPARAM1
BEHDBGETTEMPPARAM1:TYPE=BEHAVIOUR
BEHDBGETTEMPPARAM1:CODE={@RETURN(STEMPOBJ|IPARAM1);}


OBJECT=BEHDBGETTEMPPARAM2
BEHDBGETTEMPPARAM2:TYPE=BEHAVIOUR
BEHDBGETTEMPPARAM2:CODE={@RETURN(STEMPOBJ|IPARAM2);}


OBJECT=BEHDBGETTYPE
BEHDBGETTYPE:TYPE=BEHAVIOUR
BEHDBGETTYPE:CODE={@RETURN(SOBJECT|TYPE);}


OBJECT=BEHDBLOADTEMPOBJ
BEHDBLOADTEMPOBJ:TYPE=BEHAVIOUR
BEHDBLOADTEMPOBJ:CODE={VARS_SCENETEMPOBJS^SET($1);VARS_SCENETEMPOBJS^SET(["$COMMON\"+VARS_SCENETEMPOBJS+"0.DTA"]);DBTEMPOBJ^REMOVEALL();DBTEMPOBJ^LOAD(VARS_SCENETEMPOBJS);}


OBJECT=BEHDBSELECTOBJ
BEHDBSELECTOBJ:TYPE=BEHAVIOUR
BEHDBSELECTOBJ:CODE={DBOBJECTS^SELECT($1);SOBJECT^SET("DBOBJECTS_CURSOR");}


OBJECT=BEHDBSELECTOBJS
BEHDBSELECTOBJS:TYPE=BEHAVIOUR
BEHDBSELECTOBJS:CODE={VARI_TEMPSELECTOR^SET(DBOBJECTS^FIND("IDNAME",$1,0));@IF("VARI_TEMPSELECTOR",">","-1","BFITMP1172","BFITMP1173");@RETURN(VARBTEMP0INSIDE);}


OBJECT=BEHDBSELECTOBJT
BEHDBSELECTOBJT:TYPE=BEHAVIOUR
BEHDBSELECTOBJT:CODE={VARI_TEMPSELECTOR^SET(DBOBJECTS^FIND("TYPE",$1,0));@IF("VARI_TEMPSELECTOR",">","-1","BFITMP1174","BFITMP1175");@RETURN(VARBTEMP0INSIDE);}


OBJECT=BEHDBSELECTTEMPOBJ
BEHDBSELECTTEMPOBJ:TYPE=BEHAVIOUR
BEHDBSELECTTEMPOBJ:CODE={DBTEMPOBJ^SELECT($1);STEMPOBJ^SET("DBTEMPOBJ_CURSOR");}


OBJECT=BEHDBSELECTTEMPOBJS
BEHDBSELECTTEMPOBJS:TYPE=BEHAVIOUR
BEHDBSELECTTEMPOBJS:CODE={VARI_TEMPSELECTOR^SET(DBTEMPOBJ^FIND("IDNAME",$1,0));@IF("VARI_TEMPSELECTOR",">","-1","BFITMP1176","BFITMP1177");@RETURN(VARBTEMP0INSIDE);}


OBJECT=BEHDBSELECTTEMPOBJT
BEHDBSELECTTEMPOBJT:TYPE=BEHAVIOUR
BEHDBSELECTTEMPOBJT:CODE={VARI_TEMPSELECTOR^SET(DBTEMPOBJ^FIND("TYPE",$1,0));@IF("VARI_TEMPSELECTOR",">","-1","BFITMP1178","BFITMP1179");@RETURN(VARBTEMP0INSIDE);}


OBJECT=BEHDBSETPARAM0
BEHDBSETPARAM0:TYPE=BEHAVIOUR
BEHDBSETPARAM0:CODE={SOBJECT|IPARAM0^SET($1);DBOBJECTS_CURSOR^SET("SOBJECT");DBOBJECTS^SAVE(VARSCURRARCADE);}


OBJECT=BEHDBSETPARAM1
BEHDBSETPARAM1:TYPE=BEHAVIOUR
BEHDBSETPARAM1:CODE={SOBJECT|IPARAM1^SET($1);DBOBJECTS_CURSOR^SET("SOBJECT");DBOBJECTS^SAVE(VARSCURRARCADE);}


OBJECT=BEHDBSETPARAM2
BEHDBSETPARAM2:TYPE=BEHAVIOUR
BEHDBSETPARAM2:CODE={SOBJECT|IPARAM2^SET($1);DBOBJECTS_CURSOR^SET("SOBJECT");DBOBJECTS^SAVE(VARSCURRARCADE);}


OBJECT=BEHDBSETTEMPPARAM0
BEHDBSETTEMPPARAM0:TYPE=BEHAVIOUR
BEHDBSETTEMPPARAM0:CODE={STEMPOBJ|IPARAM0^SET($1);DBTEMPOBJ_CURSOR^SET("STEMPOBJ");DBTEMPOBJ^SAVE(VARS_SCENETEMPOBJS);}


OBJECT=BEHDBSETTEMPPARAM1
BEHDBSETTEMPPARAM1:TYPE=BEHAVIOUR
BEHDBSETTEMPPARAM1:CODE={STEMPOBJ|IPARAM1^SET($1);DBTEMPOBJ_CURSOR^SET("STEMPOBJ");DBTEMPOBJ^SAVE(VARS_SCENETEMPOBJS);}


OBJECT=BEHDBSETTEMPPARAM2
BEHDBSETTEMPPARAM2:TYPE=BEHAVIOUR
BEHDBSETTEMPPARAM2:CODE={STEMPOBJ|IPARAM2^SET($1);DBTEMPOBJ_CURSOR^SET("STEMPOBJ");DBTEMPOBJ^SAVE(VARS_SCENETEMPOBJS);}


OBJECT=BEHDBSETTYPE
BEHDBSETTYPE:TYPE=BEHAVIOUR
BEHDBSETTYPE:CODE={SOBJECT|TYPE^SET($1);DBOBJECTS_CURSOR^SET("SOBJECT");DBOBJECTS^SAVE(VARSCURRARCADE);}


OBJECT=BEHDBUPDATEOBJECTS
BEHDBUPDATEOBJECTS:TYPE=BEHAVIOUR
BEHDBUPDATEOBJECTS:CODE={DBOBJECTS_CURSOR^SET("SOBJECT");DBOBJECTS^SAVE(VARSCURRARCADE);}


OBJECT=BEHDBUPDATETEMPOBJ
BEHDBUPDATETEMPOBJ:TYPE=BEHAVIOUR
BEHDBUPDATETEMPOBJ:CODE={DBTEMPOBJ_CURSOR^SET("STEMPOBJ");DBTEMPOBJ^SAVE(VARS_SCENETEMPOBJS);}


OBJECT=BEHDEFAULTIDLEKRET
BEHDEFAULTIDLEKRET:TYPE=BEHAVIOUR
BEHDEFAULTIDLEKRET:CODE={VARI_NULL^SET(0);}


OBJECT=BEHDEFAULTIDLEREX
BEHDEFAULTIDLEREX:TYPE=BEHAVIOUR
BEHDEFAULTIDLEREX:CODE={@IF(ANNREX^GETEVENTNAME(),"!_",""BEZRUCH_START"","BFITMP1180","");}


OBJECT=BEHINVADDITEM
BEHINVADDITEM:TYPE=BEHAVIOUR
BEHINVADDITEM:CODE={VARSTEMP0INSIDE^SET($1);VARITEMP1INSIDE^SET($2);@IF(DBITEMS^FIND("NAME",VARSTEMP0INSIDE,0),"_","-1","BFITMP1183","");}


OBJECT=BEHINVCHECKSPACE
BEHINVCHECKSPACE:TYPE=BEHAVIOUR
BEHINVCHECKSPACE:CODE={VARITEMP0INSIDE^SET(DBITEMS^FIND("EMPTY",0,0));@IF("VARITEMP0INSIDE",">","-1","BFITMP1184","BFITMP1185");@RETURN(VARBTEMP0INSIDE);}


OBJECT=BEHINVCLEARITEMS
BEHINVCLEARITEMS:TYPE=BEHAVIOUR
BEHINVCLEARITEMS:CODE={VARSTEMP0INSIDE^COPYFILE("$COMMON\ITEMS_DEF.DTA","$COMMON\ITEMS0.DTA");DBITEMS^REMOVEALL();DBITEMS^LOAD("$COMMON\ITEMS0.DTA");}


OBJECT=BEHINVFINDITEM
BEHINVFINDITEM:TYPE=BEHAVIOUR
BEHINVFINDITEM:CODE={VARITEMP0INSIDE^SET(DBITEMS^FIND("NAME",$1,0));@IF("VARITEMP0INSIDE",">","-1","BFITMP1186","BFITMP1187");@RETURN(VARBTEMP0INSIDE);}


OBJECT=BEHINVHIDECURRENTITEM
BEHINVHIDECURRENTITEM:TYPE=BEHAVIOUR
BEHINVHIDECURRENTITEM:CODE={VARS_CURRENTITEM^SET("NULL");@IF("VARS_CURRENTITEMOBJECT","!_",""NULL"","BFITMP1188","");}


OBJECT=BEHINVPLACEITEMS
BEHINVPLACEITEMS:TYPE=BEHAVIOUR
BEHINVPLACEITEMS:CODE={VARITEMP1INSIDE^SET([VARI_INVENTORYCOUNT%2]);VARITEMP0INSIDE^SET([VARI_INVENTORYCOUNT@2]);VARDTEMP2INSIDE^SET(VARITEMP0INSIDE);@IF("VARITEMP1INSIDE","_","0","BFITMP1189","");VARDTEMP2INSIDE^MUL(VARD_INVMENUANGLE);VARDTEMP2INSIDE^ADD(90);@LOOP("{VARI_TEMPITER^SET(_I_);VARD_TEMPANGLE^SET([VARD_INVMENUANGLE*VARI_TEMPITER]);VARD_TEMPANGLE^SUB(VARDTEMP2INSIDE);VARDTEMP0INSIDE^COSINUS(VARD_TEMPANGLE);VARDTEMP1INSIDE^SINUS(VARD_TEMPANGLE);VARITEMP0INSIDE^SET([_I_@10]);VARITEMP0INSIDE^MUL(34);VARITEMP0INSIDE^ADD(VARI_INVMAINRADIUS);VARDTEMP0INSIDE^MUL(VARITEMP0INSIDE);VARDTEMP1INSIDE^MUL(VARITEMP0INSIDE);VARDTEMP0INSIDE^ADD(VARI_INVMENUX);VARDTEMP1INSIDE^ADD(VARI_INVMENUY);VARSTEMP0INSIDE^SET(["ANNITEM"+_I_]);*VARSTEMP0INSIDE^SETPOSITION(VARDTEMP0INSIDE,VARDTEMP1INSIDE);*VARSTEMP0INSIDE^SETOPACITY(VARD_INVMENUOPACITY);*VARSTEMP0INSIDE^SHOW();}",0,VARI_INVENTORYCOUNT,1);}


OBJECT=BEHINVREMOVEALLITEMS
BEHINVREMOVEALLITEMS:TYPE=BEHAVIOUR
BEHINVREMOVEALLITEMS:CODE={@LOOP("{VARI_TEMPITER^SET(_I_);DBITEMS^SELECT(VARI_TEMPITER);SITEM^SET("DBITEMS_CURSOR");SITEM|EMPTY^SET(0);SITEM|NAME^SET("NULL");SITEM|BASE^SET("NULL");SITEM|PARENT^SET(0);DBITEMS_CURSOR^SET("SITEM");}",0,10,1);DBITEMS^SAVE(VARSCURRITEMS);__LOAD_ITEMS__^RUN();}


OBJECT=BEHINVREMOVEITEM
BEHINVREMOVEITEM:TYPE=BEHAVIOUR
BEHINVREMOVEITEM:CODE={VARSTEMP0INSIDE^SET($1);VARITEMP0INSIDE^SET(DBITEMS^FIND("NAME",VARSTEMP0INSIDE,0));@IF("VARITEMP0INSIDE",">","-1","BFITMP1190","");}


OBJECT=BEHINVWASUSED
BEHINVWASUSED:TYPE=BEHAVIOUR
BEHINVWASUSED:CODE={VARB_USEWASUSED^SET(TRUE);}


OBJECT=BEHKRETLOCK
BEHKRETLOCK:TYPE=BEHAVIOUR
BEHKRETLOCK:CODE={@IF("$1","_","TRUE","BFITMP1191","BFITMP1192");}


OBJECT=BEHKRETSETSPEED
BEHKRETSETSPEED:TYPE=BEHAVIOUR
BEHKRETSETSPEED:CODE={VARD_KRETSPEED^SET($1);}


OBJECT=BEHLOCKMOVE
BEHLOCKMOVE:TYPE=BEHAVIOUR
BEHLOCKMOVE:CODE={@IF("$1","_","TRUE","BFITMP1193","BFITMP1194");}


OBJECT=BEHOBJEXIST
BEHOBJEXIST:TYPE=BEHAVIOUR
BEHOBJEXIST:CODE={VARSTEMP0INSIDE^SET($1);VARITEMP0INSIDE^SET(DBOBJECTS^FIND("IDNAME",VARSTEMP0INSIDE,0));@IF("VARITEMP0INSIDE",">","-1","BFITMP1195","BFITMP1196");@RETURN(VARBTEMP0INSIDE);}


OBJECT=BEHOBJGET
BEHOBJGET:TYPE=BEHAVIOUR
BEHOBJGET:CODE={VARSTEMP0INSIDE^SET($1);VARITEMP0INSIDE^SET(DBOBJECTS^FIND("IDNAME",VARSTEMP0INSIDE,0));@IF("VARITEMP0INSIDE",">","-1","BFITMP1197","BFITMP1198");@RETURN(VARSTEMP0INSIDE);}


OBJECT=BEHOBJGETEVENT
BEHOBJGETEVENT:TYPE=BEHAVIOUR
BEHOBJGETEVENT:CODE={VARSTEMP0INSIDE^SET($1);VARITEMP0INSIDE^SET(DBOBJECTS^FIND("IDNAME",VARSTEMP0INSIDE,0));@IF("VARITEMP0INSIDE",">","-1","BFITMP1199","BFITMP1200");@RETURN(VARSTEMP1INSIDE);}


OBJECT=BEHOBJGETFRAME
BEHOBJGETFRAME:TYPE=BEHAVIOUR
BEHOBJGETFRAME:CODE={VARSTEMP0INSIDE^SET($1);VARITEMP0INSIDE^SE